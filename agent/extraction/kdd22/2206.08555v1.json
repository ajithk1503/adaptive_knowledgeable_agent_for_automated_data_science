{
    "meta_info": {
        "title": "SOS: Score-based Oversampling for Tabular Data",
        "abstract": "Score-based generative models (SGMs) are a recent breakthrough in generating\nfake images. SGMs are known to surpass other generative models, e.g.,\ngenerative adversarial networks (GANs) and variational autoencoders (VAEs).\nBeing inspired by their big success, in this work, we fully customize them for\ngenerating fake tabular data. In particular, we are interested in oversampling\nminor classes since imbalanced classes frequently lead to sub-optimal training\noutcomes. To our knowledge, we are the first presenting a score-based tabular\ndata oversampling method. Firstly, we re-design our own score network since we\nhave to process tabular data. Secondly, we propose two options for our\ngeneration method: the former is equivalent to a style transfer for tabular\ndata and the latter uses the standard generative policy of SGMs. Lastly, we\ndefine a fine-tuning method, which further enhances the oversampling quality.\nIn our experiments with 6 datasets and 10 baselines, our method outperforms\nother oversampling methods in all cases.",
        "author": "Jayoung Kim, Chaejeong Lee, Yehjin Shin, Sewon Park, Minjung Kim, Noseong Park, Jihoon Cho",
        "link": "http://arxiv.org/abs/2206.08555v1",
        "category": [
            "cs.LG",
            "cs.AI"
        ],
        "additionl_info": "Accepted by KDD 2022"
    },
    "latex_extraction": {
        "content": {
            "section 1": {
                "name": "Introduction",
                "content": "\nTabular data is one of the most frequently occurring data types in the field of data mining and machine learning. However, imbalanced situations happen from time to time, e.g., one class significantly outnumbers other classes. Oversampling minor classes (and as a result, making class sizes even) is a long-standing research topic. Many methods have been proposed, from classical statistical methods~\\cite{10.5555/1622407.1622416,10.1007/11538059,4633969}, to recent deep generative methods~\\cite{DBLP:journals/corr/abs-1803-09655,Mullick_2019_ICCV}.\n\n\n\nAmong many deep generative models, score-based generative models (SGMs~\\cite{songyang}) have gained much attention recently. They adopt a stochastic differential equation (SDE) based framework to model i) the (forward) diffusion process and ii) the (reverse) denoising process (cf. Fig.~\\ref{fig:archi} (a)). The diffusion process is to add increasing noises to the original data $\\mathbf{x}_0$, and the denoising process is the reverse of the diffusion process to remove noises from the noisy data $\\mathbf{x}_T$. Since the space of $\\mathbf{x}$ can be tremendously large, the score function, $\\nabla_\\mathbf{x}\\log p_t(\\mathbf{x})$ is approximated by a \\emph{score neural network} (or simply a score network), where $t \\in [0, T]$ and the step sizes of the diffusion and the denoising processes are typically 1. The ground-truth score values are collected during the forward SDE process. In comparison with generative adversarial networks (GANs), SGMs are known to be superior in terms of generation quality~\\cite{songyang,dockhorn2022scorebased,xiao2022tackling}. However, one drawback of SGMs is that they require large-scale computation, compared to other generative models. {The main reason is that SGMs sometimes require long-step SDEs, e.g., $T=1,000$ for images in~\\cite{songyang}. It takes long time to conduct the denoising process with such a large number of steps. At the same time, however, it is also known that small $T$ values work well for time series~\\cite{rasul2021autoregressive}.}\n\nIn this paper, we propose a novel \\underline{\\textbf{S}}core-based \\underline{\\textbf{O}}ver\\underline{\\textbf{S}}ampling (SOS) method for tabular data and found that i) $T$ can be small in our case because of our model design, ii) the score network architecture should be significantly redesigned, and iii) a fine-tuning method, inspired by one characteristic of imbalanced tabular data that we have both target and non-target classes, can further enhance the synthesis quality.\n\nAs shown in Fig.~\\ref{fig:archi} (b), we separately train two SGMs, one for the non-target (or major) class and the other for the target (or minor) class to oversample --- for simplicity but without loss of generality, we assume the binary class data, but our model is such flexible that multiple minor classes can be augmented. In other words, we separately collect the ground-truth score values of the target and non-target classes and train the score networks. Therefore, their reverse SDEs will be very different. After that, we have two model designs denoted as Option 1 and 2 in Fig.~\\ref{fig:archi} (b). By combining the non-target class's forward SDE and the target class's reverse SDE, firstly, we can create a style transfer. A non-target record $\\mathbf{x}^+_0$ is converted to a noisy record $\\mathbf{x}^+_T$, from which a fake target record $\\hat{\\mathbf{x}}^-_0$ is created. In other words, the style (or class label) of $\\mathbf{x}^+_0$ is transferred to that of the target class. Secondly, we sample a noisy vector $\\mathbf{z}$ and generate a fake target record.\n\nSince the forward SDE is a pure Brownian motion process shared by the non-target and the target classes, it constitutes a single noisy space. Since we maintain a single noisy space for both of them, $\\mathbf{x}^+_T$ is a correct noisy representation of the non-target record $\\mathbf{x}^+_0$ even when it comes to the target class's reverse SDE. Therefore, the first option in Fig.~\\ref{fig:archi} (b) can be considered as a style transfer-based oversampling method. Its main motivation is to oversample around class boundaries since the non-target record is (little) perturbed to generate the fake target record (cf. Fig.~\\ref{fig:majortominor}).\n\nWe further enhance our method by adopting the fine-tuning method in Fig.~\\ref{fig:archi} (c), a post-processing procedure after training the two score networks. Our fine-tuning concept is to compare the two gradients (approximated) by $S_{\\theta_-}$ and $S_{\\theta_+}$ at a certain $(\\mathbf{x}_t , t=\\epsilon_t)$ pair, where $\\mathbf{x} \\in \\mathcal{T}$ is a real record, $\\mathcal{T}$ is tabular data, and $\\epsilon_t$ is a time point close to 0 --- note that at this step, we do not care about the class label of $\\mathbf{x}$ but use all records in the tabular data. If the angle between the two gradients is small, we regulate $S_{\\theta_-}$ to discourage the sampling direction toward the measured gradient (since the direction will lead us to a region where the non-target and target records co-exist).\n\n% Fig.~\\ref{fig:archi} (d) shows an outcome by the proposed fine-tuning method, where the minor class's reverse SDE sampling direction is modified into a way where we can sample fake records that are more likely to be in the minor class.\n\nWe conduct experiments with 6 benchmark tabular datasets and 10 baselines: 4 out of 6 datasets are for binary classification and 2 are for multi-class classification. Our careful choices of the baselines include various types of oversampling algorithms, ranging from classical statistical methods, generative adversarial networks (GANs), variational autoencoders (VAEs) to neural ordinary differential equation-based GANs. In those experiments, our proposed method significantly outperforms existing methods by large margins --- in particular, our proposed method is the first one increasing the test score commonly for all those benchmark datasets. Our contributions can be summarized as follows:\n\\begin{enumerate}\n    \\item We, for the first time, design a score-based generative model (SGM) for oversampling tabular data. Existing SGMs mainly study image synthesis.\n    \\item We design a neural network to approximate the score function for tabular data and propose a style transfer-based oversampling technique.\n    \\item Owing to one characteristic of tabular data that we always have class labels for classification, we design a fine-tuning method, which further enhances the sampling quality.\n    \\item In our oversampling experiments with 6 benchmark datasets and 10 baselines, our method not only outperforms them but also increases the test score for all cases in comparison with the test score before oversampling (whereas existing methods fail in at least one case).\n    \\item In Appendix~\\ref{a:entire}, our method overwhelms baselines when generating full fake tabular data (instead of oversampling minor classes) as well.\n    % \\item \n\\end{enumerate}\n\n\n\n"
            },
            "section 2": {
                "name": "Related Work and Preliminaries",
                "content": "\nIn this section, we review papers related to our research. We first review the recent score-based generative models, followed by tabular data synthesis.\n\n",
                "subsection 2.1": {
                    "name": "Score-based Generative Models",
                    "content": "\nSGMs use the following It\\^o SDE to define diffusive processes:\n\\begin{align}\\label{eq:forward}\nd\\mathbf{x}=\\mathbf{f}(\\mathbf{x},t)dt + g(t)d\\mathbf{w},\n\\end{align}where $\\mathbf{f}(\\mathbf{x},t) = f(t)\\mathbf{x}$ and its reverse SDE is defined as follows:\n\\begin{align}\\label{eq:reverse}\nd\\mathbf{x}=\\big(\\mathbf{f}(\\mathbf{x},t)-g^2(t)\\nabla_\\mathbf{x} \\log p_t(\\mathbf{x})\\big)dt + g(t)d\\mathbf{w},\n\\end{align} where this reverse SDE process is a generative process (cf. Fig.~\\ref{fig:archi} (a)). According to the types of $f$ and $g$, SGMs can be further classified as i) variance exploding (VE), ii) variance preserving (VP), and ii) sub-variance preserving (Sub-VP) models~\\cite{songyang}.\n\nIn general, $\\mathbf{x}_0$ means a real (image) sample and following the diffusive process in Eq.~\\eqref{eq:forward}, we can derive $\\mathbf{x}_t$ at time $t \\in [0,T]$. These above specific design choices are used to easily approximate the transition probability (or the perturbation kernel) $p(\\mathbf{x}_t|\\mathbf{x}_0)$ at time $t$ with a Gaussian distribution. The reverse SDE in Eq.~\\eqref{eq:reverse} maps a noisy sample at $t=T$ to a data sample at $t=0$.\n\nWe can collect the gradient of the log transition probability, $\\nabla_{\\mathbf{x}_t} \\log p(\\mathbf{x}_t|\\mathbf{x}_0)$, during the forward SDE since it can be analytically calculated. Therefore, we can easily train a score network $S_\\theta:\\mathbb{R}^{\\dim(\\mathbf{x})} \\times [0,T] \\rightarrow \\mathbb{R}^{\\dim(\\mathbf{x})}$ as follows, where $\\dim(\\mathbf{x})$ means the dimensionality of $\\mathbf{x}$, e.g., the number of pixels in the case of images or the number of columns in the case of tabular data:\n\\begin{align}\\label{eq:sgm}\n    \\argmin_{\\theta} \\mathbb{E}_t \\mathbb{E}_{\\mathbf{x}_t} \\mathbb{E}_{\\mathbf{x}_0} \\Big[\\lambda(t) \\|S_{\\theta}(\\mathbf{x}_t, t) -\\nabla_{\\mathbf{x}_t} \\log p(\\mathbf{x}_t|\\mathbf{x}_0) \\|_2^2 \\Big],\n\\end{align}where $\\lambda(t)$ is to control the trade-off between synthesis quality and likelihood. This training method is known as \\emph{denoising score matching} and it is known that $\\theta^*$ solving Eq.~\\eqref{eq:sgm} can correctly solve the reverse SDE in Eq.~\\eqref{eq:reverse}. In other words, the optimal solution $\\theta^*$ of the denoising score matching training is equivalent to the optimal solution of the exact score matching training --- its proof is in~\\cite{10.1162/NECO_a_00142}.\n\nThere exist several other improvements on SGMs. For instance, the adversarial score matching model~\\cite{jolicoeur2020adversarial} is to combine SGMs and GANs. Therefore, the reverse SDE is not solely determined as a reverse of the forward SDE but as a trade off between the denoising score matching and the adversarial training of GANs (cf. Fig.~\\ref{fig:asm} (a)). \n\n\n\nOnce the training process is finished, one can synthesize fake data samples with the \\emph{predictor-corrector} framework. In the prediction phase, we solve the reverse SDE in Eq.~\\eqref{eq:reverse} after sampling a Gaussian noise. Let $\\hat{\\mathbf{x}}_0$ be a solution of the reverse SDE. In the correction phase, we then enhance it by using the Langevin corrector~\\cite{songyang}. %(annealed Langevin dynamics. \nThe key idea of the correction phase is in Fig.~\\ref{fig:asm} (b). Since we correct the predicted sample $\\hat{\\mathbf{x}}_0$, following the direction of the gradient of the log probability, the corrected sample has a higher log probability. However, only the VE and VP models use this correction mechanism whereas the Sub-VP model does not.\n\n% One downside of SGMs is that $T$ can be large, e.g., $T=1,000$, and it requires much computation for solving the reverse SDE with the Euler-Maruyama method or the stochastic Runge-Kutta method. In the case of tabular data, however, $\\dim(\\mathbf{x})$ is much smaller that that of images and $T=50$ is sufficient according to our study. For instance, images with $100 \\times 100$ pixels define a 10,000 dimensional space whereas the number of columns (or attributes) is typically around 10 or 20 for tabular data.\n\n"
                },
                "subsection 2.2": {
                    "name": "Tabular Data Synthesis",
                    "content": "\n\nGenerative adversarial networks (GANs) are the most popular deep learning-based model for tabular data synthesis, and they generate fake samples by training a generator and a discriminator in an adversarial way~\\cite{NIPS2014_5423}. Among many variants of GANs~\\cite{pmlr-v70-arjovsky17a,10.5555/3295222.3295327,DBLP:conf/icpr/ParkAMLCP0PK18,NIPS2018_7909,NEURIPS2019_b59a51a3,NIPS2016_7c9d0b1f}, \\texttt{WGAN} is widely used providing a more stable training of GANs~\\cite{pmlr-v70-arjovsky17a}. Especially, \\texttt{WGAN-GP} is one of the most sophisticated model and is defined as follows~\\cite{10.5555/3295222.3295327}:\n\\begin{align*}\n\\begin{split}\n    \\mathop{min}_{\\substack{\\mathtt{G}}}\\mathop{max}_{\\substack{\\mathtt{D}}} \\mathbb{E}_{p_{d}}[\\mathtt{D}(\\mathbf{x})]-\\mathbb{E}_{p_{z}}[\\mathtt{D}(\\mathtt{G}(\\mathbf{z}))] -\\lambda\\mathbb{E}_{p_{\\tilde{\\mathbf{x}}}}[(\\|\\nabla_{\\tilde{\\mathbf{x}}}\\mathtt{D}(\\tilde{\\mathbf{x}})\\|_2-1)^2],\n\\end{split}\\end{align*} where $\\mathtt{G}$ is a generator function, $\\mathtt{D}$ is a Wasserstein critic function, $p_{\\mathbf{z}}$ is a prior distribution for a noisy vector $\\mathbf{z}$, which is typically $\\mathcal{N}(\\mathbf{0},\\mathbf{1})$, $p_{d}$ is a data distribution, $\\tilde{\\mathbf{x}}$ is a randomly weighted combination of $\\mathtt{G}(\\mathbf{z})$ and $\\mathbf{x}$, and $\\lambda$ is a regularization weight. \n\nTabular data synthesis generates realistic table records by modelling a joint probability distribution of features in a table. \\texttt{CLBN}~\\cite{1054142} is a Bayesian network built by the Chow-Liu algorithm representing a joint probability distribution. \\texttt{TVAE}~\\cite{NIPS2019_8953} is a variational autoencoder that effectively handles mixed types of features in tabular data. There are also many variants of GANs for tabular data synthesis. \\texttt{RGAN}~\\cite{esteban2017realvalued} generates continuous time-series records while \\texttt{MedGAN}~\\cite{DBLP:journals/corr/ChoiBMDSS17} generates discrete medical records using non-adversarial loss. \\texttt{TableGAN}~\\cite{DBLP:journals/corr/abs-1806-03384} generates tabular data using convolutional neural networks.\n\\texttt{PATE-GAN}~\\cite{Jordon2019PATEGANGS} was proposed to synthesize differentially private tabular records.\n\nHowever, one notorious challenge in synthesizing tabular data with GANs is addressing the issue of mode collapse. In many cases, the fake data distribution synthesized by GANs is confined to only a few modes and fails to represent many others. Some variants of GANs tried to resolve this problem, proposing to force the generator to produce samples from the various modes as evenly as possible. \\texttt{VEEGAN}~\\cite{NIPS2017_6923} has a reconstructor network, which maps the output of the generator to the noisy vector space, and jointly trains the generator and the reconstructor network. \\texttt{CTGAN}~\\cite{NIPS2019_8953} has a conditional generator and use a mode separation process. \\texttt{OCT-GAN}~\\cite{10.1145/3442381.3449999} exploits the homeomorphic characteristic of neural ordinary differential equations, when designing its generator, and now shows the state-of-the-art synthesis quality for many tabular datasets. However, one downside is that it requires a much longer training time than other models.\n\n\n\n"
                },
                "subsection 2.3": {
                    "name": "Minor-class Oversampling",
                    "content": "\nMulti-class data commonly suffers from imbalanced classes, and two different approaches have been proposed to address the issue; classical statistical methods and deep learning-based methods.\n\n% As the minority class can be easily ignored during training, the models can end up with poor performance on such class given imbalanced data. This is problematic as in many cases, it is the minority class where the prediction is most critical. Accordingly, a stream of research, called {\\it oversampling}, has been evolved to make up the size of the minority samples on purpose. The simplest approach is random sampling with replacement from the minority class []. \nClassical statistical methods are mostly based on the synthetic minority oversampling technique (\\texttt{SMOTE}~\\cite{10.5555/1622407.1622416}) method, which generates synthetic samples by interpolating two minor samples. Borderline SMOTE (\\texttt{B-SMOTE}~\\cite{10.1007/11538059}) improves \\texttt{SMOTE} to consider only the minor samples on the class boundary where the major samples occupy more than half of the neighbors. The adaptive synthetic sampling (\\texttt{ADASYN}~\\cite{4633969}) applies \\texttt{SMOTE} on the minority samples close to the major samples. \n\nDeep learning-based methods, based on GANs, mostly aim at oversampling minor class in images. In \\texttt{ACGAN}~\\cite{odena2017conditional}, a generator generates all classes including the minor ones, and a discriminator returns not only whether the input is fake or real but also which class it belongs to. Inspired by \\texttt{ACGAN}, \\texttt{BAGAN}~\\cite{DBLP:journals/corr/abs-1803-09655} constructs the discriminator which distinguishes the fake from the rest of the classes at once, showing good performance for minor-class image generation. \\texttt{cWGAN}~\\cite{Engelmann2021ConditionalWG} is a WGAN-GP based tabular data oversampling model, which is equipped with an auxiliary classifier to consider the downstream classification task. \\texttt{GL-GAN}~\\cite{wang2020global} is a GAN that employs an autoencoder and SMOTE to learn and oversample the latent vectors and includes an auxiliary classifier to provide label information to the networks. \\texttt{GAMO}~\\cite{Mullick_2019_ICCV} uses multiple generators, each of which is responsible for generating a specific class of data, and two separate critics; one for the real/fake classification and another for the entire class classification.\n\n"
                }
            },
            "section 3": {
                "name": "Proposed Method",
                "content": "\nWe describe our proposed score-based oversampling method. We first sketch the overall workflow of our method, followed by its detailed designs. \n\n\n\n\\begin{definition}\nLet $\\mathcal{T}$ be a table (or tabular data) consisting of $M$ classes, $\\{\\mathcal{C}_m\\}_{m=1}^M$, where $\\mathcal{C}_m$ is $m$-th class (subset) of $\\mathcal{T}$, i.e., classes are disjoint subsets of $\\mathcal{T}$. We define a minor class as $\\mathcal{C}_j$ whose cardinality is smaller than the maximum cardinality, i.e., $|\\mathcal{C}_j| < \\max_m |\\mathcal{C}_m|$. In general, therefore, we have one major (with the largest cardinality) and multiple minor classes in $\\mathcal{T}$. Our task is to oversample those minor classes, i.e., add artificial fake minor records, until $|\\mathcal{C}_j| = \\max_m |\\mathcal{C}_m|$ for all $j$.\n\\end{definition}\n\n",
                "subsection 3.1": {
                    "name": "Overall Workflow",
                    "content": "\\label{workflow}\n\nOur proposed score-based oversampling, shown in Fig.~\\ref{fig:patrick}, is done by the following workflow:\n\\begin{enumerate}\n    \\item We train a score-based generative model for each class $\\mathcal{C}_m$. Let $S_{\\theta_m}$ be a trained score network for $\\mathcal{C}_m$.\n    \\item Let $\\mathcal{C}_j$ be a minor class to oversample, i.e., target class. We fine-tune $S_{\\theta_j}$ using all records of $\\mathcal{T}$ as shown in Fig.~\\ref{fig:archi} (c).\n    \\item In order to oversample each target (minor) class $\\mathcal{C}_j$, we use one of the following two options as shown in Fig.~\\ref{fig:patrick}. We repeat this until $|\\mathcal{C}_j| = \\max_m |\\mathcal{C}_m|$.\n    \\begin{enumerate}\n        \\item After feeding a record randomly chosen from all other non-target classes except $\\mathcal{C}_j$, we derive its noisy vector. By using $S_{\\theta_j}$, we synthesize a fake target (minor) record for $\\mathcal{C}_j$. (cf. Fig.~\\ref{fig:patrick} (a)).\n        \\item After sampling a noisy vector $\\mathbf{z} \\sim \\mathcal{N}(\\mu, \\sigma^2)$, we generate a fake target (minor) record (cf. Fig.~\\ref{fig:patrick} (b)).\n    \\end{enumerate}\n    \\item After generating a fake record for the target class $\\mathcal{C}_j$, we can apply the Langevin corrector, as noted in Fig.~\\ref{fig:asm} (b). However, this step is optional and for some types of SGMs, we also do not use this step sometimes --- see Appendix~\\ref{a:hyper} for its detailed settings in each dataset for our experiments. For instance, the type of Sub-VP does not use this step for reducing computation in~\\cite{songyang} since it shows good enough quality even without the corrector.\n\\end{enumerate}\n\n\\begin{definition}\nLet $\\mathcal{C}_j$ be a target minor class, for which we aim at oversampling. $\\mathbf{x}^-_0 \\in \\mathcal{C}_j$ is a target (minor) record in the target class.\n\\end{definition}\n\n\\begin{definition}\nLet $\\mathcal{C}_j$ be a target minor class, for which we aim at oversampling. $\\mathbf{x}^+_0 \\in \\mathcal{C}_i$, where $i \\neq j$, is a record in other non-targeted classes. In the case of binary classification, $\\mathcal{C}_j$ is a minor class and $\\mathcal{C}_i$ is a major class. In general, however, $\\mathbf{x}^+_0$ means a record from other non-target classes. For ease of our convenience for writing, we use the symbol `$+$' to denote all other non-targeted classes. Fig.~\\ref{fig:patrick} follows this notation.\n\\end{definition}\n\nIn this process, our main contributions lie in i) designing the score network $S_{\\theta_m}$ for each class $\\mathcal{C}_m$, and ii) designing the fine-tuning method. Note that the fine-tuning happens after all score networks are trained.\n\n\\paragraph{\\textbf{Option 1 vs. Option 2}} In Fig.~\\ref{fig:patrick}, we show two options of how to sample a noisy vector. In Fig.~\\ref{fig:patrick} (a), we perturb $\\mathbf{x}^+_0$ in a non-target class to generate $\\hat{\\mathbf{x}}^-_0$. This strategy can be considered as \\emph{oversampling around class boundary}. In Fig.~\\ref{fig:patrick} (b), we sample from random noisy vectors and therefore, there is no guarantee that $\\hat{\\mathbf{x}}^-_0$ is around class boundary. We refer to Fig.~\\ref{fig:majortominor} for its intuitive visualization result.\n\n{One more advantage of the first option is that we do not require that $\\mathbf{x}^+_T$ follows a Gaussian distribution. Regardless of the distribution of $\\mathbf{x}^+_T$, we can derive $\\hat{\\mathbf{x}}^-_0$ using the reverse SDE with $S_{\\theta_-}$ --- recall that we do not sample the noisy vector from a Gaussian in the first option but from $\\mathbf{x}^+_0$ using the forward SDE. Therefore, we can freely choose a value for $T$, which is one big advantage in our design since a large $T$ increases computational overheads. For the second option, we also found that small $T$ settings work well as in~\\cite{rasul2021autoregressive}.\n\nThe relationship between the first and the second option is analogous to that between {\\texttt{Borderline-SMOTE}} (or \\texttt{B-SMOTE}) and \\texttt{SMOTE}. In this work, we propose those two mechanisms for increasing the usability of our method.\n}\n\n"
                },
                "subsection 3.2": {
                    "name": "Score-based Model for Tabular Data",
                    "content": "\nWe use the forward and reverse SDEs in Eqs.~\\eqref{eq:forward} and~\\eqref{eq:reverse}. As noted earlier, there exist three types of SGMs, depending on the types of $f$ and $g$ in Eqs.~\\eqref{eq:forward} and~\\eqref{eq:reverse}. We introduce the definitions of $f$ and $g$ in Appendix~\\ref{sec:fandg} and the proposed architecture for our score network in Appendix~\\ref{a:archi}.\n% We first introduce the definitions of $f$ and $g$ as follows:\n% \\begin{align}\n%     f(t)&=\\begin{cases}0,  &\\textrm{ if VE,}\\\\\n%     -\\frac{1}{2}\\beta(t)\\mathbf{x},&\\textrm{ if VP,}\\\\\n%     -\\frac{1}{2}\\beta(t)\\mathbf{x},&\\textrm{ if Sub-VP,}\\\\\n%     \\end{cases}\\\\\n%     g(t)&=\\begin{cases}\\sqrt{\\frac{\\texttt{d}[\\sigma^2(t)]}{\\texttt{d}t}},&\\textrm{ if VE,}\\\\\n%     \\sqrt{\\beta(t)},&\\textrm{ if VP,}\\\\\n%     \\sqrt{\\beta(t)(1-e^{-2\\int_0^t \\beta(s)\\, \\texttt{d}s})},&\\textrm{ if Sub-VP,}\\\\\n%     \\end{cases}\n% \\end{align}where { $\\sigma(t)$ and $\\beta(t)$ are noise functions at time $t$.}\n\n% We then introduce the proposed architecture for our score networks in Appendix~\\ref{a:archi}. \nSince the original score network design is for images, we redesign it with various techniques used by tabular data synthesis models~\\cite{NIPS2019_8953,lee2021invertible, grathwohl2018ffjord}. Its details are in Appendix~\\ref{a:archi}. However, we train this score network using the denoising score matching loss as in the original design.\n\n% in the following way --- our model design is greatly inspired by other tabular data synthesis papers~\\cite{}:\n% \\begin{align}\n%     % {\\texttt{h_1}}\n%     % \\texttt{h_{1}} \\\\\n%     % \\texttt{h_1} &= \\texttt{FC}(\\mathbf{x}) \\oplus \\psi(\\texttt{FC}(\\mathtt{x})),  \\\\\n% \\end{align}where $\\mathtt{FC}$ means a fully-connected layer. We train this score network using the denoising score matching loss as in the original design~\\cite{}.\n\nOur method provides two options for oversampling $\\mathcal{C}_j$. In the first option, we adopt the style transfer-based architecture, where i) we choose $\\mathbf{x}^+_0$ from $\\mathcal{C}_i$, $i \\neq j$, ii) we derive a noisy vector from it using the forward SDE, and iii) we finally transfer the noisy vector to a fake target record. The rationale behind this design is that the forward SDE is a pure Brownian motion regardless of classes --- in other words, all classes share the same forward SDE and thereby, share the same noisy space as well. Therefore, $\\mathbf{x}^+_T$ contains small information on its original record $\\mathbf{x}^+_0 \\in \\mathcal{C}_i$, which is still effective when it comes to generating a fake target record for $\\mathcal{C}_j$. Thus, this option can be considered as oversampling around class boundary.\n\nIn the second option, we follow the standard use of SGMs, where we sample $\\mathbf{z} \\sim \\mathcal{N}(\\mu, \\sigma^2)$ and generate a fake target record. We note that the Gaussian distribution $\\mathcal{N}(\\mu, \\sigma^2)$ is defined by the types of SDEs, i.e., VE, VP, or Sub-VP, as follows:\n\\begin{align}\n    % p_{0t}(\\mathbf{x}(t)|\\mathbf{x}(0))=\\begin{cases}\n    % \\mathcal{N}(\\mathbf{x}(t);\\mathbf{x}(0),[\\sigma^2(t)-\\sigma^2(0)]\\textbf{I}) ,\\textrm{ if VE,}\\\\\n    % \\mathcal{N}(\\mathbf{x}(t);\\mathbf{x}(0)e^{-\\frac{1}{2}\\int_0^t \\beta(s)\\, \\mathbf{d}s}, \\textbf{I} -  \\textbf{I}e^{-\\int_0^t \\beta(s)\\, \\mathbf{d}s}  ) ,\\textrm{ if VP,}\\\\\n    % \\mathcal{N}(\\mathbf{x}(t);\\mathbf{x}(0)e^{-\\frac{1}{2}\\int_0^t \\beta(s)\\, \\mathbf{d}s}, [1-e^{-\\int_0^t \\beta(s)\\, \\mathbf{d}s}]^2 \\textbf{I} ) ,\\textrm{ if Sub-VP,}\\\\\n    % \\end{cases}\n    \\mathbf{z} \\sim \\begin{cases}\n     \\mathcal{N}(\\mathbf{0}, \\sigma^2_{max}), &\\textrm{ if VE,}\\\\\n     \\mathcal{N}(\\mathbf{0}, \\mathbf{1}), &\\textrm{ if VP,}\\\\\n     \\mathcal{N}(\\mathbf{0}, \\mathbf{1}), &\\textrm{ if Sub-VP,}\\\\\n    \\end{cases}\n\\end{align}\nwhere $\\sigma_{max}$ is a hyperparameter.\n\n\n\n\n"
                },
                "subsection 3.3": {
                    "name": "Fine-tuning Method",
                    "content": "\nOnce score networks $\\{S_{\\theta_m}\\}_{m=1}^M$ are trained, we can sample fake records for all target classes as described earlier. In the case of tabular data, however, we can exploit class information to further enhance the sampling quality. Our proposed fine-tuning procedures are as follows --- for simplicity, we describe how to fine-tune for $\\mathcal{C}_j$ only. However, we repeat the following method for each $j$:\n\\begin{enumerate}\n\\item Firstly, given a record $\\mathbf{x} \\in \\mathcal{T}$ regardless of its class label and a chosen time $t=\\epsilon_t$\\footnote{$\\epsilon_t$ is a small value close to 0, and the range $[0,\\epsilon_t]$ means the last moment of the reverse SDE in Eq.~\\eqref{eq:reverse}, which we will fine-tune.}, we evaluate with each score network $S_{\\theta_m}$ to know the gradient of the log probability w.r.t. $\\mathbf{x}_t$ at time $t$, i.e., time-dependant score, as follows:\n% , where $\\epsilon_\\mathbf{x}$ is a random noisy vector to control the perturbation from $\\mathbf{x}$:\n\\begin{align}\\label{eq:eval}\n    \\mathbf{g}^m_{\\mathbf{x}, t} = S_{\\theta_m}\\bigg\\rvert_{\\mathbf{x}_t, t}, \\forall m,\n\\end{align}where $\\mathbf{g}^m_{\\mathbf{x}, t}$ is the gradient evaluated at $(\\mathbf{x}_t, t)$ with the score network $S_{\\theta_m}$. The long vertical bar means the `evaluated-at' operator.\n\\begin{enumerate}\n    \\item Our goal is to fine-tune the model around $(\\mathbf{x}_t, t)$. Therefore, we add a random noisy vector to $\\mathbf{x}$.\n\\end{enumerate}\n\n% Following the gradient, in other words, we can enhance the probability that the sample falls into the class of $\\mathcal{C}_m$ by doing $\\mathbf{x}' = \\mathbf{x} + h S_{\\theta_m}(\\mathbf{x}, t)$, where $h$ is a step size (since its log probability increases).\n\n\\item Secondly, we compare the angle between $\\mathbf{g}^j_{\\mathbf{x}, t}$ and $\\mathbf{g}^i_{\\mathbf{x}, t}$ where $i \\neq j$. Suppose that the angle $arccos\\Big(\\frac{\\mathbf{g}^j_{\\mathbf{x}, t} \\cdot \\mathbf{g}^i_{\\mathbf{x}, t}}{\\|\\mathbf{g}^j_{\\mathbf{x}, t}\\| \\|\\mathbf{g}^i_{\\mathbf{x}, t}\\|}\\Big)$ is large enough. It then says that $\\mathcal{C}_j$ and $\\mathcal{C}_i$ can be well separated around the location and time of $(\\mathbf{x}, t)$, which is a preferred situation. However, a problematic situation happens when the angle is smaller than a threshold {$0 < \\xi < \\pi$} --- in other words, their directions are similar. In such a case, we use the following loss to fine-tune the gradient $S_{\\theta_j}$ at $(\\mathbf{x}_t, t)$:\n\\begin{align}\\label{eq:tune}\nL(\\mathbf{x}, t, j) = \\| S_{\\theta_j}(\\mathbf{x}_t, t) - w \\mathbf{g}^j_{\\mathbf{x}, t}\\|_2^2,\n\\end{align}where $0 < w < 1$. In other words, we want to decrease the gradient by a factor of $w$.\n\\end{enumerate}\n\n\nThe rationale behind the proposed fine-tuning method is that by decreasing the scale of the gradient by a factor of $w$ at $(\\mathbf{x}_t, t)$, we can prevent that the reverse SDE process moves too much toward the \\emph{gray region} where both target and non-target class records are mixed (cf. Fig.~\\ref{fig:tune}). By controlling the damping coefficient $w$, we control how aggressively we suppress the direction.\n\n\\setlength{\\textfloatsep}{8pt}\n\\begin{algorithm}[t]\n\\footnotesize\n\\DontPrintSemicolon\n  \\caption{How to train our proposed model}\\label{alg1}\n\n  Initialize $\\theta_m$ for all $1 \\leq m \\leq M$\\;\n  \n  \\For{each class $\\mathcal{C}_m$}{\n        Train its score network $S_{\\theta_m}$ using the denoising score matching loss in Eq.~\\eqref{eq:sgm}\\;\\label{alg:s1}\n  }\n  \n  \\tcc{Let $\\mathcal{C}_i$ be the major class, where $i=\\argmax_m |\\mathcal{C}_m|$.}\n  \\For{each record $\\mathbf{x} \\in \\mathcal{T}$}{\n    \\For{each minor class $\\mathcal{C}_j$}{\n    %   \\For{each other class $\\mathcal{C}_i$, where $i \\neq j$}{\n        \\If{$arccos\\Big(\\frac{\\mathbf{g}^j_{\\mathbf{x}, t} \\cdot \\mathbf{g}^i_{\\mathbf{x}, t}}{\\|\\mathbf{g}^j_{\\mathbf{x}, t}\\| \\|\\mathbf{g}^i_{\\mathbf{x}, t}\\|}\\Big) < \\xi$}{\n          Fine-tune $\\theta_j$ with $L(\\mathbf{x}, t, j)$ in Eq.~\\eqref{eq:tune}\\;\\label{alg:s2}\n        % }\n      }  \n    }\n  }\n  \n  \\For{each minor class $\\mathcal{C}_j$}{\n    Oversample fake minor records with Option 1 or 2 for $\\mathcal{C}_j$ until $|\\mathcal{C}_j| = \\max_m |\\mathcal{C}_m|$\\;\n  }\n  \n  \\Return oversampled minor classes\n\\end{algorithm}\n\n"
                },
                "subsection 3.4": {
                    "name": "Training Algorithm",
                    "content": "\n\nAlgorithm~\\ref{alg1} shows the overall training process for our method. At the beginning, we initialize the score network parameters for all $m$. We then train each score network $S_{\\theta_m}$ using each $\\mathcal{C}_m$ in Line~\\ref{alg:s1}. At this step, we use the standard denoising score matching loss in Eq.~\\eqref{eq:sgm}. After finishing this step, we can already generate fake target records. However, we further enhance each score network in Line~\\ref{alg:s2}. The complexity of the proposed fine-tuning is  $\\mathcal{O}(|\\mathcal{T}|m)$, which is affordable in {practice} since $m$, the number of classes, is not large in comparison with the table size $|\\mathcal{T}|$. For oversampling $\\mathcal{C}_j$, we can use either the first or the second option of our model designs in Fig.~\\ref{fig:patrick}. They correspond to i) oversampling around class boundary or ii) regular oversampling, respectively.\n\n"
                }
            },
            "section 4": {
                "name": "Experiments",
                "content": "\nWe describe the experimental environments and results. In Appendix~\\ref{a:entire}, we introduce our additional experiments that we generate entire fake tabular data (instead of making imbalanced tabular data balanced after oversampling minor classes). We also analyze the space and time overheads of our method in Appendix~\\ref{a:comp}.\n\n\\vspace{-0.5em}\n",
                "subsection 4.1": {
                    "name": "Experimental Environments",
                    "content": "\n",
                    "subsubsection 4.1.1": {
                        "name": "Datasets",
                        "content": " \nWe describe the tabular datasets that are used for our experiments. \\texttt{Buddy} and \\texttt{Satimage} are for multi-class classification, and the others for binary classification. \n\n\\texttt{Default}~\\cite{default} is a dataset describing the information on credit card clients in Taiwan regarding default payments, demographic factors, credit data, and others. {The `\\textit{default payment}' column includes 23,364 (77.9$\\%$) of major records and 6,636 (22.1$\\%$) minor records.} \\texttt{Shoppers}~\\cite{shoppers} is a binary classification dataset, where out of 12,330 sessions, 10,422 (84.5$\\%$) are negative records which did not end with purchase, and the rest 1,908 (15.5$\\%$) are positive records ending with purchase. \\texttt{Surgical}~\\cite{surgical} is a binary classification dataset, which contains general surgical patient information. {There are 10,945 (74.8$\\%$) records for the major class, and 3,690 (25.2$\\%$) records for the minor class.} \\texttt{WeatherAUS}~\\cite{weatheraus} contains 10 years of daily weather observations from several weather stations in Australia. {`\\textit{RainTomorrow}' is the target variable to classify, where 43,993 (78.0$\\%$) records belong to the major class, which means the rain for that day was over 1mm, and 12,427 (22.0$\\%$) records belong to the minor class.}\n\n\\texttt{Buddy}~\\cite{buddy} consists of parameters, including a unique ID, assigned to each animal that is up for adoption, and a variety of physical attributes. {The target variable is `\\textit{breed}', which includes 10,643 (56.5$\\%$) records for the major class, and 7,021 (37.3$\\%$) and 1,170 (6.2$\\%$) records for minor classes.} \\texttt{Satimage}~\\cite{satimage} is to classify types of land usage, which is created by the Australian Centre for Remote Sensing. {The dataset contains 2,282 (35.8$\\%$) records for the major class, and 1,336 (21.0$\\%$), 1,080 (16.9$\\%$), 562 (8.8$\\%$), 573 (9.0$\\%$), and 539 (8.5$\\%$) records for minor classes.}\n\n% \\begin{enumerate}\n    \n%     \\item \\texttt{Default}~\\cite{default} is a dataset describing the information on credit card clients in Taiwan regarding default payments, demographic factors, credit data, and others. {The \\textit{default payment} column includes 23,364 (77.9$\\%$) of major records and 6,636 (22.1$\\%$) minor records.} \n\n%     \\item \\texttt{Shoppers}~\\cite{shoppers} is a binary classification dataset, where out of 12,330 sessions, 10,422 (84.5$\\%$) are negative records which did not end with purchase, and the rest 1,908 (15.5$\\%$) are positive records ending with purchase. \n    \n%     \\item \\texttt{Surgical}~\\cite{surgical} is a binary classification dataset, which contains general surgical patient information. {The number of records of each class is as follows: 10,945 (74.8$\\%$) records for major class and 3,690 (25.2$\\%$) records for minor class.}\n    \n%     % , i.e., one major and one minor classes.\n    \n%     \\item \\texttt{WeatherAUS}~\\cite{weatheraus} contains 10 years of daily weather observations from several weather stations in Australia. {\\textit{RainTomorrow} is the target variable to classify, where 43,993 (78.0$\\%$) records belong to major class which means the rain for that day was over 1mm, and 12,427 (22.0$\\%$) records belong to minor class which means the rain for that day was less than 1mm.}\n\n%     % which means it did rain in the next day; this column is \\textit{Yes}, which is 76$\\%$, if the rain for the day was 1$mm$ or more. \n    \n%     \\item \\texttt{Buddy}~\\cite{buddy} consists of parameters, including a unique ID, assigned to each animal that is up for adoption, and a variety of physical attributes. {The target variable is \\textit{breed}, which includes 10,643 (56.5$\\%$) records for major class, and 7,021 (37.3$\\%$), 1,170 (6.2$\\%$) records for minor classes.}\n    \n%     % and uses machine learning techniques to build models for multi-label classification, e.g., types and breeds of animals. \n    \n%     \\item \\texttt{Satimage}~\\cite{satimage} is to classify types of land usage, which is created by the Australian Centre for Remote Sensing. {The dataset contains 2,282 (35.8$\\%$) records for major class, and 1,336 (21.0$\\%$), 1,080 (16.9$\\%$), 562 (8.8$\\%$), 573 (9.0$\\%$), 539 (8.5$\\%$) records for minor classes.}\n\n% \\end{enumerate}\n\\vspace{-0.3em}\n"
                    },
                    "subsubsection 4.1.2": {
                        "name": "Baselines",
                        "content": "\n%There exist various approaches, ranging from statistical methods to deep learning-based generative models. Our specific choices of baselines include all those methods as follows:\n\nWe use a set of baselines as follows, which include statistical methods and generative models based on deep learning:\n\n\\texttt{Identity} is the original tabular data without oversampling. \n    %If an oversampling method is effective, it should show performance better than that of \\texttt{Identity};\n    % \\item \\texttt{Sample} is the simplest method to randomly re-sample minor records with replacements. In other words, the re-sampled minor records are duplicated;\n\\texttt{SMOTE}~\\cite{10.5555/1622407.1622416}, \\texttt{B-SMOTE}~\\cite{10.1007/11538059}, and \\texttt{Adasyn}~\\cite{4633969} are classical methods of data augmentation for the minority class;\n    % \\item \\texttt{CLBN}~\\cite{1054142} is a method of tabular data synthesis based on Bayesian network;\n\\texttt{MedGAN}~\\cite{DBLP:journals/corr/ChoiBMDSS17}, \\texttt{VEEGAN}~\\cite{NIPS2017_6923}, \\texttt{TableGAN}~\\cite{DBLP:journals/corr/abs-1806-03384}, and \\texttt{CTGAN}~\\cite{NIPS2019_8953} are GAN models for tabular data synthesis;\n\\texttt{TVAE}~\\cite{NIPS2019_8953} is proposed to learn latent embedding in VAE by incorporating deep learning metric. \n\\texttt{BAGAN}~\\cite{DBLP:journals/corr/abs-1803-09655} is a type of GAN model for oversampling images, but we replace its generator and discriminator with ours for tabular data synthesis.\n\\texttt{OCT-GAN}~\\cite{10.1145/3442381.3449999} is one of the state of the art model for tabular data systhesis.\n\n% \\begin{enumerate}\n%     \\item \\texttt{Identity} is the original tabular data without oversampling. \n%     %If an oversampling method is effective, it should show performance better than that of \\texttt{Identity};\n%     % \\item \\texttt{Sample} is the simplest method to randomly re-sample minor records with replacements. In other words, the re-sampled minor records are duplicated;\n    \n%     \\item \\texttt{SMOTE}~\\cite{10.5555/1622407.1622416}, \\texttt{B-SMOTE}~\\cite{10.1007/11538059}, and \\texttt{Adasyn}~\\cite{4633969} are classical methods of data augmentation for the minority class;\n%     % \\item \\texttt{CLBN}~\\cite{1054142} is a method of tabular data synthesis based on Bayesian network;\n%     \\item \\texttt{MedGAN}~\\cite{DBLP:journals/corr/ChoiBMDSS17}, \\texttt{VEEGAN}~\\cite{NIPS2017_6923}, \\texttt{TableGAN}~\\cite{DBLP:journals/corr/abs-1806-03384}, and \\texttt{CTGAN}~\\cite{NIPS2019_8953} are GAN models for tabular data synthesis;\n%     \\item \\texttt{TVAE}~\\cite{NIPS2019_8953} is proposed to learn latent embedding in VAE by incorporating deep learning metric. \n%     \\item \\texttt{BAGAN}~\\cite{DBLP:journals/corr/abs-1803-09655} is a type of GAN model for oversampling images, but we replace its generator and discriminator with ours for tabular data synthesis.\n%     \\item \\texttt{OCT-GAN}~\\cite{10.1145/3442381.3449999} is one of the state of the art model for tabular data systhesis.\n% \\end{enumerate}\n\nWe exclude \\texttt{cWGAN}~\\cite{Engelmann2021ConditionalWG} and \\texttt{GL-GAN}~\\cite{wang2020global}, since they do not support multiple minority cases and synthesis quality is also relatively lower than others in our preliminary experiments. \n\\vspace{-0.3em}\n"
                    },
                    "subsubsection 4.1.3": {
                        "name": "Hyperparameters",
                        "content": "\nWe refer to Appendix~\\ref{a:hyper} for detailed hyperparameter settings. We also provide all our codes and data for reproducibility and one can easily reproduce our results.\n% Click \\href{https://drive.google.com/drive/folders/1NBOpSUiaCksKWp3ehlY9qqBWKKgE_FrE?usp=sharing}{{here}} to download our codes\\&data.\n\\vspace{-0.3em}\n"
                    },
                    "subsubsection 4.1.4": {
                        "name": "Evaluation Methods",
                        "content": " Let $\\mathcal{C}_j$ be a minor class, where $|\\mathcal{C}_j| < \\max_m |\\mathcal{C}_m|$. As mentioned earlier, our task is to oversample  $\\mathcal{C}_j$ until $|\\mathcal{C}_j| = \\max_m |\\mathcal{C}_m|$ for all $j$. However, some baselines are not for oversampling minor classes but generating one entire fake tabular data, in which case we train such a baselines for each $\\mathcal{C}_j$ --- in other words, one dedicated baseline model for each minor class. For our method, we follow the described process.\n\nFor evaluation, we first train various classification algorithms with the augmented (or oversampled) training data --- we note that the augmented data is fully balanced after oversampling --- including \\texttt{Decision Tree}~\\cite{breiman1984classification}, \\texttt{Logistic Regression}~\\cite{cox1958regression}, \\texttt{AdaBoost}~\\cite{10.5555/1624312.1624417}, and \\texttt{MLP}~\\cite{10.5555/1162264}. We then conduct classification with the testing data. We take the average of the results  --- the same evaluation scenario had been used in~\\cite{NIPS2019_8953,lee2021invertible} and we strictly follow their evaluation protocols. We repeat with 5 different seed numbers and report their mean and std. dev. scores. We use the weighted F1 since the testing data is also imbalanced. We visualize the column-wise histogram of original and fake records and use t-SNE~\\cite{JMLR:v9:vandermaaten08a} to display them.\n\n\n\n\n\\vspace{-0.3em}\n"
                    }
                },
                "subsection 4.2": {
                    "name": "Experimental Results",
                    "content": "\nWe compare various oversampling methods in Table~\\ref{table:main}. As mentioned earlier, \\texttt{Identity} means that we do not oversampling minor classes, train classifiers, and test with testing data. Therefore, the score of \\texttt{Identity} can be considered as a minimum requirement upon oversampling.\n\nClassical methods, such as \\texttt{SMOTE}, \\texttt{B-SMOTE}, and \\texttt{Adasyn}, show their effectiveness to some degree. For instance, \\texttt{SMOTE} improves the test score from {0.515} to {0.561} after oversampling in \\texttt{Default}. All these methods, however, fail to increase the test score in \\texttt{Surgical}. \\texttt{SMOTE} and \\texttt{B-SMOTE} fail in \\texttt{Buddy} as well.\n\n\\texttt{VEEGAN} and \\texttt{TableGAN} are two early GAN-based methods and their test scores are relatively lower than other advanced methods, such as \\texttt{CTGAN} and \\texttt{OCT-GAN}. However, \\texttt{TableGAN} shows the best result among all baselines for \\texttt{Surgical}. \\texttt{MedGAN} fails in \\texttt{Surgical}, \\texttt{WeatherAUS}, and \\texttt{Buddy}. \\texttt{TVAE} also fails in multiple cases. Among the baselines, \\texttt{CTGAN} and \\texttt{OCT-GAN} show the best outcomes in many cases and in general, their synthesis quality looks stable. In general, those deep learning-based methods show better effectiveness than the classical methods.\n\nHowever, our method, \\texttt{SOS}, clearly outperforms all those methods in all cases by large margins. In \\texttt{Default}, the original score without oversampling, i.e., \\texttt{Identity}, is 0.515, {and the best baseline score is 0.561 by \\texttt{SMOTE}. However, our method with Sub-VP achieves 0.574, which is about 11\\%} improvement over \\texttt{Identity}. The biggest enhancement is achieved in \\texttt{Shoppers}, i.e., a score of 0.601 by \\texttt{Identity} vs. 0.675 by our method with VE. For other datasets, our method marks significant enhancements after oversampling. \nIn \\texttt{Buddy}, moreover, other methods except \\texttt{Adasyn} and \\texttt{SOS} oversample noisy fake records and decrease the score below that of \\texttt{Identity}.\n\n% {\\color{green} In \\texttt{Buddy}, moreover, other methods except \\texttt{Adasyn} and \\texttt{SOS} oversample noisy fake records and decrease the score below that of \\texttt{Identity}. (need to be modified)}\n\n% In fact, \\texttt{Buddy} is the most challenging dataset in our experiments. All methods except \\texttt{Adasyn} and \\texttt{SOS} oversample noisy fake records and their scores are far less than that of \\texttt{Identity}.\n\\vspace{-1em}\n"
                },
                "subsection 4.3": {
                    "name": "Sensitivity on Hyperparameters",
                    "content": "\n% { For sensitivity analyses, we control two major factors for the training process: the number of denoising steps, T, and noise scale factors, $(\\beta_{min}, \\beta_{max})$ and two for the fine-tuning: angle (temporal notation), and weight to the .}\nWe summarize the sensitivity results w.r.t. some key hyperparameters in Table~\\ref{table:sensitivity}. We used $T=50$ in Table~\\ref{table:main}. Others for $T$ produce sub-optimal results in Table~\\ref{table:sensitivity}. $\\beta_{min}$ and $\\beta_{max}$ means the lower and upper bounds of $\\beta(t)$ of the drift $f$ and the diffusion $g$. In general, all settings produce reasonable outcomes, outperforming \\texttt{Identity}. $\\xi$ is the angle threshold for our fine-tuning method. As shown in Appendix~\\ref{a:hyper}, the best setting for $\\xi$ varies from one dataset to another but in general, $\\xi \\in [80,100]$ produces the best fine-tuning results. For $w$, we recommend a value close to 0.99 as shown in Table~\\ref{table:sensitivity}. $\\epsilon_{t}=5e-04$ produces optimal results in almost all cases.\n\n\n\n\n\\vspace{-0.5em}\n"
                },
                "subsection 4.4": {
                    "name": "Sensitivity on Boundary vs. Regular Oversampling",
                    "content": "\nThe first option of our sampling strategy (cf. Fig.~\\ref{fig:patrick} (a)) corresponds to oversampling around class boundary, and the second option (cf. Fig.~\\ref{fig:patrick} (b)) corresponds to regular oversampling. We compare their key results in Table~\\ref{table:ZvsN}. It looks like that there does not exist a clear winner, but the boundary oversampling produces better results in more cases.\n\n\n\n\\vspace{-0.5em}\n"
                },
                "subsection 4.5": {
                    "name": "Ablation study on the reverse SDE solver (or predictor)",
                    "content": "\nTo solve $\\hat{\\mathbf{x}}^-_0$ from $\\mathbf{x}^+_T$ with Eq.~\\eqref{eq:reverse}, we can adopt various strategies. In general, the Euler-Maruyama (EM) method~\\cite{platen_1999} is popular in solving SDEs. However, one can choose different SDE solvers, such as ancestral sampling~\\cite{NEURIPS2020_4c5bcfec}, reverse diffusion~\\cite{songyang}, probability flow~\\cite{songyang} and so on. Following the naming convection of~\\cite{songyang}, we call them as \\emph{predictor} (instead of solver) in this subsection. In the context of SGMs, therefore, the predictor means the SDE solver to solve Eq.~\\eqref{eq:reverse}.\n\nIn Table~\\ref{table:pc_sampler}, the Euler-Maruyama method leads to the best outcomes for \\texttt{Surgical}. For \\texttt{Shoppers}, the ancestral sampling method produces the best outcomes. Likewise, predictors depend on datasets. The probability flow also shows reasonable results in our experiments. Especially, we observe that the probability flow always outperforms other predictors in \\texttt{Buddy}.\n\n\n% \\begin{table*}[]\n% \\small\n% \\centeringahgr akf\n% \\setlength{\\tabcolsep}{2pt}\n% % \\caption{Results by the reverse SDE solver (or predictor). We consider the predictors of Euler-Maruyama (EM), Ancestral Sampling (AS), Reverse Diffusion (RD), and Probability Flow (PF).}\\label{table:pc_sampler}\n% \\caption{Results by the reverse SDE solver (or predictor). We consider the predictors of Euler-Maruyama (EM), Ancestral Sampling (AS), and Reverse Diffusion (RD).}\\label{table:pc_sampler}\n\n% \\begin{tabular}{c|ccccccccccccc|cccccclclclcl}\n% \\specialrule{1pt}{1pt}{1pt}\n\n% \\multirow{3}{*}{Predictor} &  & \\multicolumn{11}{c}{VE}                                                                                 &  &  & \\multicolumn{11}{c}{VP}                                                                                                                            &                      \\\\ \\cline{3-13} \\cline{16-26}\n%                           &  & \\multicolumn{3}{c}{Pred. only} &  & \\multicolumn{3}{c}{Corr. only} &  & \\multicolumn{3}{c}{Pred. Corr.} &  &  & \\multicolumn{3}{c}{Pred. only} &  & \\multicolumn{3}{c}{Corr. only}             & \\multicolumn{1}{c}{} & \\multicolumn{3}{c}{Pred. Corr.}            & \\multicolumn{1}{c}{} \\\\ \\cline{3-5} \\cline{7-9} \\cline{11-13} \\cline{16-18} \\cline{20-22} \\cline{24-26}\n%                           &  & Surgical    &     & Shoppers   &  & Surgical    &     & Shoppers   &  & Surgical    &     & Shoppers    &  &  & Surgical    &     & Shoppers   &  & Surgical & \\multicolumn{1}{c}{} & Shoppers & \\multicolumn{1}{c}{} & Surgical & \\multicolumn{1}{c}{} & Shoppers &                      \\\\ \n% \\specialrule{1pt}{1pt}{1pt}\n\n% EM                         &  & -           &     &  -         &  & -           &     & -          &  & -           &     & -           &  &  & -           &     & 0.6482±0.0066           &  & -        &                      & -        &                      & -        &                      &  0.6508±0.0053       &                      \\\\\n% AS                         &  & -           &     & -          &  & -           &     & -          &  & -           &     & -           &  &  & -           &     & -          &  & -        &                      & -        &                      & -        &                      & -        &                      \\\\\n% RD                         &  & -           &     & -          &  & -           &     & -          &  & -           &     & -           &  &  & -           &     & -          &  & -        &                      & -        &                      & -        &                      & -        &                      \\\\ \n% \\specialrule{1pt}{1pt}{1pt}\n\n% \\end{tabular}\n% \\end{table*}\n\n\n\n\n\n\n"
                },
                "subsection 4.6": {
                    "name": "Ablation study on Adversarial Score Matching vs. Fine-tuning",
                    "content": "\nWe also compare the two enhancement strategies, the adversarial score matching (cf. Fig.~\\ref{fig:asm}) and our fine-tuning, in Table~\\ref{table:abl_adv}. First of all, we found that the adversarial score matching for tabular data is not as effective as that for image data. The original method of the adversarial score matching had been designed for images to integrate SGMs with GANs. We simply took the discriminator of \\texttt{CTGAN}, one of the best performing GAN models for tabular data, and combine it with our model, when building the adversarial score matching for our tabular data. Although there can be a better design, the current implementation with the best existing discriminator model for tabular data does not show good performance in our experiments. In many cases, it is inferior to our method even without fine-tuning. However, our fine-tuning successfully improves in almost all cases.\n\n\\vspace{-0.5em}\n\n\n\n\n% \\subsection{Ablation study on No Fine-tuning vs. Adversarial SGM vs. Fine-tuning}\n\n% \\begin{table*}[]\n% \\caption{Ablation study}\n% \\label{table:ablation}\n% \\small\n% \\centering\n% \\setlength{\\tabcolsep}{3pt}\n% \\begin{tabular}{c|ccccccc|ccccccc|ccccccc}\n% \\specialrule{1pt}{1pt}{1pt}\n\n%       &  & \\multicolumn{5}{c}{\\texttt{Shoppers}}                          &  &  & \\multicolumn{5}{c}{\\texttt{Surgical}}                          &  &  & \\multicolumn{5}{c}{\\texttt{Buddy}}                             &  \\\\ \\cline{3-7} \\cline{10-14} \\cline{17-21}\n%       &  &  before    &  & train w/      &  & after     &  &  & before    &  & train w/      &  & after      &  &  & before    &  & train w/         &  & after      &  \\\\ \n%       &  &  fine-tune &  & Discriminator &  & fine-tune &  &  & fine-tune &  & Discriminator &  & fine-tune  &  &  & fine-tune &  & Discriminator &  & fine-tune &  \\\\ \\hline\n\n% VE     &  & -                &  & -               &  & -          &  &  & -                &  & -               &  & -          &  &  & -                &  & -               &  & -          &  \\\\\n% VP     &  & -                &  & -               &  & -          &  &  & -                &  & -               &  & -          &  &  & -                &  & -               &  & -          &  \\\\\n% Sub-VP &  & -                &  & -               &  & -          &  &  & -                &  & -               &  & -          &  &  & -                &  & -               &  & -          &  \\\\ \n% \\specialrule{1pt}{1pt}{1pt}\n\n% \\end{tabular}\n% \\end{table*}\n\n"
                },
                "subsection 4.7": {
                    "name": "Visualization",
                    "content": "\nWe introduce several key visualization results, ranging from histograms of columns to t-SNE plots.\n\\vspace{-5pt}\n",
                    "subsubsection 4.7.1": {
                        "name": "Column-wise Histogram",
                        "content": "\nFig.~\\ref{fig:histogram} shows two histogram figures. The real histogram of values and the histogram by our method are similar to each other in both figures. However, \\texttt{CTGAN} fails to capture the real distribution of the `bmi' column of \\texttt{Surgical} in Fig.~\\ref{fig:histogram} (a), which we consider the well-known mode-collapse problem of GANs, i.e., values in certain regions are more actively sampled than those in other regions. In Fig.~\\ref{fig:histogram} (b), \\texttt{CTGAN}'s histogram shows three peaks whereas the real histogram has only one peak. Our method successfully captures it.\n\n\n\n\n\n\n"
                    },
                    "subsubsection 4.7.2": {
                        "name": "t-SNE plot of fake/real records",
                        "content": "\nIn Fig.~\\ref{fig:majortominor}, we visualize real and fake records --- we use \\texttt{SOS} (Sub-VP) with the boundary oversampling option {in \\texttt{WeatherAUS}}. The translucent dots mean real records, and the solid blue dots are transferred to the solid red dots in the figure. As described earlier, those solid red dots are around the class boundary.\n\n\n\n"
                    }
                }
            },
            "section 5": {
                "name": "Conclusions \\& Limitations",
                "content": "\nOversampling minor classes is a long-standing research problem in data mining and machine learning. Many different methods have been proposed so far. In this paper, however, we presented a score-based oversampling method, called \\texttt{SOS}. Since SGMs were originally invented for images, we carefully redesigned many parts of them. For instance, we designed a neural network to approximate the score function of the forward SDE and a fine-tuning method. In our experiments with 6 datasets and 10 baselines, our method overwhelms other oversampling methods in all cases. Moreover, our method does not decrease the F1 score after oversampling in all cases whereas existing methods fail to do so from time to time. From all these facts, we think that our method makes a great step forward in oversampling minor classes.\n\n% In one dataset, however, we found that all methods including ours do not show good results. However, we hope that our work will bring much follow-up research and the problem will be addressed in the near future. In general, SGMs are still in early phase when it comes to generating tabular data, and we consider that there exists a room to improve. \nEven though SGMs perform well in general, they are still in an early phase when it comes to generating tabular data, and we hope that our work will bring much follow-up research. For instance, one can invent a drift and/or a diffusion function different from the three existing types and specialized to tabular data.\n\n%% The acknowledgments section is defined using the \"acks\" environment\n%% (and NOT an unnumbered section). This ensures the proper\n%% identification of the section in the article metadata, and the\n%% consistent spelling of the heading.\n\\begin{acks}\nJayoung Kim and Chaejeong Lee equally contributed. Noseong Park is the corresponding author. This work was supported by the Institute of Information \\& Communications Technology Planning \\& Evaluation (IITP) grant funded by the Korea government (MSIT) (10\\% from No. 2020-0-01361, Artificial Intelligence Graduate School Program at Yonsei University and 70\\% from No. 2021-0-00231, Development of Approximate DBMS Query Technology to Facilitate Fast Query Processing for Exploratory Data Analysis) and the National Research Foundation of Korea (NRF) grant funded by the Korea government (MSIT) (20\\% from No. 2021R1F1A1063981).\n\n\n\\end{acks}\n\n%%\n%% The next two lines define the bibliography style to be used, and\n%% the bibliography file.\n\\bibliographystyle{ACM-Reference-Format}\n\\bibliography{ref}\n\n%%\n%% If your work has an appendix, this is the place to put it.\n\\clearpage\n\\appendix\n"
            },
            "section 6": {
                "name": "Settings \\& Reproducibility",
                "content": "\\label{a:hyper}\nOur software and hardware environments are as follows: \\textsc{Ubuntu} 18.04 LTS, \\textsc{Python} 3.8.2, \\textsc{Pytorch} 1.8.1, \\textsc{CUDA} 11.4, and \\textsc{NVIDIA} Driver 470.42.01, i9 CPU, and \\textsc{NVIDIA RTX 3090}. Our codes and data are at \\url{https://github.com/JayoungKim408/SOS}.\n\nIn Tables~\\ref{table:hyperparameters_sgm} and~\\ref{table:hyperparameters_finetune}, we list the best hyperparameters. We have three layer types as shown in Appendix~\\ref{a:archi}: Concat, Squash, and Concatsquash~\\cite{grathwohl2018ffjord}. $(\\beta_{min}, \\beta_{max})$ (resp. $(\\sigma_{min}, \\sigma_{max})$) are two hyperparameters of the function $\\beta(t)$ (resp. $\\sigma(t)$). In fact, the full writing of $\\beta$ and $\\sigma$ are $\\beta(t;\\beta_{min}, \\beta_{max})$ and $\\sigma(t;\\sigma_{min}, \\sigma_{max})$, respectively. We search for (min, max), in total, with 9 combinations using $min = \\{0.01, 0.1, 0.5\\}$ and $max = \\{1.0, 5.0, 10.0\\}$. We use a learning rate in \\{$1 \\times 10^{-i}$, $2 \\times 10^{-i}$ | $i$ = \\{3, 4, 5\\}\\}. Our predictors are in \\{AS, RD, EM, PF\\} and the corrector is the Langevin corrector~\\cite{songyang}. SNR is the signal-to-noise ratio set to $\\{0.01, 0.05, 0.16\\}$ when using the corrector.\n\nWe also consider the following hyperparameter configurations for the fine-tuning process: the fine-tuning learning rate is \\{$2 \\times 10^{-i}$ | $i$ = \\{4, 5, \\dots, 8\\}\\}, and the angle threshold $\\xi$ is \\{$60+5 \\times i$ | $i$ = \\{0, 1, \\dots, 10\\}\\}. The number of fine-tuning epochs is \\{1, 2, 3, 4, 5\\}, and $w$ is \\{0.99, 0.95, 0.9, 0.8, 0.7, 0.6\\}. $\\epsilon_{t}$ is \\{5e-04, 1, 2, 3\\} in all datasets.\n\n\n\n\n\n\n\n\n\n% \\clearpage\n\n\n\n"
            },
            "section 7": {
                "name": "VE, VP, and Sub-VP SDEs",
                "content": "\\label{sec:fandg}\n\nThe definitions of $f$ and $g$ as follows:\n\\begin{align}\n    f(t)&=\\begin{cases}0,  &\\textrm{ if VE,}\\\\\n    -\\frac{1}{2}\\beta(t)\\mathbf{x},&\\textrm{ if VP,}\\\\\n    -\\frac{1}{2}\\beta(t)\\mathbf{x},&\\textrm{ if Sub-VP,}\\\\\n    \\end{cases}\\\\\n    g(t)&=\\begin{cases}\\sqrt{\\frac{\\texttt{d}[\\sigma^2(t)]}{\\texttt{d}t}},&\\textrm{ if VE,}\\\\\n    \\sqrt{\\beta(t)},&\\textrm{ if VP,}\\\\\n    \\sqrt{\\beta(t)(1-e^{-2\\int_0^t \\beta(s)\\, \\texttt{d}s})},&\\textrm{ if Sub-VP,}\\\\\n    \\end{cases}\n\\end{align}where {$\\sigma(t)$ and $\\beta(t)$ are noise functions at time $t$.}\n\n"
            },
            "section 8": {
                "name": "Score Network Architecture",
                "content": "\\label{a:archi}\n\nThe proposed score network $S_{\\theta}(\\mathbf{x}, t)$ is as follows:\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\begin{align*}\n    \\mathbf{h}_0     &=  \\mathbf{x}_t,\\\\\n    \\mathbf{h}_i     &=  \\omega( \\mathtt{H}_i(\\mathbf{h}_{i-1}, t) \\oplus \\mathbf{h}_{i-1} ), 1 \\le i \\le d_N\\\\\n    S_{\\boldsymbol{\\theta}}(\\mathbf{x}_t, t) &= \\mathtt{FC}(\\mathbf{h}_{d_N}),\n\\end{align*}where $\\mathbf{x}_t$ is a record (or a row) at time $t$ in tabular data and $\\omega$ is an activation function. $d_N$ is the number of hidden layers. For various layer types of $\\mathtt{H}_i(\\mathbf{h}_{i-1}, t)$, we provide the following options:\n\\begin{align*}\n    \\mathtt{H}_i(\\mathbf{h}_{i-1}, t) &= \n        \\begin{cases}\n            \\texttt{FC}_{i}(\\mathbf{h}_{i-1}) \\odot \\psi(\\texttt{FC}^{t}_{i}(t)), &\\textrm{ if Squash,}\\\\\n            \\texttt{FC}_{i}(t \\oplus \\mathbf{h}_{i-1}), &\\textrm{ if Concat,} \\\\\n            \\texttt{FC}_{i}(\\mathbf{h}_{i-1}) \\odot \\psi(\\texttt{FC}^{gate}_{i}(t) + \\texttt{FC}^{bias}_{i}(t)), &\\textrm{ if Concatsquash,}\n        \\end{cases}\n\\end{align*}where we can choose one of the three possible layer types as a hyperparameter, $\\odot$ means the element-wise multiplication, $\\oplus$ means the concatenation operator, $\\psi$ is the Sigmoid function, and $\\mathtt{FC}$ is a fully connected layer.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n% \\begin{align*}\n%     \\mathbf{h}_0 &= \\mathbf{x},\\\\\n%     \\mathbf{h}_1 &=  \\mathtt{H}_1(\\mathbf{h}_0, \\mathbf{e}_t)\\\\\n%     \\mathbf{h}_i &=  \\mathbf{h}_{i-1} \\oplus \\mathtt{H}_i(\\mathbf{h}_{i-1}, \\mathbf{e}_t), 1 < i < d_N\\\\\n%     % \\mathbf{h}_2 &= \\mathtt{H}_2(\\mathbf{h}_1, \\mathbf{e}_t),\\\\\n%     % &\\vdots\\\\\n%     \\mathbf{h}_{d_N} &= \\mathbf{h}_{d_{N}-1} \\oplus \\mathtt{H}_{d_N}(\\mathbf{h}_{d_{N}-1}, \\mathbf{e}_t), \\\\\n%     S_{\\theta}(\\mathbf{x}, t) &= \\mathtt{FC}(\\mathbf{h}_{d_N})\n% \\end{align*}\n\n\n% where $\\mathbf{e}_t$ means the embedding of $t$. We use the embedding method in \\cite[Section H.2]{songyang}.\n\n\n% \\begin{align*}\n%     \\mathtt{H}_i(\\mathbf{h}_{i-1}, \\mathbf{e}_t) &= \n%         \\begin{cases}\n%             \\omega(\\texttt{FC}_{i}(\\mathbf{h}_{i-1}) \\odot \\psi(\\texttt{FC}^{t}_{i}(\\mathbf{e}_t))), &\\textrm{ if Squash,}\\\\\n%             \\omega(\\texttt{FC}_{i}(\\mathbf{e}_t \\oplus \\mathbf{h}_{i-1})), &\\textrm{ if Concat,}\\\\\n%             \\omega(\\texttt{FC}_{i}(\\mathbf{h}_{i-1}) \\odot \\psi(\\texttt{FC}^{gate}_{i}(\\mathbf{e}_t)) \\\\\n%             \\quad  + \\texttt{FC}^{bias}_{i}(\\mathbf{e}_t)), &\\textrm{if Concatsquash,}\n%         \\end{cases}\n% \\end{align*}\n\n\n% where $\\odot$ means the element-wise multiplication, $\\oplus$ means the concatenation operator, $\\omega$ is an activation function, $\\psi$ is the Sigmoid function, and $\\mathtt{FC}$ is the fully connected layer.\n\n\n% The (input, output) dimensionality of each layer is as follows:\n\n\n% \\begin{enumerate}\n%     \\item ($\\dim(\\mathbf{x})$, $\\dim(h_1)$)  for $\\texttt{FC}$ with $i=1$, \n%     \\item ($\\dim(\\mathbf{x}) + \\dim(h_{i-1})$, $\\dim(h_i)$)  for $\\texttt{FC}$ with $1 < i < d_N$, \n%     \\item ($\\dim(\\mathbf{x})$ + $\\sum_{j=1}^{d_{N}-1} \\dim(h_j) $, $\\dim(h_{d_{N}})$) for $\\texttt{FC}$ with $i=d_{N}$,\n%     \\item ($\\dim(h_{d_{N}})$,  $\\dim(\\mathbf{x})$) for $\\texttt{FC}$. \n% \\end{enumerate}\n\n\n\n\n\n\n"
            },
            "section 9": {
                "name": "Space and Time Overheads",
                "content": "\\label{a:comp}\n\n\n\nSome SGMs are notorious for their high computational overheads. In the case of tabular data, however, it is not the case since the number of columns is typically much smaller than other cases, e.g., the number of pixels of images. We introduce our training and synthesis overheads. As shown in Fig.~\\ref{fig:loss_curve}, our training curves are smooth and in Table~\\ref{table:time}, the space and time overheads of our method are well summarized. The GPU memory requirements are around 4GB, which is small. It takes well less than a second per epoch for training. For the total generation time, i.e, the time taken to accomplish the entire oversampling task, our method shows less than 5 seconds in all cases. Sometimes, it takes less than a second.\n\n\n\n\n\n\n\n\n\n\n\n\n"
            },
            "section 10": {
                "name": "Full Fake Table Synthesis",
                "content": "\\label{a:entire}\nInstead of oversampling minor classes, one can use our method for generating fake tabular data entirely --- in other words, fake tabular data consists of only fake records. To this end, we train one score network of \\texttt{SOS} (Sub-VP) with all classes without the fine-tuning process since we do not distinguish major/minor classes but try to generate all classes. In Table~\\ref{tbl:entire_synthesis}, we summarize its results in three datasets. As shown, it overwhelms all other existing methods. Even in comparison with \\texttt{Identity}, it shows higher F1 scores in \\texttt{Shoppers} and \\texttt{Satimage}. However, its accuracy is lower than \\texttt{Identity} in \\texttt{Shoppers} and \\texttt{Surgical}.\n\nOne interesting point is that for \\texttt{Satimage}, our fake table shows better scores than \\texttt{Identity} for all metrics. We compare the loss curves of the MLP classifier with the original data and our fake data in Fig.~\\ref{fig:full_fake_loss_curve}. Surprisingly, the fake tabular data by \\texttt{SOS} yields lower training loss values than \\texttt{Identity}. For some reasons, the fake tabular data is likely to provide better training, which is very promising. We think that it needs more study on synthesizing fake tabular data with SGMs to fully understand the phenomena.\n\n"
            }
        },
        "tables": {
            "tbl:cmp": "\\begin{table}\n\\small\n\\centering\n\\setlength{\\tabcolsep}{3pt}\n\\caption{The qualitative comparison among our method and other methods. There are no existing minor-class oversampling models that adopt the score-based generative model. Moreover, many of the existing minor-class oversampling methods are for images. In our experiments, we modify some of them to be able to process tabular data and compare with our method.}\\label{tbl:cmp}\n\\begin{tabular}{c|c|c|c}\n\\specialrule{1pt}{1pt}{1pt}\n\n% \\hline\nMethod & Multiple Generators & Generative Model Type & Domain \\\\ % \\hline\n\\specialrule{1pt}{1pt}{1pt}\n\\texttt{SMOTE} & N/A & Classical Method & Tabular \\\\ \\hline\n\\texttt{B-SMOTE} & N/A & Classical Method & Tabular \\\\ \\hline\n\\texttt{ADASYN} & N/A & Classical Method & Tabular \\\\ \\hline\n\\texttt{BAGAN} & X & GAN & Image \\\\ \\hline\n\\texttt{cWGAN} & X & GAN & Tabular \\\\ \\hline\n\\texttt{GL-GAN} & X & GAN & Tabular \\\\ \\hline\n\\texttt{GAMO} & O & GAN & Image \\\\ \\hline\n\\texttt{SOS} (Ours) & O (Score Networks) & Score-based Model & Tabular \\\\  % \\hline\n\\specialrule{1pt}{1pt}{1pt}\n\n\\end{tabular}\n\\end{table}",
            "table:main": "\\begin{table*}[t]\n\n\\caption{Experimental results (Weighted F1).\n% For \\texttt{Buddy}, VE and VP are not properly trained. \nThe best results are in boldface --- if tie, {the winner is determined by comparing in the 4th decimal place.}}\n\\label{table:main}\n% \\small\n\\centering\n\\setlength{\\tabcolsep}{5pt}\n\n\\begin{tabular*}{0.85\\textwidth}{c|c|cccccccccccc}\n\n\\specialrule{1pt}{1pt}{1pt}\n&\\multirow{2}{*}{Methods}  & & & \\multicolumn{4}{c}{Single Minority}                                            &  &  & \\multicolumn{2}{c}{Multiple Minority}           & &      \\\\ \\cline{5-8} \\cline{11-12}\n                        & & &  & \\texttt{Default} & \\texttt{Shoppers} & \\texttt{Surgical} & \\texttt{WeatherAUS} &  &  & \\texttt{Buddy} & \\texttt{Satimage}                 &  &  \\\\ \\specialrule{1pt}{1pt}{1pt}\n\\multicolumn{2}{c|}{\\texttt{Identity}}         &&  & 0.515\\footnotesize{±0.035}    & 0.601\\footnotesize{±0.039}     & 0.687\\footnotesize{±0.004}     & 0.657\\footnotesize{±0.016}       &  &  & 0.603\\footnotesize{±0.010}          & 0.817\\footnotesize{±0.004}       &         \\\\ \\specialrule{1pt}{1pt}{1pt}\n\\multirow{10}{*}{\\rotatebox[origin=c]{90}{Baselines}} & \\texttt{SMOTE}           & &  & 0.561\\footnotesize{±0.025}    & 0.648\\footnotesize{±0.004}    & 0.678\\footnotesize{±0.008}     & 0.674\\footnotesize{±0.025}     &  &  & 0.584\\footnotesize{±0.005}     & 0.846\\footnotesize{±0.005}   & &           \\\\\n&\\texttt{B-SMOTE}         & &  & 0.561\\footnotesize{±0.029}    & 0.640\\footnotesize{±0.042}    & 0.671\\footnotesize{±0.004}    & 0.663\\footnotesize{±0.022}    &  &  & 0.595\\footnotesize{±0.003}    & 0.845\\footnotesize{±0.005}    & &          \\\\\n&\\texttt{Adasyn}          & &  & 0.558\\footnotesize{±0.023}    & 0.630\\footnotesize{±0.045}    & 0.662\\footnotesize{±0.007}    & 0.658\\footnotesize{±0.022}    &  &  & 0.608\\footnotesize{±0.002}           & 0.841\\footnotesize{±0.008}     &  &        \\\\\n&\\texttt{MedGAN}          & &  & 0.532\\footnotesize{±0.028}    & 0.620\\footnotesize{±0.062}    & 0.686\\footnotesize{±0.003}    & 0.656\\footnotesize{±0.022}      &  &  & 0.598\\footnotesize{±0.011}     & 0.835\\footnotesize{±0.019}  &  &        \\\\\n&\\texttt{VEEGAN}          & &  & 0.495\\footnotesize{±0.076}    & 0.607\\footnotesize{±0.065}   & 0.680\\footnotesize{±0.117} & 0.661\\footnotesize{±0.025}    &  &  & 0.555\\footnotesize{±0.036}           & 0.840\\footnotesize{±0.031} &   &       \\\\\n&\\texttt{TableGAN}        & &  & 0.423\\footnotesize{±0.115}    & 0.571\\footnotesize{±0.097}     & 0.704\\footnotesize{±0.001} & 0.579\\footnotesize{±0.066}       &  &  & 0.570\\footnotesize{±0.019}           & 0.813\\footnotesize{±0.013}      &    &      \\\\\n&\\texttt{TVAE}            & &  & 0.536\\footnotesize{±0.035}    & 0.610\\footnotesize{±0.060}    & 0.681\\footnotesize{±0.004}    & 0.652\\footnotesize{±0.018}       &  &  & 0.552\\footnotesize{±0.044}           & 0.846\\footnotesize{±0.031}     &     &     \\\\\n&\\texttt{CTGAN}           & &  & 0.545\\footnotesize{±0.022}    & 0.605\\footnotesize{±0.059}    & 0.701\\footnotesize{±0.004}    & 0.659\\footnotesize{±0.020}      &  &  & 0.593\\footnotesize{±0.009}           & 0.833\\footnotesize{±0.015}      &      &    \\\\\n&\\texttt{OCT-GAN}          &&  & 0.531\\footnotesize{±0.018}    & 0.639\\footnotesize{±0.029}    & 0.692\\footnotesize{±0.082}    & 0.656\\footnotesize{±0.018}       &  &  & 0.551\\footnotesize{±0.015}           & 0.837\\footnotesize{±0.011}      &       &   \\\\ \n&\\texttt{BAGAN}           & &  & 0.525\\footnotesize{±0.005}    & 0.610\\footnotesize{±0.005}    & 0.668\\footnotesize{±0.004}    & 0.663\\footnotesize{±0.002}       &  &  & 0.555\\footnotesize{±0.013}           & 0.834\\footnotesize{±0.011}      &        &  \\\\ \\hline\n\\multirow{3}{*}{\\rotatebox[origin=c]{90}{\\texttt{SOS}}} & VE         & &  &  0.571\\footnotesize{±0.003} &   \\textbf{0.675\\footnotesize{±0.004}}   &  0.709\\footnotesize{±0.003}  &   0.672\\footnotesize{±0.002}    &  &  &    0.607\\footnotesize{±0.007}       &      0.854\\footnotesize{±0.002}     &      &\\\\\n%& SGM w/ discriminator      &  & 0.5418±0.0058    & 0.6586±0.0031     & 0.7054±0.0023     & -  &  &  & -                       & -                          &  \\\\\n% & VE w/ fine-tune          &  &  -   &  -   &  -    &   -     &  &  &       -     &         -      &  \\\\  \\cline{2-12}\n% & VP w/o fine-tune         &  &  -   &  -   &  -    &   -     &  &  &       -     &         -      &  \\\\ \n& VP         & &  &  0.559\\footnotesize{±0.006} & 0.658\\footnotesize{±0.003}  &  0.712\\footnotesize{±0.002} &   0.680\\footnotesize{±0.002}     &  &  &     0.607\\footnotesize{±0.011}     &         \\textbf{0.857\\footnotesize{±0.006}}   & &    \\\\ \n% & Sub-VP w/o fine-tune     &  & 0.5725±0.0025    & 0.6700±0.0038    & 0.7086±0.0018     & 0.6809±0.0023      &  &  & 0.5994±0.0063           & 0.8442±0.0036             &  \\\\ \n& Sub-VP      & &  & \\textbf{0.574\\footnotesize{±0.003}}  &  0.673\\footnotesize{±0.002}    & \\textbf{0.714\\footnotesize{±0.001}}     & \\textbf{0.680\\footnotesize{±0.003}}      &  &  & \\textbf{0.608\\footnotesize{±0.002}}       & 0.855\\footnotesize{±0.004}      &  &      \\\\ \n\\specialrule{1pt}{1pt}{1pt}\n\n\\end{tabular*}   \n\\vspace{-0.5em}\n\\end{table*}",
            "table:sensitivity": "\\begin{table}[]\n\\caption{Results by some selected key hyperparameters}\n\\label{table:sensitivity}\n\\small\n\\centering\n\\setlength{\\tabcolsep}{3pt}\n\n\\begin{tabular}{c|cccccccccc}\n\\specialrule{1pt}{1pt}{1pt}\nHyper                                                                         &  & \\multicolumn{3}{c}{WeatherAUS}  &  &  & \\multicolumn{3}{c}{Satimage}    &  \\\\ \\cline{3-5} \\cline{8-10}\nParam.&  & Setting    &  & Weighted F1   &  &  & Setting    &  & Weighted F1   &  \\\\ \\specialrule{1pt}{1pt}{1pt}\n\\multirow{6}{*}{\\rotatebox[origin=c]{0}{$T$}}                            &  & 10           &  &   0.679\\footnotesize{±0.002}  &  &  & 10           &  & 0.841\\footnotesize{±0.008} &  \\\\\n                                                                         &  & 50          &  &   \\textbf{0.680\\footnotesize{±0.003}}  &  &  & 50          &  & \\textbf{0.857\\footnotesize{±0.006}} &  \\\\ \n                                                                         &  & 100          &  &   0.670\\footnotesize{±0.001}  &  &  & 100          &  & 0.846\\footnotesize{±0.004} &  \\\\ % \\hline\n                                                                         &  & 150          &  &   0.660\\footnotesize{±0.002}  &  &  & 150          &  & 0.847\\footnotesize{±0.005}\n &  \\\\ \n                                                                         &  & 200          &  &   0.666\\footnotesize{±0.002}  &  &  & 200          &  & 0.845\\footnotesize{±0.002} &  \\\\      \n                                                                         &  & 300          &  &   0.669\\footnotesize{±0.002}  &  &  & 300          &  & 0.849\\footnotesize{±0.004} &  \\\\ \\hline\n                                                                    \n\\multirow{5}{*}{\\rotatebox[origin=c]{90}{$(\\beta_{min}, \\beta_{max})$}}  &  & (0.01, 5.0)  &  &   0.671\\footnotesize{±0.000}  &  &  & (0.01, 1.0)  &  & 0.843\\footnotesize{±0.002} &  \\\\\n                                                                         &  & (0.01, 10.0) &  &   0.676\\footnotesize{±0.001}  &  &  & (0.01, 10.0) &  & \\textbf{0.848\\footnotesize{±0.003} }&  \\\\\n                                                                         &  & (0.1, 1.0)   &  &   \\textbf{0.676\\footnotesize{±0.002}}  &  &  & (0.1, 1.0)   &  & 0.820\\footnotesize{±0.004} &  \\\\\n                                                                         &  & (0.1, 5.0)   &  &   0.673\\footnotesize{±0.002}  &  &  & (0.1, 5.0)   &  & 0.834\\footnotesize{±0.008} &  \\\\\n                                                                         &  & (0.1, 10.0)  &  &   0.668\\footnotesize{±0.003}  &  &  & (0.1, 10.0)  &  & 0.834\\footnotesize{±0.014} &  \\\\ \\hline\n\\multirow{2}{*}{\\rotatebox[origin=c]{0}{$\\xi$}}                          &  & 80           &  &   0.679\\footnotesize{±0.003}  &  &  & 70           &  & 0.783\\footnotesize{±0.016} &  \\\\\n                                                                         &  & 90           &  &   \\textbf{0.680\\footnotesize{±0.002} } &  &  & 90           &  & \\textbf{0.854\\footnotesize{±0.005} }&  \\\\ \\hline\n\\multirow{2}{*}{\\rotatebox[origin=c]{0}{$w$}}                            &  & 0.99         &  &   0.680\\footnotesize{±0.003}  &  &  & 0.99         &  & \\textbf{0.856\\footnotesize{±0.006}} &  \\\\\n                                                                         &  & 0.90          &  &  \\textbf{0.680\\footnotesize{±0.003}} &  &  & 0.90          &  & 0.854\\footnotesize{±0.006} &  \\\\ \\hline\n\\multirow{4}{*}{\\rotatebox[origin=c]{0}{$\\epsilon_t$}}                   &  & 5e-04        &  & \\textbf{0.680\\footnotesize{±0.003}}  &  &  & 5e-04         &  & \\textbf{0.857\\footnotesize{±0.006}} &  \\\\\n                                                                         &  & 1            &  & 0.661\\footnotesize{±0.002}  &  &  & 1          &  & 0.850\\footnotesize{±0.004} &  \\\\\n                                                                         &  & 2            &  & 0.661\\footnotesize{±0.002}  &  &  & 2          &  & 0.857\\footnotesize{±0.004} &  \\\\\n                                                                         &  & 3            &  & 0.661\\footnotesize{±0.003}  &  &  & 3          &  & 0.854\\footnotesize{±0.002} & \\\\\n\\specialrule{1pt}{1pt}{1pt}\n\\end{tabular}\n\\vspace{-0.5em}\n\\end{table}",
            "table:ZvsN": "\\begin{table*}[]\n\\caption{Comparison between the boundary (Bnd.) vs. regular (Reg.) oversampling}\n\\label{table:ZvsN}\n\\small\n\\centering\n\\setlength{\\tabcolsep}{3pt}\n\\begin{tabular}{c|cccc|cccc|cccc}\n\\specialrule{1pt}{1pt}{1pt}\n\nSDE & &\\multicolumn{2}{c}{WeatherAUS}  && &\\multicolumn{2}{c}{Default} &&& \\multicolumn{2}{c}{Satimage} & \\\\ \\cline{3-4}\\cline{7-8}\\cline{11-12}\nType   && Bnd.           & Reg.          &&& Bnd.         & Reg.         &&& Bnd.          & Reg.          &\\\\ \\specialrule{1pt}{1pt}{1pt}\n\\texttt{SOS} (VE)     && 0.670\\footnotesize{±0.002}    & 0.672\\footnotesize{±0.002}   &&& 0.569\\footnotesize{±0.001}  & 0.571\\footnotesize{±0.002}  &&& 0.854\\footnotesize{±0.004}   & 0.854\\footnotesize{±0.002}   &\\\\\n\\texttt{SOS} (VP)     && 0.673\\footnotesize{±0.002}    & 0.680\\footnotesize{±0.002}   &&& 0.559\\footnotesize{±0.005}  & 0.557\\footnotesize{±0.004}  &&& 0.855\\footnotesize{±0.005}   & \\textbf{0.857\\footnotesize{±0.006}}  &\\\\\n\\texttt{SOS} (Sub-VP) && \\textbf{0.680\\footnotesize{±0.003}}    & 0.651\\footnotesize{±0.002}   &&& \\textbf{0.574\\footnotesize{±0.003}}  & 0.574\\footnotesize{±0.002}  &&& 0.854\\footnotesize{±0.005}   & 0.855\\footnotesize{±0.004}   & \\\\ \n\\specialrule{1pt}{1pt}{1pt}\n\n\\end{tabular}\n\\end{table*}",
            "table:pc_sampler": "\\begin{table}\n\\small\n\\centering\n\\setlength{\\tabcolsep}{2pt}\n\n\\caption{Results by the reverse SDE solver (or predictor). We consider the predictors of Euler-Maruyama (EM), Ancestral Sampling (AS), Reverse Diffusion (RD), and Probability Flow (PF).}\\label{table:pc_sampler}\n    \\subtable[Surgical]{\n        \\centering\n        \\begin{tabular}{ccc|cccc|cccc}\n        \\specialrule{1pt}{1pt}{1pt}\n        & \\multirow{2}{*}{Predictor} &  & & \\multicolumn{2}{c}{VE} & & & \\multicolumn{2}{c}{VP} & \\\\ \\cline{5-6} \\cline{9-10}\n        &  & & &   Pred. only  &  Pred. Corr.  & & &    Pred. only   &  Pred. Corr. & \\\\ \n        % &  & & &   only      &  only      &    Corr.    & & &    only     &  only      & Corr.  & \\\\ \n        \n        \\specialrule{1pt}{1pt}{1pt}\n        & EM          & &  & 0.709\\footnotesize{±0.002} & \\textbf{0.709\\footnotesize{±0.003}} &     & & 0.710\\footnotesize{±0.004} & \\textbf{0.712\\footnotesize{±0.002}} & \\\\\n        & AS          & &  & 0.706\\footnotesize{±0.002}  &  0.707\\footnotesize{±0.003}  &    & & 0.706\\footnotesize{±0.004} & 0.711\\footnotesize{±0.002} & \\\\\n        & RD          & & & 0.701\\footnotesize{±0.003} &  0.708\\footnotesize{±0.003}  &    & & 0.707\\footnotesize{±0.002} &  0.711\\footnotesize{±0.001} & \\\\\n        & PF          & &  &  \\multicolumn{2}{c}{0.704\\footnotesize{±0.004}} &    & &  \\multicolumn{2}{c}{0.712\\footnotesize{±0.002}} & \\\\\n        \\specialrule{1pt}{1pt}{1pt}\n        \\end{tabular}\n        % \\subcaption{Surgical}\n        \\label{table:surgical}}\n    \\subtable[Shoppers]{\n        \\centering\n        \\begin{tabular}{ccc|cccc|cccc}\n        \\specialrule{1pt}{1pt}{1pt}\n        & \\multirow{2}{*}{Predictor} &  & & \\multicolumn{2}{c}{VE} & & & \\multicolumn{2}{c}{VP} & \\\\ \\cline{5-6} \\cline{9-10}\n        &  & & &   Pred. only  &  Pred. Corr.  & & &    Pred. only   &  Pred. Corr. & \\\\ \n        % &  & & &   only      &  only      &    Corr.    & & &    only     &  only      & Corr.  & \\\\ \n        \n        \\specialrule{1pt}{1pt}{1pt}\n        & EM          & &  & 0.668\\footnotesize{±0.003} & 0.664\\footnotesize{±0.005}  &     & & 0.648\\footnotesize{±0.007} & 0.651\\footnotesize{±0.005} & \\\\\n        & AS          & &  & \\textbf{0.675\\footnotesize{±0.006}} & 0.661\\footnotesize{±0.003}  &    & & 0.646\\footnotesize{±0.002}  & \\textbf{0.657\\footnotesize{±0.002}} & \\\\\n        & RD          & &  & 0.673\\footnotesize{±0.005} & 0.671\\footnotesize{±0.006}  &    & & 0.640\\footnotesize{±0.004}  & 0.655\\footnotesize{±0.004} & \\\\\n        & PF          & &  & \\multicolumn{2}{c}{0.674\\footnotesize{±0.004}}  &    & &  \\multicolumn{2}{c}{0.640\\footnotesize{±0.005}} & \\\\\n        \\specialrule{1pt}{1pt}{1pt}\n        \\end{tabular}\n        % \\subcaption{Shoppers}\n        \\label{table:shoppers}}\n\\end{table}",
            "table:abl_adv": "\\begin{table*}[]\n\\caption{Results of No Fine-tuning vs. Adversarial SGM vs. Fine-tuning}\n\\label{table:abl_adv}\n\\small\n\\centering\n\\setlength{\\tabcolsep}{2pt}\n\\begin{tabular}{c|ccccc|ccccc|ccccc}\n\\specialrule{1pt}{1pt}{1pt}\n\nSDE \n&&   \\multicolumn{3}{c}{\\texttt{Shoppers}}  &\n&&   \\multicolumn{3}{c}{\\texttt{Surgical}}  &\n&&   \\multicolumn{3}{c}{\\texttt{Default}}  &\\\\  \\cline{3-5} \\cline{8-10} \\cline{13-15}\nType\n&&   No Fine-Tune    &   Adv. SGM    &   Fine-Tune &\n&&   No Fine-Tune    &   Adv. SGM    &   Fine-Tune &\n&&   No Fine-Tune    &   Adv. SGM    &   Fine-Tune &\\\\ \\specialrule{1pt}{1pt}{1pt}\n\\texttt{SOS} (VE)  \n&&  0.672\\footnotesize{±0.003}  &   0.651\\footnotesize{±0.005}    &   \\textbf{0.675\\footnotesize{±0.004}}&\n&&  0.709\\footnotesize{±0.004} &   0.692\\footnotesize{±0.003} &   0.709\\footnotesize{±0.003}\t&\n&&\t0.567\\footnotesize{±0.001}\t&\t0.565\\footnotesize{±0.002}\t&\t0.571\\footnotesize{±0.002}   &\t\\\\\n\\texttt{SOS} (VP)\t \n&&\t0.652\\footnotesize{±0.004}\t&\t0.651\\footnotesize{±0.005}\t&\t0.658\\footnotesize{±0.002}             &\n&&\t0.708\\footnotesize{±0.002} &\t0.689\\footnotesize{±0.001} \t&\t0.712\\footnotesize{±0.002}   &\n&&\t0.558\\footnotesize{±0.004}\t&\t0.557\\footnotesize{±0.004}\t&\t0.559\\footnotesize{±0.006}   &\t\\\\\n\\texttt{SOS} (Sub-VP)\n&&\t0.667\\footnotesize{±0.005}\t&\t0.659\\footnotesize{±0.003}\t&\t0.673\\footnotesize{±0.002}   &\n&&\t0.712\\footnotesize{±0.003}\t&\t0.705\\footnotesize{±0.002}\t&\t\\textbf{0.714\\footnotesize{±0.001}}   &\n&&\t0.570\\footnotesize{±0.001}\t&\t0.555\\footnotesize{±0.003}\t&\t\\textbf{0.574\\footnotesize{±0.003}}   &   \\\\ \n\\specialrule{1pt}{1pt}{1pt}\n\n\\end{tabular}\n\\vspace{-5pt}\n\\end{table*}",
            "table:hyperparameters_sgm": "\\begin{table*}[t]\n\\caption{The best hyperparameters of \\texttt{SOS} we used in Table~\\ref{table:main}. `(min, max)' means $(\\beta_{min}, \\beta_{max})$ for VP and Sub-VP or $(\\sigma_{min}, \\sigma_{max})$ for VE, respectively.}\n% $\\dim(\\mathbf{x})$ means the dimensionality of $\\mathbf{x}$.\n\\label{table:hyperparameters_sgm}\n\\small\n\\centering\n\\setlength{\\tabcolsep}{2pt}\n% \\resizebox{width=\\textwidth}{!}{\n% \\begin{adjustbox}{angle=90}\n\\begin{tabular}{c|c|cccccccccc}\n\n\\specialrule{1pt}{1pt}{1pt}\n\n\\multirow{2}{*}{Dataset} \n& SDE &\n&   \\multicolumn{8}{c}{Hyperparameters for \\texttt{SOS}}  &\\\\  \n\\cline{4-11}\n\n& Type &\n& Layer Type & $( \\dim(h_1), \\dim(h_1), \\dots, \\dim(h_{d_{N}}))$ &  Activation & Learn. Rate  &   (min, max)  &  Pred. & Corr. & SNR &\\\\ \n\\specialrule{1pt}{1pt}{1pt}\n\\multirow{3}{*}{\\texttt{Default}}\n& VE &\n&\\multirow{3}{*}{Concat}  &\t(512, 1024, 1024, 512)\t& \\multirow{3}{*}{LeakyReLU} \n& \\multirow{3}{*}{2e-03}  & (0.01, 5.0) & RD & Langevin & 0.05  &  \\\\\n& VP &\n&&(256, 512, 1024, 1024, 512, 256)&\n& - & (0.1, 5.0) & PF & None & -  & \\\\\n& Sub-VP &\n&&(512, 1024, 1024, 512)& \n&  & (0.01, 1.0) & EM & None &  - & \\\\\n\\hline\n\\multirow{3}{*}{\\texttt{Shoppers}}\n& VE &\n&\t\\multirow{3}{*}{Concatsquash}   &\t\\multirow{3}{*}{(512, 1024, 2048, 1024, 512)}\t& \\multirow{3}{*}{ReLU} \n& \\multirow{3}{*}{1e-03} & (0.1, 5.0) & AS & None & - &  \\\\\n& VP &\n&&&  \n& - & (0.01, 5.0) & RD & Langevin & 0.05 & \\\\\n& Sub-VP &\n&&& \n&  & (0.1, 10.0) & EM & None &  -  & \\\\\n\\hline\n\\multirow{3}{*}{\\texttt{Surgical}}\n& VE &\n&\t\\multirow{2}{*}{Squash}   &\t\\multirow{2}{*}{(256, 512, 1024, 1024, 512, 256)}\t&\t \\multirow{3}{*}{ReLU} & \\multirow{3}{*}{2e-03} & (0.1, 10.0)  & EM & Langevin & 0.05  &  \\\\\n& VP & &&&   &  & (0.01, 5.0) & EM & Langevin & 0.16  & \\\\\n& Sub-VP &\n& Concat & (512, 1024, 1024, 512) & &  & (0.1, 10.0)  & PF & None &  -  & \\\\\n\\hline\n\\multirow{3}{*}{\\texttt{WeatherAUS}}\n& VE &\n&\t\\multirow{3}{*}{Concat}   &\t\\multirow{3}{*}{(512, 1024, 2048, 1024, 512)}\t&\t \\multirow{3}{*}{LeakyReLU} \n& \\multirow{2}{*}{2e-04} & (0.01, 5.0) & AS & Langevin & 0.16  &  \\\\\n& VP &\n&&&  \n&  & (0.01, 10.0) & RD & None & -  & \\\\\n& Sub-VP &\n&&& \n& 2e-03 & (0.01, 1.0) & EM & None &  -  & \\\\\n\\hline\n\\multirow{3}{*}{\\texttt{Buddy}}\n& VE &\n&\tConcat   &\\multirow{3}{*}{(256, 512, 1024, 1024, 512, 256)}& \\multirow{3}{*}{SoftPlus} & \\multirow{3}{*}{2e-03} & (0.5, 5.0)&PF  & None & - &\\\\\n& VP &\n& \\multirow{2}{*}{Squash} & &  \n&  & (0.5, 10.0) & PF & None & -  & \\\\\n& Sub-VP &\n& & &  \n&  & (0.1, 10.0) & PF & None &  -  & \\\\\n% & Sub-VP & & Squash & (128, 256, 512, 512, 256, 128) & SoftPlus & 2e-03 & (0.5, 10.0) & EM & None &  -  & \\\\\n\\hline\n\\multirow{3}{*}{\\texttt{Satimage}}\n& VE &\n&\t\\multirow{3}{*}{Concat}   &\t\\multirow{3}{*}{(512, 1024, 2048, 2048, 1024, 512)}\t&\t \\multirow{3}{*}{LeakyReLU} \n& \\multirow{3}{*}{2e-04}  & (0.01, 5.0) & RD & None & -  &  \\\\\n& VP &\n&&&  \n& - & (0.01, 5.0) & RD & Langevin & 0.05  & \\\\\n& Sub-VP &\n&&& \n&  & (0.1, 5.0) & EM & None &  - & \\\\\n\\specialrule{1pt}{1pt}{1pt}\n\\end{tabular}\n% \\end{adjustbox}\n% }\n\n\\end{table*}",
            "table:hyperparameters_finetune": "\\begin{table}[]\n\\caption{The best hyperparameters of the fine-tuning process we used in Table~\\ref{table:main} }\n\\label{table:hyperparameters_finetune}\n\\small\n\\centering\n\\setlength{\\tabcolsep}{3pt}\n% \\resizebox{width=\\textwidth}{!}{\n% \\begin{adjustbox}{angle=90}\n\\begin{tabular}{c|c|cccccccc}\n\n\\specialrule{1pt}{1pt}{1pt}\n\n\\multirow{2}{*}{Dataset} \n& SDE &\n&   \\multicolumn{6}{c}{Hyperparameters for fine-tuning} &\\\\  \n\\cline{4-9}\n \n& Type &\n& $\\epsilon_{t}$ & Learn. Rate  &    $\\xi$  & $w$ & Epoch & Option & \\\\ \n\\specialrule{1pt}{1pt}{1pt}\n\\multirow{3}{*}{\\texttt{Default}}\n& VE &\n& 5e-04 &\t2e-06\t&\t80\t& 0.90 & 4 & Reg. & \\\\\n& VP &\n& 2 &\t2e-08\t&\t80\t&\t0.95 & 1 & Bnd. &\\\\\n& Sub-VP &\n& 5e-04 &\t2e-06\t&\t90\t&\t0.95 & 1 &  Bnd. &\\\\\n\\hline\n\\multirow{3}{*}{\\texttt{Shoppers}}\n& VE &\n& 5e-04 &\t2e-07\t&\t90\t& 0.80 & 1 & Bnd. &\\\\\n& VP &\n&  5e-04 &\t2e-06\t&\t100\t&\t0.95 & 3 & Reg. &\\\\\n& Sub-VP &\n& 5e-04 &\t2e-05\t&\t80\t&\t0.95\t& 2 & Bnd.&\\\\\n\\hline\n\\multirow{3}{*}{\\texttt{Surgical}}\n& VE &\n& 5e-04&\t2e-08\t&\t80\t& 0.99 & 3 & Reg. &\\\\\n& VP &\n& 5e-04 &\t2e-06\t&\t100\t&\t0.90 & 5 & Reg. &\\\\\n& Sub-VP &\n& 2 &\t2e-07\t&\t80\t&\t0.95\t& 3 & Bnd.&\\\\\n\\hline\n\\multirow{3}{*}{\\texttt{WeatherAUS}}\n& VE &\n& 5e-04 &\t2e-05\t&\t100\t& 0.70 & 4 & Reg. &\\\\\n& VP &\n& 5e-04 &\t2e-07\t&\t60\t&\t0.60 & 1 & Reg. &\\\\\n& Sub-VP &\n& 5e-04 &\t2e-07\t&\t100\t&\t0.95\t& 1 & Bnd. &\\\\\n\\hline\n\\multirow{3}{*}{\\texttt{Buddy}}\n& VE &\n& 5e-04 &\t2e-07\t&\t80\t& 0.99 & 3 & Bnd. &\\\\\n& VP &\n& 5e-04 &\t2e-07 &\t80\t& 0.90 & 3 & Bnd.&\\\\\n& Sub-VP &\n& 2 &\t2e-03\t&\t80\t&\t0.90\t& 4 & Bnd. &\\\\\n\\hline\n\\multirow{3}{*}{\\texttt{Satimage}}\n& VE &\n& 5e-04 &\t2e-07\t&\t80\t& 0.95 & 3 & Reg. &\\\\\n& VP &\n& 5e-04 &\t2e-06\t&\t80\t&\t0.95 & 4 & Reg. &\\\\\n& Sub-VP &\n& 5e-04 &\t2e-08\t&\t80\t&\t0.70\t& 5 & Reg. & \\\\\n\\specialrule{1pt}{1pt}{1pt}\n\\end{tabular}\n% \\end{adjustbox}\n% }\n\n\\end{table}",
            "tbl:entire_synthesis": "\\begin{table*}[t]\n\\small\n\\centering\n\\setlength{\\tabcolsep}{3pt}\n\\caption{Results of experiments synthesizing full fake tabular data}\\label{tbl:entire_synthesis}\n\\begin{tabular}{ccc|cccc|cccc|cccc}\n\\specialrule{1pt}{1pt}{1pt}\n& \\multirow{2}{*}{Method} &  & & \\multicolumn{2}{c}{\\texttt{Shoppers}} & & &  \\multicolumn{2}{c}{\\texttt{Surgical}}  & & &  \\multicolumn{2}{c}{\\texttt{Satimage}}  &    \\\\  \\cline{5-6} \\cline{9-10} \\cline{13-14}\n\n&  & &  & Acc. & F1 & & & Acc. & F1  & & & Acc. & F1 & \\\\  \n\\specialrule{1pt}{1pt}{1pt}\n\n\n& \\texttt{Identity}           & & & 0.883\\footnotesize{±0.002}  & 0.503\\footnotesize{±0.005}   & & & 0.827\\footnotesize{±0.002} & 0.608\\footnotesize{±0.005} & & & 0.846\\footnotesize{±0.002}  & 0.799\\footnotesize{±0.003}  &  \\\\\n\\hline\n& \\texttt{CTGAN}              & & & 0.778\\footnotesize{±0.009}  & 0.440\\footnotesize{±0.012}   & & & 0.716\\footnotesize{±0.004} & 0.472\\footnotesize{±0.003} & & &  0.735\\footnotesize{±0.010}  & 0.699\\footnotesize{±0.007}  &   \\\\\n& \\texttt{OCT-GAN}            & & & 0.835\\footnotesize{±0.011}  & 0.490\\footnotesize{±0.010}   & & & 0.695\\footnotesize{±0.026} & 0.527\\footnotesize{±0.014} & & &  0.798\\footnotesize{±0.008}  & 0.767\\footnotesize{±0.009}  &    \\\\\n& \\texttt{TableGAN}           & & & 0.854\\footnotesize{±0.024}  & 0.515\\footnotesize{±0.013}   & & & 0.752\\footnotesize{±0.003} & 0.496\\footnotesize{±0.009} & & &  0.783\\footnotesize{±0.007}  & 0.710\\footnotesize{±0.007}  &    \\\\\n& \\texttt{TVAE}               & & & 0.855\\footnotesize{±0.004}  & 0.476\\footnotesize{±0.009}   & & & 0.778\\footnotesize{±0.004} & 0.427\\footnotesize{±0.019} & & &  0.825\\footnotesize{±0.004}  & 0.779\\footnotesize{±0.008}  &    \\\\\n\\hline\n& SOS          & & &  \\textbf{0.874\\footnotesize{±0.002}} & \\textbf{0.618\\footnotesize{±0.003}}  & & &  \\textbf{0.798\\footnotesize{±0.003}}  & \\textbf{0.549\\footnotesize{±0.005}}   & & &  \\textbf{0.852\\footnotesize{±0.003}} & \\textbf{0.815\\footnotesize{±0.004}} &  \\\\\n\\specialrule{1pt}{1pt}{1pt}\n\\end{tabular}\n\\end{table*}",
            "table:time": "\\begin{table}[t]\n\\caption{The runtime and GPU memory usage (averaged across classes) of \\texttt{SOS} (Sub-VP) with the EM predictor.}\n\\label{table:time}\n\\small\n\\centering\n\\setlength{\\tabcolsep}{2pt}\n\n% \\begin{tabular}{c|cccccccccccc}\n% \\specialrule{1pt}{1pt}{1pt}\n\n%                  &  & \\texttt{Default} &  & \\texttt{Shoppers} &  & \\texttt{Surgical} &  & \\texttt{WeatherAUS} &  & \\texttt{Buddy} &  &\\texttt{Satimage} \\\\ \\hline\n% Class size       &  & 15,000   &  & 6,165     &  & 7,318     &  & 28,210      &  & 9,417  &  & 3,186     \\\\\n% GPU Memory Usage(MB) &  &  4,196        &  & 4,608        &  & 4,616          &  & 4,812     &  & 4,357  & &  4,424         \\\\\n% sec. per 1 epoch &  & 0.395   &  & 0.067    &  & 0.185    &  & 0.606      &  & 0.157 &  & 0.036    \\\\\n% Generation time  &  & 0.901   &  & 0.824    &  & 0.952    &  & 1.766      &  & 1.718 &  & 4.240   \\\\\n% \\specialrule{1pt}{1pt}{1pt}\n\n% \\end{tabular}\n\\begin{tabular}{c|c|c|c|c}\n\\specialrule{1pt}{1pt}{1pt}\n\\multirow{2}{*}{Dataset}    &   Avg.        &   GPU Memory    &   Train Time        &   Total Gen. \\\\ \n                            &   Class size  &   Usage (MB)    &   per Epoch (sec)   &   Time (sec) \\\\  \\specialrule{1pt}{1pt}{1pt}\n\\texttt{Satimage}   &   3,186   &   4,424   &   0.036   &   4.240  \\\\\n\\texttt{Shoppers}   &   6,165   &   4,608   &   0.067   &   0.824 \\\\\n\\texttt{Surgical}   &   7,318   &   4,616   &   0.185   &   0.952 \\\\ \n\\texttt{Buddy}      &   9,417   &   4,357   &   0.157   &   1.718 \\\\\n\\texttt{Default}    &   15,000  &   4,196   &   0.395   &   0.901 \\\\\n\\texttt{WeatherAUS} &   28,210  &   4,812   &   0.606   &   1.766 \\\\\n\\specialrule{1pt}{1pt}{1pt}\n\\end{tabular}\n\\end{table}"
        },
        "figures": {
            "fig:archi": "\\begin{figure}[t]\n    \\centering\n    \\subfigure[The overall workflow of score-based generative models, where the score function is approximated by a score network, i.e., $S_{\\theta}(\\mathbf{x}_t,t) \\approx \\nabla_\\mathbf{x}\\log p_t(\\mathbf{x})$. We note that it means the gradient of the log probability w.r.t. $\\mathbf{x}$ at time $t$.]{\\includegraphics[width=0.9\\columnwidth]{images/SGM.pdf}}\n    \\subfigure[The proposed concept where i) we transfer a non-target (or major) record $\\mathbf{x}^+_0$ to a synthesized target (or minor) record $\\hat{\\mathbf{x}}^-_0$ or ii) we sample a noisy vector $\\mathbf{z}$ and generate $\\hat{\\mathbf{x}}^-_0$.]{\\includegraphics[width=0.9\\columnwidth]{images/patrick.pdf}}\n    \\subfigure[The proposed fine-tuning method where we i) compare the two gradients, and ii) fine-tune $\\theta_-$ to enhance the sampling quality.]{\\includegraphics[width=0.9\\columnwidth]{images/fine4.pdf}}\n    % \\subfigure[An example of fine-tuning where the probability of generating $\\hat{\\mathbf{a}}^-_0$ decreases]{\\includegraphics[width=0.65\\columnwidth,trim={0.5cm 0 0 0},clip]{images/fine2.pdf}}\n     \\caption{In this figure, we assume one major (non-target) and one minor (target) classes for ease of discussion but our propose method can be applied to multiple minor classes. (a) The reverse SDE can be considered as a generator since it produces data from noise. (b) The combination of the major (non-target) class's forward SDE and the minor (target) class's reverse SDE can be considered as a \\emph{style transfer}-based oversampling process. (c) The fine-tuning process can further enhance the minor (target) class's score network.}\n    \\label{fig:archi}\n    \\vspace{-2em}\n\\end{figure}",
            "fig:asm": "\\begin{figure}\n    \\centering\n    \\subfigure[Adversarial score matching where the score network $S_\\theta$ is trained with i) the denoising score matching loss in Eq.~\\eqref{eq:sgm} and ii) the adversarial training.]{\\includegraphics[width=0.9\\columnwidth]{images/asm.pdf}}\n    \\subfigure[Langevin corrector highlighted in purple]{\\includegraphics[width=0.7\\columnwidth]{images/lan.pdf}}\n    \\caption{Two ideas further improving the synthesis quality of SGMs. (a) The adversarial score matching model combining SGMs and GANs. (b) The correction algorithm, called \\emph{Langevin corrector}, where $\\hat{\\mathbf{x}}'_0$ has a higher log probability than $\\hat{\\mathbf{x}}_0$ since we move following the gradient of the log probability.}\n    \\label{fig:asm}\n    \\vspace{-1,5em}\n\\end{figure}",
            "fig:patrick": "\\begin{figure}\n    \\centering\n    \\subfigure[Option 1: Style transfer-based oversampling which corresponds to \\emph{oversampling around class boundary}]{\\includegraphics[width=\\columnwidth]{images/patrick2.pdf}}\n    \\subfigure[Option 2: Plain score-based oversampling]{\\includegraphics[width=0.6\\columnwidth]{images/patrick3.pdf}}\n    \\caption{Another diagram showing our model architectures. In this figure, we assume multiple minor classes. Given a set of classes $\\{\\mathcal{C}_m\\}_{m=1}^M$, suppose that a target minor class is $\\mathcal{C}_1$, for which we aim at oversampling. (a) We randomly choose $\\mathbf{x}^+_0$ from other non-target classes $\\{\\mathcal{C}_m\\}_{m=2}^M$. (b) We randomly sample a noisy vector $\\mathbf{z}$.}\n    \\label{fig:patrick}\n    \\vspace{-1em}\n\\end{figure}",
            "fig:tune": "\\begin{figure}\n    \\centering\n    \\includegraphics[width=0.7\\columnwidth]{images/fig4_5.pdf}\n    \\caption{Suppose that we want to fine-tune $\\theta_j$ for class $\\mathcal{C}_j$. At $(\\mathbf{x}_t,t)$, the two gradients evaluated with Eq.~\\eqref{eq:eval}, $\\mathbf{g}^j_{\\mathbf{x}, t}$ and $\\mathbf{g}^i_{\\mathbf{x}, t}$, create a small angle. Then, we suppress the denoising process (or reverse SDE) toward $\\mathbf{g}^j_{\\mathbf{x}, t}$ by a factor of $w$, as noted in Eq.~\\eqref{eq:tune}, to avoid the gray region where both target and non-target class records are likely to {co-exist}.}\n    \\label{fig:tune}\n\\vspace{-1em}\n\\end{figure}",
            "fig:histogram": "\\begin{figure}[t]\n    \\centering\n    \\subfigure[\\texttt{Surgical} (bmi)]{\\includegraphics[width=0.48\\columnwidth]{images/surgical_histogram.pdf}}\n    \\subfigure[\\texttt{WeatherAUS} (temperature)]{\\includegraphics[width=0.48\\columnwidth]{images/weatherAUS_histo.pdf}}\n    \\caption{Column-wise Histogram}\n    \\label{fig:histogram}\n    \\vspace{-1em}\n\\end{figure}",
            "fig:majortominor": "\\begin{figure}[t]\n    \\centering\n    \\includegraphics[width=0.8\\columnwidth]{images/tsne_right_label.pdf}\n    \\caption{t-SNE plot of real/fake records by our method with boundary oversampling on \\texttt{WeatherAUS}. Blue dots mean non-target records, i.e., $\\mathbf{x}^+_0$, and red dots mean fake target records, i.e., $\\hat{\\mathbf{x}}^-_0$. Black arrows show which non-target records are style-transferred to which target records.}\n    \\label{fig:majortominor}\n    \\vspace{-1em}\n\\end{figure}",
            "fig:loss_curve": "\\begin{figure}[t]\n    \\centering\n    \\includegraphics[width=0.7\\columnwidth]{images/default_loss.pdf}\n    \\caption{The training loss curves of \\texttt{SOS} in \\texttt{Default}}\n    \\label{fig:loss_curve}\n\\end{figure}",
            "fig:full_fake_loss_curve": "\\begin{figure}[t]\n    \\centering\n    \\includegraphics[width=0.7\\columnwidth]{images/satimage_loss_mean.pdf}\n    \\caption{The training loss curves of the MLP classifier before and after oversampling in \\texttt{Satimage}}\n    \\label{fig:full_fake_loss_curve}\n\\end{figure}"
        },
        "equations": {
            "eq:eq:forward": "\\begin{align}\\label{eq:forward}\nd\\mathbf{x}=\\mathbf{f}(\\mathbf{x},t)dt + g(t)d\\mathbf{w},\n\\end{align}",
            "eq:eq:reverse": "\\begin{align}\\label{eq:reverse}\nd\\mathbf{x}=\\big(\\mathbf{f}(\\mathbf{x},t)-g^2(t)\\nabla_\\mathbf{x} \\log p_t(\\mathbf{x})\\big)dt + g(t)d\\mathbf{w},\n\\end{align}",
            "eq:eq:sgm": "\\begin{align}\\label{eq:sgm}\n    \\argmin_{\\theta} \\mathbb{E}_t \\mathbb{E}_{\\mathbf{x}_t} \\mathbb{E}_{\\mathbf{x}_0} \\Big[\\lambda(t) \\|S_{\\theta}(\\mathbf{x}_t, t) -\\nabla_{\\mathbf{x}_t} \\log p(\\mathbf{x}_t|\\mathbf{x}_0) \\|_2^2 \\Big],\n\\end{align}",
            "eq:1": "\\begin{align*}\n\\begin{split}\n    \\mathop{min}_{\\substack{\\mathtt{G}}}\\mathop{max}_{\\substack{\\mathtt{D}}} \\mathbb{E}_{p_{d}}[\\mathtt{D}(\\mathbf{x})]-\\mathbb{E}_{p_{z}}[\\mathtt{D}(\\mathtt{G}(\\mathbf{z}))] -\\lambda\\mathbb{E}_{p_{\\tilde{\\mathbf{x}}}}[(\\|\\nabla_{\\tilde{\\mathbf{x}}}\\mathtt{D}(\\tilde{\\mathbf{x}})\\|_2-1)^2],\n\\end{split}\\end{align*}",
            "eq:2": "\\begin{align}\n    % p_{0t}(\\mathbf{x}(t)|\\mathbf{x}(0))=\\begin{cases}\n    % \\mathcal{N}(\\mathbf{x}(t);\\mathbf{x}(0),[\\sigma^2(t)-\\sigma^2(0)]\\textbf{I}) ,\\textrm{ if VE,}\\\\\n    % \\mathcal{N}(\\mathbf{x}(t);\\mathbf{x}(0)e^{-\\frac{1}{2}\\int_0^t \\beta(s)\\, \\mathbf{d}s}, \\textbf{I} -  \\textbf{I}e^{-\\int_0^t \\beta(s)\\, \\mathbf{d}s}  ) ,\\textrm{ if VP,}\\\\\n    % \\mathcal{N}(\\mathbf{x}(t);\\mathbf{x}(0)e^{-\\frac{1}{2}\\int_0^t \\beta(s)\\, \\mathbf{d}s}, [1-e^{-\\int_0^t \\beta(s)\\, \\mathbf{d}s}]^2 \\textbf{I} ) ,\\textrm{ if Sub-VP,}\\\\\n    % \\end{cases}\n    \\mathbf{z} \\sim \\begin{cases}\n     \\mathcal{N}(\\mathbf{0}, \\sigma^2_{max}), &\\textrm{ if VE,}\\\\\n     \\mathcal{N}(\\mathbf{0}, \\mathbf{1}), &\\textrm{ if VP,}\\\\\n     \\mathcal{N}(\\mathbf{0}, \\mathbf{1}), &\\textrm{ if Sub-VP,}\\\\\n    \\end{cases}\n\\end{align}",
            "eq:3": "\\begin{align}\n    f(t)&=\\begin{cases}0,  &\\textrm{ if VE,}\\\\\n    -\\frac{1}{2}\\beta(t)\\mathbf{x},&\\textrm{ if VP,}\\\\\n    -\\frac{1}{2}\\beta(t)\\mathbf{x},&\\textrm{ if Sub-VP,}\\\\\n    \\end{cases}\\\\\n    g(t)&=\\begin{cases}\\sqrt{\\frac{\\texttt{d}[\\sigma^2(t)]}{\\texttt{d}t}},&\\textrm{ if VE,}\\\\\n    \\sqrt{\\beta(t)},&\\textrm{ if VP,}\\\\\n    \\sqrt{\\beta(t)(1-e^{-2\\int_0^t \\beta(s)\\, \\texttt{d}s})},&\\textrm{ if Sub-VP,}\\\\\n    \\end{cases}\n\\end{align}",
            "eq:4": "\\begin{align*}\n    \\mathbf{h}_0     &=  \\mathbf{x}_t,\\\\\n    \\mathbf{h}_i     &=  \\omega( \\mathtt{H}_i(\\mathbf{h}_{i-1}, t) \\oplus \\mathbf{h}_{i-1} ), 1 \\le i \\le d_N\\\\\n    S_{\\boldsymbol{\\theta}}(\\mathbf{x}_t, t) &= \\mathtt{FC}(\\mathbf{h}_{d_N}),\n\\end{align*}",
            "eq:5": "\\begin{align*}\n    \\mathtt{H}_i(\\mathbf{h}_{i-1}, t) &= \n        \\begin{cases}\n            \\texttt{FC}_{i}(\\mathbf{h}_{i-1}) \\odot \\psi(\\texttt{FC}^{t}_{i}(t)), &\\textrm{ if Squash,}\\\\\n            \\texttt{FC}_{i}(t \\oplus \\mathbf{h}_{i-1}), &\\textrm{ if Concat,} \\\\\n            \\texttt{FC}_{i}(\\mathbf{h}_{i-1}) \\odot \\psi(\\texttt{FC}^{gate}_{i}(t) + \\texttt{FC}^{bias}_{i}(t)), &\\textrm{ if Concatsquash,}\n        \\end{cases}\n\\end{align*}"
        },
        "git_link": "https://github.com/JayoungKim408/SOS"
    }
}