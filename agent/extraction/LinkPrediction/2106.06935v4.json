{
    "meta_info": {
        "title": "Neural Bellman-Ford Networks: A General Graph Neural Network Framework  for Link Prediction",
        "abstract": "Link prediction is a very fundamental task on graphs. Inspired by traditional\npath-based methods, in this paper we propose a general and flexible\nrepresentation learning framework based on paths for link prediction.\nSpecifically, we define the representation of a pair of nodes as the\ngeneralized sum of all path representations, with each path representation as\nthe generalized product of the edge representations in the path. Motivated by\nthe Bellman-Ford algorithm for solving the shortest path problem, we show that\nthe proposed path formulation can be efficiently solved by the generalized\nBellman-Ford algorithm. To further improve the capacity of the path\nformulation, we propose the Neural Bellman-Ford Network (NBFNet), a general\ngraph neural network framework that solves the path formulation with learned\noperators in the generalized Bellman-Ford algorithm. The NBFNet parameterizes\nthe generalized Bellman-Ford algorithm with 3 neural components, namely\nINDICATOR, MESSAGE and AGGREGATE functions, which corresponds to the boundary\ncondition, multiplication operator, and summation operator respectively. The\nNBFNet is very general, covers many traditional path-based methods, and can be\napplied to both homogeneous graphs and multi-relational graphs (e.g., knowledge\ngraphs) in both transductive and inductive settings. Experiments on both\nhomogeneous graphs and knowledge graphs show that the proposed NBFNet\noutperforms existing methods by a large margin in both transductive and\ninductive settings, achieving new state-of-the-art results.",
        "author": "Zhaocheng Zhu, Zuobai Zhang, Louis-Pascal Xhonneux, Jian Tang",
        "link": "http://arxiv.org/abs/2106.06935v4",
        "category": [
            "cs.LG"
        ],
        "additionl_info": "NeurIPS 2021"
    },
    "latex_extraction": {
        "content": {
            "section 1": {
                "name": "Introduction",
                "content": "\n\nPredicting the interactions between nodes (a.k.a. link prediction) is a fundamental task in the field of graph machine learning. Given the ubiquitous existence of graphs, such a task has many applications, such as recommender system~\\cite{koren2009matrix}, knowledge graph completion~\\cite{nickel2015review} and drug repurposing~\\cite{ioannidis2020few}.\n\n% traditional methods\nTraditional methods of link prediction usually define different heuristic metrics over the paths between a pair of nodes. For example, Katz index~\\cite{katz1953new} is defined as a weighted count of paths between two nodes. Personalized PageRank~\\cite{page1999pagerank} measures the similarity of two nodes as the random walk probability from one to the other. Graph distance~\\cite{liben2007link} uses the length of the shortest path between two nodes to predict their association.\nThese methods can be directly applied to new graphs, i.e., inductive setting, enjoy good interpretability and scale up to large graphs. However, they are designed based on handcrafted metrics and may not be optimal for link prediction on real-world graphs.\n\nTo address these limitations, some link prediction methods adopt graph neural networks (GNNs)~\\cite{kipf2016variational, schlichtkrull2018modeling, vashishth2020composition} to automatically extract important features from local neighborhoods for link prediction. Thanks to the high expressiveness of GNNs, these methods have shown state-of-the-art performance. However, these methods can only be applied to predict new links on the training graph, i.e. transductive setting, and lack interpretability. While some recent methods~\\cite{zhang2018link, teru2020inductive} extract features from local subgraphs with GNNs and support inductive setting, the scalability of these methods is compromised.\n\nTherefore, we wonder if there exists an approach that enjoys the advantages of both traditional path-based methods and recent approaches based on graph neural networks, i.e., \\textbf{generalization in the inductive setting}, \\textbf{interpretability}, \\textbf{high model capacity} and \\textbf{scalability}.\n\nIn this paper, we propose such a solution. Inspired by traditional path-based methods, our goal is to develop a general and flexible representation learning framework for link prediction based on the paths between two nodes. Specifically, we define the representation of a pair of nodes as the \\emph{generalized sum} of all the path representations between them, where each path representation is defined as the \\emph{generalized product} of the edge representations in the path. Many link prediction methods, such as Katz index~\\cite{katz1953new}, personalized PageRank~\\cite{page1999pagerank}, graph distance~\\cite{liben2007link}, as well as graph theory algorithms like widest path~\\cite{baras2010path} and most reliable path~\\cite{baras2010path}, are special instances of this path formulation with different \\emph{summation} and \\emph{multiplication} operators. Motivated by the polynomial-time algorithm for the shortest path problem~\\cite{bellman1958routing}, we show that such a formulation can be efficiently solved via the generalized Bellman-Ford algorithm~\\cite{baras2010path} under mild conditions and scale up to large graphs.\n\nThe operators in the generalized Bellman-Ford algorithm---\\emph{summation} and \\emph{multiplication}---are handcrafted, which have limited flexibility. Therefore, we further propose the Neural Bellman-Ford Networks (\\method), a graph neural network framework that solves the above path formulation with learned operators in the generalized Bellman-Ford algorithm. Specifically, \\method parameterizes the generalized Bellman-Ford algorithm with three neural components, namely \\textsc{Indicator}, \\textsc{Message} and \\textsc{Aggregate} functions. The \\textsc{Indicator} function initializes a representation on each node, which is taken as the boundary condition of the generalized Bellman-Ford algorithm. The \\textsc{Message} and the \\textsc{Aggregate} functions learn the \\emph{multiplication} and \\emph{summation} operators respectively.\n\nWe show that the \\textsc{Message} function can be defined according to the relational operators in knowledge graph embeddings~\\cite{bordes2013translating, yang2015embedding, trouillon2016complex, kazemi2018simple, sun2019rotate}, e.g., as a translation in Euclidean space induced by the relational operators of TransE~\\cite{bordes2013translating}. The \\textsc{Aggregate} function can be defined as learnable set aggregation functions~\\cite{zaheer2017deep, xu2018powerful, corso2020principal}. With such parameterization, \\method can generalize to the inductive setting, meanwhile achieve one of the lowest time complexity among inductive GNN methods. A comparison of \\method and other GNN frameworks for link prediction is showed in Table~\\ref{tab:comparison}. With other instantiations of \\textsc{Message} and \\textsc{Aggregate} functions, our framework can also recover some existing works on learning logic rules~\\cite{yang2017differentiable, sadeghian2019drum} for link prediction on knowledge graphs (Table~\\ref{tab:semiring_instance}).\n\n% achievement\nOur \\method framework can be applied to several link prediction variants, covering not only single-relational graphs (e.g., homogeneous graphs) but also multi-relational graphs (e.g., knowledge graphs). We empirically evaluate the proposed \\method for link prediction on homogeneous graphs and knowledge graphs in both transductive and inductive settings. Experimental results show that the proposed \\method outperforms existing state-of-the-art methods by a large margin in all settings, with an average relative performance gain of 18\\% on knowledge graph completion (HITS@1) and 22\\% on inductive relation prediction (HITS@10). We also show that the proposed \\method is indeed interpretable by visualizing the top-k relevant paths for link prediction on knowledge graphs. \n\\vspace{-1em}\n\n\n\\footnotetext{We consider the inductive setting where a model can generalize to entirely new graphs without node features.}"
            },
            "section 2": {
                "name": "Related Work",
                "content": "\n\nExisting work on link prediction can be generally classified into 3 main paradigms: path-based methods, embedding methods, and graph neural networks.\n\n\\textbf{Path-based Methods.}\nEarly methods on homogeneous graphs compute the similarity between two nodes based on the weighted count of paths (Katz index~\\cite{katz1953new}), random walk probability (personalized PageRank~\\cite{page1999pagerank}) or the length of the shortest path (graph distance~\\cite{liben2007link}). SimRank~\\cite{jeh2002simrank} uses advanced metrics such as the expected meeting distance on homogeneous graphs, which is extended by PathSim~\\cite{sun2011pathsim} to heterogeneous graphs. On knowledge graphs, Path Ranking~\\cite{lao2010relational, gardner2015efficient} directly uses relational paths as symbolic features for prediction. Rule mining methods, such as NeuralLP~\\cite{yang2017differentiable} and DRUM~\\cite{sadeghian2019drum}, learn probabilistic logical rules to weight different paths. Path representation methods, such as Path-RNN~\\cite{neelakantan2015compositional} and its successors~\\cite{das2016chains, wang2021relational}, encode each path with recurrent neural networks (RNNs), and aggregate paths for prediction. However, these methods need to traverse an exponential number of paths and are limited to very short paths, e.g., $\\leq 3$ edges. To scale up path-based methods, All-Paths~\\cite{toutanova2016compositional} proposes to efficiently aggregate all paths with dynamic programming. However, All-Paths is restricted to bilinear models and has limited model capacity. Another stream of works~\\cite{xiong2017deeppath, das2017go, hildebrandt2020reasoning} learns an agent to collect useful paths for link prediction. While these methods can produce interpretable paths, they suffer from extremely sparse rewards and require careful engineering of the reward function~\\cite{lin2018multi} or the search strategy~\\cite{shen2018m}. Some other works~\\cite{chen2018variational, qu2020rnnlogic} adopt variational inference to learn a path finder and a path reasoner for link prediction.\n\n\\textbf{Embedding Methods.}\nEmbedding methods learn a distributed representation for each node and edge by preserving the edge structure of the graph. Representative methods include DeepWalk~\\cite{perozzi2014deepwalk} and LINE~\\cite{tang2015line} on homogeneous graphs, and TransE~\\cite{bordes2013translating}, DistMult~\\cite{yang2015embedding} and RotatE~\\cite{sun2019rotate} on knowledge graphs. Later works improve embedding methods with new score functions~\\cite{trouillon2016complex, dettmers2018convolutional, kazemi2018simple, sun2019rotate, tang2019orthogonal, zhang2020learning} that capture common semantic patterns of the relations, or search the score function in a general design space~\\cite{zhang2020autosf}. Embedding methods achieve promising results on link prediction, and can be scaled to very large graphs using multiple GPUs~\\cite{zhu2019graphvite}. However, embedding methods do not explicitly encode local subgraphs between node pairs and cannot be applied to the inductive setting.\n\n\\textbf{Graph Neural Networks.}\nGraph neural networks (GNNs)~\\cite{scarselli2008graph, kipf2016semi, velivckovic2018graph, xu2018powerful} are a family of representation learning models that encode topological structures of graphs. For link prediction, the prevalent frameworks~\\cite{kipf2016variational, schlichtkrull2018modeling, davidson2018hyperspherical, vashishth2020composition} adopt an auto-encoder formulation, which uses GNNs to encode node representations, and decodes edges as a function over node pairs. Such frameworks are potentially inductive if the dataset provides node features, but are transductive only when node features are unavailable. Another stream of frameworks, such as SEAL~\\cite{zhang2018link} and GraIL~\\cite{teru2020inductive}, explicitly encodes the subgraph around each node pair for link prediction. While these frameworks are proved to be more powerful than the auto-encoder formulation~\\cite{zhang2020revisiting} and can solve the inductive setting, they require to materialize a subgraph for each link, which is not scalable to large graphs. By contrast, our \\method explicitly captures the paths between two nodes for link prediction, meanwhile achieves a relatively low time complexity (Table~\\ref{tab:comparison}). ID-GNN~\\cite{you2021identity} formalizes link prediction as a conditional node classification task, and augments GNNs with the identity of the source node. While the architecture of \\method shares some spirits with ID-GNN, our model is motivated by the generalized Bellman-Ford algorithm and has theoretical connections with traditional path-based methods. There are also some works trying to scale up GNNs for link prediction by dynamically pruning the set of nodes in message passing~\\cite{xu2019dynamically, han2020xerte}. These methods are complementary to \\method, and may be incorporated into our method to further improve scalability."
            },
            "section 3": {
                "name": "Methodology",
                "content": "\n\nIn this section, we first define a path formulation for link prediction. Our path formulation generalizes several traditional methods, and can be efficiently solved by the generalized Bellman-Ford algorithm. Then we propose Neural Bellman-Ford Networks to learn the path formulation with neural functions.\n\n",
                "subsection 3.1": {
                    "name": "Path Formulation for Link Prediction",
                    "content": "\n\\label{sec:path_formulation}\n\nWe consider the link prediction problem on both knowledge graphs and homogeneous graphs. \\pagebreak[0] A knowledge graph is denoted by $\\gG=(\\gV, \\gE, \\gR)$, where $\\gV$ and $\\gE$ represent the set of entities (nodes) and relations (edges) respectively, and $\\gR$ is the set of relation types. We use $\\gN(u)$ to denote the set of nodes connected to $u$, and $\\gE(u)$ to denote the set of edges ending with node $u$. A homogeneous graph $\\gG=(\\gV, \\gE)$ can be viewed as a special case of knowledge graphs, with only one relation type for all edges. Throughout this paper, we use \\textbf{bold} terms, $\\vw_q(e)$ or $\\vh_q(u, v)$, to denote vector representations, and \\textit{italic} terms, $w_e$ or $w_{uv}$, to denote scalars like the weight of edge $(u, v)$ in homogeneous graphs or triplet $(u, r, v)$ in knowledge graphs. Without loss of generality, we derive our method based on knowledge graphs, while our method can also be applied to homogeneous graphs.\n\n\\textbf{Path Formulation.} Link prediction is aimed at predicting the existence of a query relation $q$ between a head entity $u$ and a tail entity $v$. From a representation learning perspective, this requires to learn a pair representation $\\vh_q(u, v)$, which captures the local subgraph structure between $u$ and $v$ w.r.t. the query relation $q$. In traditional methods, such a local structure is encoded by counting different types of random walks from $u$ to $v$~\\cite{lao2010relational, gardner2015efficient}. Inspired by this construction, we formulate the pair representation as a \\emph{generalized sum} of path representations between $u$ and $v$ with a commutative \\emph{summation} operator $\\oplus$. Each path representation $\\vh_q(P)$ is defined as a \\emph{generalized product} of the edge representations in the path with the \\emph{multiplication} operator $\\otimes$.\n\\begin{align}\n    \\restatableeq{\\link}{&\\vh_q(u, v) = \\vh_q(P_1) \\oplus \\vh_q(P_2) \\oplus ... \\oplus \\vh_q(P_{|\\gP_{uv}|}) \\vert_{P_i \\in \\gP_{uv}} \\triangleq \\bigoplus_{P \\in \\gP_{uv}} \\vh_q(P)}{eqn:link} \\\\\n    \\restatableeq{\\path}{&\\vh_q(P = (e_1, e_2, ..., e_{|P|})) = \\vw_q(e_1) \\otimes \\vw_q(e_2) \\otimes ... \\otimes \\vw_q(e_{|P|}) \\triangleq \\bigotimes_{i=1}^{|P|} \\vw_q(e_i)}{eqn:path}\n\\end{align}\nwhere $\\gP_{uv}$ denotes the set of paths from $u$ to $v$ and $\\vw_q(e_i)$ is the representation of edge $e_i$. Note the \\emph{multiplication} operator $\\otimes$ is not required to be commutative (e.g., matrix multiplication), therefore we define $\\bigotimes$ to compute the product following the exact order. Intuitively, the path formulation can be interpreted as a depth-first-search (DFS) algorithm, where one searches all possible paths from $u$ to $v$, computes their representations (Equation~\\ref{eqn:path}) and aggregates the results (Equation~\\ref{eqn:link}). Such a formulation is capable of modeling several traditional link prediction methods, as well as graph theory algorithms. Formally, Theorem~\\ref{thm:katz_index}-\\ref{thm:reliable_path} state the corresponding path formulations for 3 link prediction methods and 2 graph theory algorithms respectively. See Appendix~\\ref{app:path_formulation} for proofs.\n\n\\vspace{-1em}\n\n\\vspace{-1em}\n\n\\vspace{-1em}\n\n\\vspace{-1em}\n\n\\textbf{Generalized Bellman-Ford Algorithm.}\nWhile the above formulation is able to model important heuristics for link prediction, it is computationally expensive since the number of paths grows exponentially with the path length.\nPrevious works~\\cite{neelakantan2015compositional, das2016chains, wang2021relational} that directly computes the exponential number of paths can only afford a maximal path length of 3.\nA more scalable solution is to use the generalized Bellman-Ford algorithm~\\cite{baras2010path}. Specifically, assuming the operators $\\langle\\oplus, \\otimes\\rangle$ satisfy a semiring system~\\cite{hebisch1998semirings} with \\emph{summation identity} $\\ozero_q$ and \\emph{multiplication identity} $\\oone_q$, we have the following algorithm.\n\\begin{align}\n    \\restatableeq{\\boundary}{\\vh_q^{(0)}(u, v) &\\leftarrow \\mathbbm{1}_q(u = v)}{eqn:boundary} \\\\\n    \\restatableeq{\\iteration}{\\vh_q^{(t)}(u, v) &\\leftarrow \\left(\\bigoplus_{(x, r, v)\\in\\gE(v)} \\vh_q^{(t-1)}(u, x) \\otimes \\vw_q(x, r, v)\\right) \\oplus \\vh_q^{(0)}(u, v)}{eqn:iteration}\n\\end{align}\nwhere $\\mathbbm{1}_q(u = v)$ is the \\textit{indicator} function that outputs $\\oone_q$ if $u = v$ and $\\ozero_q$ otherwise. $\\vw_q(x, r, v)$ is the representation for edge $e = (x, r, v)$ and $r$ is the relation type of the edge. Equation~\\ref{eqn:boundary} is known as the boundary condition, while Equation~\\ref{eqn:iteration} is known as the Bellman-Ford iteration. The high-level idea of the generalized Bellman-Ford algorithm is to \\textbf{compute the pair representation $\\vh_q(u, v)$ for a given entity $u$, a given query relation $q$ and all $v \\in \\gV$ in parallel}, and reduce the total computation by the distributive property of \\emph{multiplication} over \\emph{summation}. Since $u$ and $q$ are fixed in the generalized Bellman-Ford algorithm, we may abbreviate $\\vh_q^{(t)}(u, v)$ as $\\vh^{(t)}_v$ when the context is clear. When $\\oplus = min$ and $\\otimes = +$, it recovers the original Bellman-Ford algorithm for the shortest path problem~\\cite{bellman1958routing}. See Appendix~\\ref{app:bellman_ford} for preliminaries and the proof of the above algorithm.\n\n\\vspace{-1em}\n\n\n"
                },
                "subsection 3.2": {
                    "name": "Neural Bellman-Ford Networks",
                    "content": "\n\\label{sec:nbfn}\n\nWhile the generalized Bellman-Ford algorithm can solve many classical methods (Theorem~\\ref{th:bellman-ford}), these methods instantiate the path formulation with handcrafted operators (Table~\\ref{tab:semiring_instance}), and may not be optimal for link prediction. To improve the capacity of path formulation, we propose a general framework, Neural Bellman-Ford Networks (\\method), to learn the operators in the pair representations.\n\n\n\n\\textbf{Neural Parameterization.} We relax the semiring assumption and parameterize the generalized Bellman-Ford algorithm (Equation~\\ref{eqn:boundary} and \\ref{eqn:iteration}) with 3 neural functions, namely \\textsc{Indicator}, \\textsc{Message} and \\textsc{Aggregate} functions. The \\textsc{Indicator} function replaces the \\emph{indicator} function $\\mathbbm{1}_q(u = v)$. The \\textsc{Message} function replaces the binary \\emph{multiplication} operator $\\otimes$. The \\textsc{Aggregate} function is a permutation invariant function over sets that replaces the n-ary \\emph{summation} operator $\\bigoplus$. Note that one may alternatively define \\textsc{Aggregate} as the commutative binary operator $\\oplus$ and apply it to a sequence of messages. However, this will make the parameterization more complicated.\n\nNow consider the generalized Bellman-Ford algorithm for a given entity $u$ and relation $q$. In this context, we abbreviate $\\vh_q^{(t)}(u, v)$ as $\\vh^{(t)}_v$, i.e., a representation on entity $v$ in the $t$-th iteration. It should be stressed that $\\vh^{(t)}_v$ is still a pair representation, rather than a node representation. By substituting the neural functions into Equation~\\ref{eqn:boundary} and \\ref{eqn:iteration}, we get our Neural Bellman-Ford Networks.\n\\begin{align}\n    \\vh^{(0)}_v &\\leftarrow \\textsc{Indicator}(u, v, q) \\\\\n    \\vh^{(t)}_v &\\leftarrow \\textsc{Aggregate}\\left(\\left\\{\\textsc{Message}\\left(\\vh^{(t-1)}_x, \\vw_q(x, r, v)\\right) \\middle\\vert (x, r, v) \\in \\gE(v)\\right\\} \\cup \\left\\{\\vh^{(0)}_v\\right\\}\\right)\n\\end{align}\n\\method can be interpreted as a novel GNN framework for learning pair representations. Compared to common GNN frameworks~\\cite{kipf2016variational, schlichtkrull2018modeling} that compute the pair representation as two independent node representations $\\vh_q(u)$ and $\\vh_q(v)$, \\method initializes a representation on the source node $u$, and readouts the pair representation on the target node $v$. Intuitively, our framework can be viewed as a source-specific message passing process, where every node learns a representation conditioned on the source node. The pseudo code of \\method is outlined in Algorithm~\\ref{alg:framework}.\n\n\\textbf{Design Space.} Now we discuss some principled designs for \\textsc{Message}, \\textsc{Aggregate} and \\textsc{Indicator} functions by drawing insights from traditional methods. Note the potential design space for \\method is way larger than what is presented here, as one can always borrow \\textsc{Message} and \\textsc{Aggregate} from the arsenal of message-passing GNNs~\\cite{hamilton2017inductive, gilmer2017neural, velivckovic2018graph, xu2018powerful}.\n\nFor the \\textsc{Message} function, traditional methods instantiate it as natural summation, natural multiplication or min over scalars. Therefore, we may use the vectorized version of summation or multiplication. Intuitively, summation of $\\vh^{(t-1)}_x$ and $\\vw_q(x, r, v)$ can be interpreted as a translation of $\\vh^{(t-1)}_x$ by $\\vw_q(x, r, v)$ in the pair representation space, while multiplication corresponds to scaling. Such transformations correspond to the relational operators~\\cite{hamilton2018embedding, ren2020query2box} in knowledge graph embeddings~\\cite{bordes2013translating, yang2015embedding, trouillon2016complex, kazemi2018simple, sun2019rotate}. For example, translation and scaling are the relational operators used in TransE~\\cite{bordes2013translating} and DistMult~\\cite{yang2015embedding} respectively. We also consider the rotation operator in RotatE~\\cite{sun2019rotate}.\n\nThe \\textsc{Aggregate} function is instantiated as natural summation, max or min in traditional methods, which are reminiscent of set aggregation functions~\\cite{zaheer2017deep, xu2018powerful, corso2020principal} used in GNNs. Therefore, we specify the \\textsc{Aggregate} function to be sum, mean, or max, followed by a linear transformation and a non-linear activation. We also consider the principal neighborhood aggregation (PNA) proposed in a recent work~\\cite{corso2020principal}, which jointly learns the types and scales of the aggregation function.\n\nThe \\textsc{Indicator} function is aimed at providing a non-trivial representation for the source node $u$ as the boundary condition. Therefore, we learn a query embedding $\\vq$ for $\\oone_q$ and define \\textsc{Indicator} function as $\\mathbbm{1}(u = v) * \\vq$. Note it is also possible to additionally learn an embedding for $\\ozero_q$. However, we find a single query embedding works better in practice.\n\nThe edge representations are instantiated as transition probabilities or length in traditional methods. We notice that an edge may have different contribution in answering different query relations. Therefore, we parameterize the edge representations as a linear function over the query relation, i.e., $\\vw_q(x, r, v) = \\mW_r \\vq + \\vb_r$. For homogeneous graphs or knowledge graphs with very few relations, we simplify the parameterization to $\\vw_q(x, r, v) = \\vb_r$ to prevent overfitting. Note that one may also parameterize $\\vw_q(x, r, v)$ with learnable entity embeddings $\\vx$ and $\\vv$, but such a parameterization cannot solve the inductive setting. Similar to NeuralLP~\\cite{yang2017differentiable} \\& DRUM~\\cite{sadeghian2019drum}, we use different edge representations for different iterations, which is able to distinguish noncommutative edges in paths, e.g., father's mother v.s. mother's father.\n\n\\textbf{Link Prediction.} We now show how to apply the learned pair representations $\\vh_q(u, v)$ to the link prediction problem. We predict the conditional likelihood of the tail entity $v$ as $p(v | u, q) = \\sigma(f(\\vh_q(u, v)))$, where $\\sigma(\\cdot)$ is the sigmoid function and $f(\\cdot)$ is a feed-forward neural network. The conditional likelihood of the head entity $u$ can be predicted by $p(u|v, q^{-1}) = \\sigma(f(\\vh_{q^{-1}}(v, u)))$ with the same model. Following previous works~\\cite{bordes2013translating, sun2019rotate}, we minimize the negative log-likelihood of positive and negative triplets (Equation~\\ref{eqn:kg_loss}). The negative samples are generated according to Partial Completeness Assumption (PCA)~\\cite{galarraga2013amie}, which corrupts one of the entities in a positive triplet to create a negative sample. For undirected graphs, we symmetrize the representations and define $p_q(u, v) = \\sigma(f(\\vh_q(u, v) + \\vh_q(v, u)))$. Equation~\\ref{eqn:homo_loss} shows the loss for homogeneous graphs.\n\\vspace{-0.5em}\n\\begin{align}\n    &\\gL_{KG} = -\\log p(u, q, v) - \\sum_{i=1}^n \\frac{1}{n}\\log (1 - p(u_i', q, v_i'))\n    \\label{eqn:kg_loss} \\\\\n    &\\gL_{homo} = -\\log p(u, v) -\n    \\sum_{i=1}^n \\frac{1}{n}\\log (1 - p(u_i', v_i')),\n    \\label{eqn:homo_loss}\n\\end{align}\nwhere $n$ is the number of negative samples per positive sample and $(u_i',q,v_i')$ and $(u_i',v_i')$ are the $i$-th negative samples for knowledge graphs and homogeneous graphs, respectively.\n\n\\textbf{Time Complexity.} One advantage of \\method is that it has a relatively low time complexity during inference\\footnote{Although the same analysis can be applied to training on a fixed number of samples, we note it is less instructive since one can trade-off samples for performance, and the trade-off varies from method to method.}.\nConsider a scenario where a model is required to infer the conditional likelihood of all possible triplets $p(v | u, q)$. We group triplets with the same condition $u, q$ together, where each group contains $|\\gV|$ triplets. For each group, we only need to execute Algorithm~\\ref{alg:framework} once to get their predictions. Since a small constant number of iterations $T$ is enough for \\method to converge (Table~\\ref{tab:num_layer}), Algorithm~\\ref{alg:framework} has a time complexity of $O(|\\gE|d + |\\gV|d^2)$, where $d$ is the dimension of representations. Therefore, the amortized time complexity for a single triplet is $O\\left(\\frac{|\\gE|d}{|\\gV|} + d^2\\right)$. For a detailed derivation of time complexity of other GNN frameworks, please refer to Appendix~\\ref{app:complexity}."
                }
            },
            "section 4": {
                "name": "Experiment",
                "content": "\n\n",
                "subsection 4.1": {
                    "name": "Experiment Setup",
                    "content": "\n\\label{sec:exp_setup}\n\nWe evaluate \\method in three settings, knowledge graph completion, homogeneous graph link prediction and inductive relation prediction. The former two are transductive settings, while the last is an inductive setting. For knowledge graphs, we use FB15k-237~\\cite{toutanova2015observed} and WN18RR~\\cite{dettmers2018convolutional}. We use the standard transductive splits~\\cite{toutanova2015observed, dettmers2018convolutional} and inductive splits~\\cite{teru2020inductive} of these datasets. For homogeneous graphs, we use Cora, Citeseer and PubMed~\\cite{sen2008collective}. Following previous works~\\cite{kipf2016variational, davidson2018hyperspherical}, we split the edges into train/valid/test with a ratio of 85:5:10. Statistics of datasets can be found in Appendix~\\ref{app:dataset_stat}. Additional experiments of \\method on OGB~\\cite{hu2020ogb} datasets can be found in Appendix~\\ref{app:ogb}.\n\n\\textbf{Implementation Details.}\nOur implementation generally follows the open source codebases of knowledge graph completion\\footnote{\\url{https://github.com/DeepGraphLearning/KnowledgeGraphEmbedding}. MIT license.\\label{fn:kg_url}} and homogeneous graph link prediction\\footnote{\\url{https://github.com/tkipf/gae}. MIT license.\\label{fn:homo_url}}. For knowledge graphs, we follow \\cite{yang2017differentiable, sadeghian2019drum} and augment each triplet \\edge{u, q, v} with a flipped triplet \\edge{v, q$^{-1}$, u}. For homogeneous graphs, we follow \\cite{kipf2016semi, kipf2016variational} and augment each node $u$ with a self loop \\edge{u, u}. We instantiate \\method with 6 layers, each with 32 hidden units. The feed-forward network $f(\\cdot)$ is set to a 2-layer MLP with 64 hidden units. ReLU is used as the activation function for all hidden layers. We drop out edges that directly connect query node pairs during training to encourage the model to capture longer paths and prevent overfitting. Our model is trained on 4 Tesla V100 GPUs for 20 epochs. We select the models based on their performance on the validation set. See Appendix~\\ref{app:implementation} for more details.\n\n\\textbf{Evaluation.} We follow the filtered ranking protocol~\\cite{bordes2013translating} for knowledge graph completion. For a test triplet \\edge{u, q, v}, we rank it against all negative triplets \\edge{u, q, v'} or \\edge{u', q, v} that do not appear in the knowledge graph. We report mean rank (MR), mean reciprocal rank (MRR) and HITS at N (H@N) for knowledge graph completion. For inductive relation prediction, we follow~\\cite{teru2020inductive} and draw 50 negative triplets for each positive triplet and use the above filtered ranking. We report HITS@10 for inductive relation prediction. For homogeneous graph link prediction, we follow~\\cite{kipf2016variational} and compare the positive edges against the same number of negative edges. We report area under the receiver operating characteristic curve (AUROC) and average precision (AP) for homogeneous graphs.\n\n\\textbf{Baselines.} We compare \\method against path-based methods, embedding methods, and GNNs. These include 11 baselines for knowledge graph completion, 10 baselines for homogeneous graph link prediction and 4 baselines for inductive relation prediction. Note the inductive setting only includes path-based methods and GNNs, since existing embedding methods cannot handle this setting.\n\n"
                },
                "subsection 4.2": {
                    "name": "Main Results",
                    "content": "\n\nTable~\\ref{tab:kg_result} summarizes the results on knowledge graph completion. \\method significantly outperforms existing methods on all metrics and both datasets. \\method achieves an average relative gain of 21\\% in HITS@1 compared to the best path-based method, DRUM~\\cite{sadeghian2019drum}, on two datasets. Since DRUM is a special instance of \\method with natural summation and multiplication operators, this indicates the importance of learning \\textsc{Message} and \\textsc{Aggregate} functions in \\method. \\method also outperforms the best embedding method, LowFER~\\cite{amin2020lowfer}, with an average relative performance gain of 18\\% in HITS@1 on two datasets. Meanwhile, \\method requires much less parameters than embedding methods. \\method only uses 3M parameters on FB15k-237, while TransE needs 30M parameters. See Appendix~\\ref{app:num_param} for details on the number of parameters.\n\n\n\n\n\n\n\nTable~\\ref{tab:homo_result} shows the results on homogeneous graph link prediction. \\method gets the best results on Cora and PubMed, meanwhile achieves competitive results on CiteSeer. Note CiteSeer is extremely sparse (Appendix~\\ref{app:dataset_stat}), which makes it hard to learn good representations with NBFNet. One thing to note here is that unlike other GNN methods, \\method does not use the node features provided by the datasets but is still able to outperform most other methods. We leave how to effectively combine node features and structural representations for link prediction as our future work.\n\nTable~\\ref{tab:inductive_result} summarizes the results on inductive relation prediction. On all inductive splits of two datasets, \\method achieves the best result. \\method outperforms the previous best method, GraIL~\\cite{teru2020inductive}, with an average relative performance gain of 22\\% in HITS@10. Note that GraIL explicitly encodes the local subgraph surrounding each node pair and has a high time complexity (Appendix~\\ref{app:complexity}). Usually, GraIL can at most encode a 2-hop subgraph, while our \\method can efficiently explore longer paths. \n\n"
                },
                "subsection 4.3": {
                    "name": "Ablation Study",
                    "content": "\n\n\\textbf{\\textsc{Message} \\& \\textsc{Aggregate} Functions.} Table~\\ref{tab:msg_agg} shows the results of different \\textsc{Message} and \\textsc{Aggregate} functions. Generally, \\method benefits from advanced embedding methods (DistMult, RotatE > TransE) and aggregation functions (PNA > sum, mean, max). Among simple \\textsc{Aggregate} functions (sum, mean, max), combinations of \\textsc{Message} and \\textsc{Aggregate} functions (TransE \\& max, DistMult \\& sum) that satisfy the semiring assumption\\footnote{Here semiring is discussed under the assumption of linear activation functions. Rigorously, no combination satisfies a semiring if we consider non-linearity in the model.} of the generalized Bellman-Ford algorithm, achieve locally optimal performance. PNA significantly improves over simple counterparts, which highlights the importance of learning more powerful \\textsc{Aggregate} functions.\n\n\\textbf{Number of GNN Layers.} Table~\\ref{tab:num_layer} compares the results of \\method with different number of layers. Although it has been reported that GNNs with deep layers often result in significant performance drop~\\cite{li2018deeper, zhao2019pairnorm}, we observe \\method does not have this issue. The performance increases monotonically with more layers, hitting a saturation after 6 layers. We conjecture the reason is that longer paths have negligible contribution, and paths not longer than 6 are enough for link prediction.\n\n\\textbf{Performance by Relation Category.} We break down the performance of \\method by the categories of query relations: one-to-one, one-to-many, many-to-one and many-to-many\\footnote{The categories are defined same as \\cite{wang2014knowledge}. We compute the average number of tails per head and the average number of heads per tail. The category is \\textit{one} if the average number is smaller than 1.5 and \\textit{many} otherwise.}. Table~\\ref{tab:rel_category} shows the prediction results for each category. It is observed that \\method not only improves on easy one-to-one cases, but also on hard cases where there are multiple true answers for the query.\n\n\\vspace{-1em}\n\n\n"
                },
                "subsection 4.4": {
                    "name": "Path Interpretations of Predictions",
                    "content": "\n\nOne advantage of \\method is that we can interpret its predictions through paths, which may be important for users to understand and debug the model. Intuitively, the interpretations should contain paths that contribute most to the prediction $p(u, q, v)$. Following local interpretation methods~\\cite{baehrens2010explain, zeiler2014visualizing}, we approximate the local landscape of \\method with a linear model over the set of all paths, i.e., 1st-order Taylor polynomial. We define the importance of a path as its weight in the linear model, which can be computed by the partial derivative of the prediction w.r.t.\\ the path. Formally, the top-k path interpretations for $p(u, q, v)$ are defined as\n\\begin{equation}\n    P_1, P_2, ..., P_k = \\topk_{P \\in \\gP_{uv}} \\frac{\\partial{p(u, q, v)}}{\\partial{P}}\n\\end{equation}\nNote this formulation generalizes the definition of logical rules~\\cite{yang2017differentiable, sadeghian2019drum} to non-linear models. While directly computing the importance of all paths is intractable, we approximate them with edge importance. Specifically, the importance of each path is approximated by the sum of the importance of edges in that path, where edge importance is obtained via auto differentiation. Then the top-k path interpretations are equivalent to the top-k longest paths on the edge importance graph, which can be solved by a Bellman-Ford-style beam search. Better approximation is left as a future work.\n\nTable~\\ref{tab:visualization} visualizes path interpretations from FB15k-237 test set. While users may have different insights towards the visualization, here is our understanding. 1) In the first example, \\method learns soft logical entailment, such as $\\emph{impersonate}^{-1} \\land \\emph{nationality} \\implies \\emph{nationality}$ and $\\emph{ethnicity}^{-1} \\land \\emph{distribution} \\implies \\emph{nationality}$. 2) In second example, \\method performs analogical reasoning by leveraging the fact that \\emph{Florence} is similar to \\emph{Rome}. 3) In the last example, \\method extracts longer paths, since there is no obvious connection between \\emph{Pearl Harbor (film)} and \\emph{Japanese language}.\n\n\n"
                }
            },
            "section 5": {
                "name": "Discussion and Conclusion",
                "content": "\n\\label{sec:discussion}\n\n\\textbf{Limitations.} There are a few limitations for \\method. First, the assumption of the generalized Bellman-Ford algorithm requires the operators $\\langle\\oplus, \\otimes\\rangle$ to satisfy a semiring. Due to the non-linear activation functions in neural networks, this assumption does not hold for \\method, and we do not have a theoretical guarantee on the loss incurred by this relaxation. Second, \\method is only verified on simple edge prediction, while there are other link prediction variants, e.g., complex logical queries with conjunctions ($\\land$) and disjunctions ($\\lor$)~\\cite{hamilton2018embedding, ren2020query2box}. In the future, we would like to how \\method approximates the path formulation, as well as apply \\method to other link prediction settings.\n\n\\textbf{Social Impacts.} Link prediction has a wide range of beneficial applications, including recommender systems, knowledge graph completion and drug repurposing. However, there are also some potentially negative impacts. First, \\method may encode the bias present in the training data, which leads to stereotyped predictions when the prediction is applied to a user on a social or e-commerce platform. Second, some harmful network activities could be augmented by powerful link prediction models, e.g., spamming, phishing, and social engineering. We expect future studies will mitigate these issues.% \\section{Conclusion}\n\n\\textbf{Conclusion.} We present a representation learning framework based on paths for link prediction. Our path formulation generalizes several traditional methods, and can be efficiently solved via the generalized Bellman-Ford algorithm. To improve the capacity of the path formulation, we propose \\method, which parameterizes the generalized Bellman-Ford algorithm with learned \\textsc{Indicator}, \\textsc{Message}, \\textsc{Aggregate} functions. Experiments on knowledge graphs and homogeneous graphs show that \\method outperforms a wide range of methods in both transductive and inductive settings."
            },
            "section 6": {
                "name": "Acknowledgements",
                "content": "\n\nWe would like to thank Komal Teru for discussion on inductive relation prediction, Guyue Huang for discussion on fused message passing implementation, and Yao Lu for assistance on large-scale GPU training. We thank Meng Qu, Chence Shi and Minghao Xu for providing feedback on our manuscript.\n\nThis project is supported by the Natural Sciences and Engineering Research Council (NSERC) Discovery Grant, the Canada CIFAR AI Chair Program, collaboration grants between Microsoft Research and Mila, Samsung Electronics Co., Ltd., Amazon Faculty Research Award, Tencent AI Lab Rhino-Bird Gift Fund and a NRC Collaborative R\\&D Project (AI4D-CORE-06). This project was also partially funded by IVADO Fundamental Research Project grant PRF-2019-3583139727. The computation resource of this project is supported by Calcul Qu\\'ebec\\footnote{\\url{https://www.calculquebec.ca/}} and Compute Canada\\footnote{\\url{https://www.computecanada.ca/}}.\n\\bibliographystyle{plain}\n\\bibliography{reference}\n\n\\clearpage\n\\appendix\n\n"
            },
            "section 7": {
                "name": "Path Formulations for Traditional Methods",
                "content": "\n\\label{app:path_formulation}\n\nHere we demonstrate our path formulation is capable of modeling traditional link prediction methods like Katz index~\\cite{katz1953new}, personalized PageRank~\\cite{page1999pagerank} and graph distance~\\cite{liben2007link}, as well as graph theory algorithms like widest path~\\cite{baras2010path} and most reliable path~\\cite{baras2010path}.\n\nRecall the path formulation is defined as\n\\begin{align}\n    \\link \\\\\n    \\path\n\\end{align}\nwhich can be written in the following compact form\n\\begin{equation}\n    \\vh_q(u,v) = \\bigoplus_{P\\in\\gP_{uv}} \\bigotimes_{i=1}^{|P|} \\vw_q(e_i)\n    \\label{eqn:compact}\n\\end{equation}\n\n",
                "subsection 7.1": {
                    "name": "Katz Index",
                    "content": "\nThe Katz index for a pair of nodes $u$, $v$ is defined as a weighted count of paths between $u$ and $v$, penalized by an attenuation factor $\\beta\\in(0,1)$. Formally, it can be written as\n\\begin{equation}\n    \\text{Katz}(u, v)\n    =\\sum_{t=1}^{\\infty} \\beta^t \\ve_u^\\top \\mA^t \\ve_v\n\\end{equation}\nwhere $\\mA$ denotes the adjacency matrix and $\\ve_u$, $\\ve_v$ denote the one-hot vector for nodes $u$, $v$ respectively. The term $\\ve_u^\\top \\mA^t \\ve_v$ counts all paths of length $t$ between $u$, and $v$ and shorter paths are assigned with larger weights.\n\n\\katz*\n\\begin{proof}\nWe show that $\\text{Katz}(u, v)$ can be transformed into a summation over all paths between $u$ and $v$, where each path is represented by a product of damped edge weights in the path.\nMathematically, it can be derived as\n\\begin{align}\n    \\text{Katz}(u, v)\n    &=\\sum_{t=1}^{\\infty} \\beta^t \\sum_{P \\in \\gP_{uv}:|P|=t}\\prod_{e \\in P} w_{e}\\\\\n    &=\\sum_{P \\in \\gP_{uv}}\\prod_{e \\in P} \\beta w_{e}\n\\end{align}\nTherefore, the Katz index can be viewed as a path formulation with the \\emph{summation} operator $+$, the \\emph{multiplication} operator $\\times$ and the edge representations $\\beta w_e$.\n\\end{proof}\n\n"
                },
                "subsection 7.2": {
                    "name": "Personalized PageRank",
                    "content": "\nThe personalized PageRank (PPR) for $u$ computes the stationary distribution over nodes generated by an infinite random walker, where the walker moves to a neighbor node with probability $\\alpha$ and returns to the source node $u$ with probability $1-\\alpha$ at each step. The probability of a node $v$ from a source node $u$ has the following closed-form solution~\\cite{jeh2003scaling}\n\\begin{equation}\n    \\text{PPR}(u, v)\n    =(1-\\alpha)\\sum_{t=1}^{\\infty} \\alpha^t \\ve_u^\\top (\\mD^{-1}\\mA)^t \\ve_v\n\\end{equation}\nwhere $\\mD$ is the degree matrix and $\\mD^{-1}\\mA$ is the (random walk) normalized adjacency matrix.\nNote that $\\ve_u^\\top (\\mD^{-1}\\mA)^t \\ve_v$ computes the probability of $t$-step random walks from $u$ to $v$.\n\n\\pagerank*\n\\begin{proof}\nWe omit the coefficient $1-\\alpha$, since it is always positive and has no effect on the ranking of different node pairs.\nThen we have \n\\begin{align}\n    \\text{PPR}(u, v)\n    &\\propto\\sum_{t=1}^{\\infty} \\alpha^t \\sum_{P \\in \\gP_{uv}:|P|=t}\\prod_{(a,b) \\in P} \\frac{w_{ab}}{\\sum_{b'\\in\\gN(a)}w_{ab'}} \\\\\n    &=\\sum_{P \\in \\gP_{uv}}\\prod_{(a,b) \\in P} \\frac{\\alpha w_{ab}}{\\sum_{b'\\in\\gN(a)}w_{ab'}}\n\\end{align}\nwhere the \\emph{summation} operator is $+$, the \\emph{multiplication} operator is $\\times$ and edge representations are random walk probabilities scaled by $\\alpha$.\n\\end{proof}\n\n"
                },
                "subsection 7.3": {
                    "name": "Graph Distance",
                    "content": "\nGraph distance (GD) is defined as the minimum length of all paths between $u$ and $v$.\n\n\\distance*\n\\begin{proof}\nSince the length of a path is the sum of edge lengths in the path, we have\n\\begin{equation}\n    \\text{GD}(u, v) = \\min_{P \\in \\gP_{uv}} \\sum_{e \\in P} w_e\n    \\label{eqn:shortest_path}\n\\end{equation}\nHere the \\emph{summation} operator is $\\min$, the \\emph{multiplication} operator is $+$ and the edge representations are the lengths of edges.\n\\end{proof}\n\n"
                },
                "subsection 7.4": {
                    "name": "Widest Path",
                    "content": "\nThe widest path (WP), also known as the maximum capacity path, is aimed at finding a path between two given nodes, such that the path maximizes the minimum edge weight in the path.\n\n\\widest*\n\\begin{proof}\nGiven two nodes $u$ and $v$, we can write the widest path as\n\\begin{align}\n    \\text{WP}(u, v) =\\max_{P \\in \\gP_{uv}} \\min_{e \\in P} w_e\n\\end{align}\nHere the \\emph{summation} operator is $\\max$, the \\emph{multiplication} operator is $\\min$ and the edge representations are plain edge weights.\n\\end{proof}\n\n"
                },
                "subsection 7.5": {
                    "name": "Most Reliable Path",
                    "content": "\nFor a graph with non-negative edge probabilities, the most reliable path (MRP) is the path with maximal probability from a start node to an end node. This is also known as Viterbi algorithm~\\cite{viterbi1967error} used in the maximum a posterior (MAP) inference of hidden Markov models (HMM).\n\n\\reliable*\n\\begin{proof}\nFor a start node $u$ and an end node $v$, the probaility of their most reliable path is \n\\begin{align}\n    \\text{MRP}(u, v)\n    =\\max_{P \\in \\gP_{uv}} \\prod_{e \\in P} w_e\n\\end{align}\nHere the \\emph{summation} operator is $\\max$, the \\emph{multiplication} operator is $\\times$ and the edge representations are edge probabilities.\n\\end{proof}\n\n"
                }
            },
            "section 8": {
                "name": "Generalized Bellman-Ford Algorithm",
                "content": "\n\\label{app:bellman_ford}\n\nFirst, we prove that the path formulation can be efficiently solved by the generalized Bellman-Ford algorithm when the operators $\\langle\\oplus, \\otimes\\rangle$ satisfy a semiring.\nThen, we show that traditional methods satisfy the semiring assumption and therefore can be solved by the generalized Bellman-Ford algorithm.\n\n",
                "subsection 8.1": {
                    "name": "Preliminaries on Semirings",
                    "content": "\n\nSemirings are algebraic structures with two operators, \\emph{summation} $\\oplus$ and \\emph{multiplication} $\\otimes$, that share similar properties with the natural summation and the natural multiplication defined on integers. Specifically, $\\oplus$ should be commutative, associative and have an identity element $\\ozero$. $\\otimes$ should be associative and have an identity element $\\oone$. Mathematically, the \\emph{summation} $\\oplus$ satisfies\n\\begin{itemize}\n    \\setlength{\\parskip}{0pt}\n    \\setlength{\\itemsep}{0pt plus 1pt}\n    \\item \\textbf{Commutative Property.} $a \\oplus b = b \\oplus a$\n    \\item \\textbf{Associative Property.} $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$\n    \\item \\textbf{Identity Element.} $a \\oplus \\ozero = a$\n\\end{itemize}\nThe \\emph{multiplication} $\\otimes$ satisfies\n\\begin{itemize}\n    \\setlength{\\parskip}{0pt}\n    \\setlength{\\itemsep}{0pt plus 1pt}\n    \\item \\textbf{Associative Property.} $(a \\otimes b) \\otimes c = a \\otimes (b \\otimes c)$\n    \\item \\textbf{Absorption Property.} $a \\otimes \\ozero = \\ozero \\otimes a = \\ozero$\n    \\item \\textbf{Identity Element.} $a \\otimes \\oone = \\oone \\otimes a = a$\n\\end{itemize}\nAdditionally, $\\otimes$ should be distributive over $\\oplus$.\n\\begin{itemize}\n    \\setlength{\\parskip}{0pt}\n    \\setlength{\\itemsep}{0pt plus 1pt}\n    \\item \\textbf{Distributive Property (Left).} $a \\otimes (b \\oplus c) = (a \\otimes b) \\oplus (a \\otimes c)$\n    \\item \\textbf{Distributive Property (Right).} $(b \\oplus c) \\otimes a = (b \\otimes a) \\oplus (c \\otimes a)$\n\\end{itemize}\nNote semirings differ from natural arithmetic operators in two aspects. First, the \\emph{summation} operator $\\oplus$ does not need to be invertible, e.g., min or max. Second, the \\emph{multiplication} operator $\\otimes$ does not need to be commutative nor invertible, e.g., matrix multiplication.\n\n"
                },
                "subsection 8.2": {
                    "name": "Generalized Bellman-Ford Algorithm for Path Formulation",
                    "content": "\nNow we prove that the generalized Bellman-Ford algorithm computes the path formulation when the operators $\\langle\\oplus, \\otimes\\rangle$ satisfy a semiring. It should be stressed that the generalized Bellman-Ford algorithm for path problems has been proved in~\\cite{baras2010path}, and not a contribution of this paper. Here we apply the proof to our proposed path formulation.\n\nThe generalized Bellman-Ford algorithm computes the following iterations for all $v \\in \\gV$\n\\begin{align}\n    \\boundary \\\\\n    \\iteration\n\\end{align}\n\\begin{lemma}\\label{lem:induction}\nAfter $t$ Bellman-Ford iterations, the intermediate representation $\\vh^{(t)}_q(u,v)$ aggregates all path representations within a length of $t$ edges for all $v$. That is\n\\begin{equation}\n    \\vh_q^{(t)}(u,v) = \\bigoplus_{P\\in\\gP_{uv}:|P|\\le t} \\bigotimes_{i=1}^{|P|} \\vw_q(e_i)\n\\end{equation}\n\\end{lemma}\n\\begin{proof}\nWe prove Lemma~\\ref{lem:induction} by induction. For the base case $t=0$, there is a single path of length $0$ from $u$ to itself and no path to other nodes. Due to the product definition of path representations, a path of length $0$ is equal to the \\emph{multiplication} identity $\\oone_q$. Similarly, a summation of no path is equal to the \\emph{summation} identity $\\ozero_q$. Therefore, we have $\\vh_q^{(0)}(u, v) = \\mathbbm{1}_q(u = v) = \\bigoplus_{P\\in\\gP_{uv}:|P|=0} \\bigotimes_{i=1}^{|P|} \\vw_q(e_i)$.\n\nFor the inductive case $t > 0$, we consider the second-to-last node $x$ in each path if the path has a length larger than $0$. To avoid overuse of brackets, we use the convention that $\\otimes$ and $\\bigotimes$ have a higher priority than $\\oplus$ and $\\bigoplus$. \n\\begin{align}\n    \\vh^{(t)}_q(u,v) \n    &= \\left(\\bigoplus_{(x, r, v) \\in \\gE(v)}\\vh_q^{(t-1)}(u,x) \\otimes \\vw_q(x, r, v)\\right) \\oplus \\vh^{(0)}_q(u,v)\\\\\n    &= \\left[\\bigoplus_{(x, r, v) \\in \\gE(v)}\\left(\\bigoplus_{P\\in\\gP_{ux}:|P|\\le t-1} \\bigotimes_{i=1}^{|P|} \\vw_q(e_i)\\right) \\otimes \\vw_q(x, r, v)\\right] \\oplus \\vh^{(0)}_q(u,v)\\label{eq:substitution}\\\\\n    &=\n    \\left\\{\\bigoplus_{(x, r, v) \\in \\gE(v)}\\left[\\bigoplus_{P\\in\\gP_{ux}:|P|\\le t-1}\\left(\\bigotimes_{i=1}^{|P|} \\vw_q(e_i)\\right) \\otimes \\vw_q(x, r, v)\\right]\\right\\} \\oplus \\vh^{(0)}_q(u,v)\\label{eq:distributive}\\\\\n    &= \\left(\\bigoplus_{P\\in\\gP_{uv}:1\\le|P|\\le t} \\bigotimes_{i=1}^{|P|} \\vw_q(e_i)\\right) \\oplus \\left( \\bigoplus_{P\\in\\gP_{uv}:|P|=0} \\bigotimes_{i=1}^{|P|} \\vw_q(e_i)\\right)\\label{eq:associative}\\\\\n    &= \\bigoplus_{P\\in\\gP_{uv}:|P|\\le t} \\bigotimes_{i=1}^{|P|} \\vw_q(e_i),\n\\end{align}\nwhere Equation~\\ref{eq:substitution} substitutes the inductive assumption for $\\vh_q^{(t-1)}(u, x)$, Equation~\\ref{eq:distributive} uses the distributive property of $\\otimes$ over $\\oplus$.\n\\end{proof}\n\nBy comparing Lemma~\\ref{lem:induction} and Equation~\\ref{eqn:compact}, we can see the intermediate representation converges to our path formulation $\\lim_{t\\rightarrow \\infty} \\vh_q^{(t)}(u, v) = \\vh_q(u, v)$. More specifically, at most $|\\gV|$ iterations are required if we only consider simple paths, i.e., paths without repeating nodes. In practice, for link prediction we find it only takes a very small number of iterations (e.g., $T = 6$) to converge, since long paths make negligible contribution to the task.\n\n"
                },
                "subsection 8.3": {
                    "name": "Traditional Methods",
                    "content": "\n\n\\bellman*\n\\begin{proof}\nGiven that the generalized Bellman-Ford algorithm solves the path formulation when $\\langle\\oplus, \\otimes\\rangle$ satisfy a semiring, we only need to show that the operators of the path formulations for traditional methods satisfy semiring structures.\n\nKatz index (Theorem~\\ref{thm:katz_index}) and personalized PageRank (Theorem~\\ref{thm:pagerank}) use the natural summation $+$ and the natural multiplication $\\times$, which obviously satisfy a semiring.\n\nGraph distance (Theorem~\\ref{thm:proximity}) uses $\\min$ for \\emph{summation} and $+$ for \\emph{multiplication}. The corresponding identities are $\\ozero = +\\infty$ and $\\oone = 0$. It is obvious that $+$ satisfies the associative property and has identity element $0$.\n\\begin{itemize}\n    \\setlength{\\parskip}{0pt}\n    \\setlength{\\itemsep}{0pt plus 1pt}\n    \\item \\textbf{Commutative Property.} $\\min(a, b) = \\min(b, a)$\n    \\item \\textbf{Associative Property.} $\\min(\\min(a, b), c) = \\min(a, \\min(b, c))$\n    \\item \\textbf{Identity Element.} $\\min(a, +\\infty) = a$\n    \\item \\textbf{Absorption Property.} $a + \\infty = \\infty + a = +\\infty$\n    \\item \\textbf{Distributive Property (Left).} $a + \\min(b, c) = \\min(a + b, a + c)$\n    \\item \\textbf{Distributive Property (Right).} $\\min(b, c) + a = \\min(b + a, c + a)$\n\\end{itemize}\n\nWidest path (Theorem~\\ref{thm:widest_path}) uses $\\max$ for \\emph{summation} and $\\min$ for \\emph{multiplication}. The corresponding identities are $\\ozero = -\\infty$ and $\\oone = +\\infty$. We have\n\\begin{itemize}\n    \\setlength{\\parskip}{0pt}\n    \\setlength{\\itemsep}{0pt plus 1pt}\n    \\item \\textbf{Commutative Property.} $\\max(a, b) = \\max(b, a)$\n    \\item \\textbf{Associative Property.} $\\max(\\max(a, b), c) = \\max(a, \\max(b, c))$\n    \\item \\textbf{Identity Element.} $\\max(a, -\\infty) = a$\n    \\item \\textbf{Associative Property.} $\\min(\\min(a, b), c) = \\min(a, \\min(b, c))$\n    \\item \\textbf{Absorption Property.} $\\min(a, -\\infty) = \\min(-\\infty, a) = -\\infty$\n    \\item \\textbf{Identity Element.} $\\min(a, +\\infty) = \\min(+\\infty, a) = a$\n    \\item \\textbf{Distributive Property (Left).} $\\min(a, \\max(b, c)) = \\max(\\min(a, b), \\min(a, c))$\n    \\item \\textbf{Distributive Property (Right).} $\\min(\\max(b, c), a) = \\max(\\min(b, a), \\min(c, a))$\n\\end{itemize}\nwhere the distributive property can be proved by enumerating all possible orders of $a$, $b$ and $c$.\n\nMost reliable path (Theorem~\\ref{thm:reliable_path}) uses $\\max$ for \\emph{summation} and $\\times$ for \\emph{multiplication}.  The corresponding identities are $\\ozero = 0$ and $\\oone = 1$, since all path representations are probabilities in $[0, 1]$. It is obvious that $\\times$ satisfies the associative property, the absorption property and has identity element $0$.\n\\begin{itemize}\n    \\setlength{\\parskip}{0pt}\n    \\setlength{\\itemsep}{0pt plus 1pt}\n    \\item \\textbf{Commutative Property.} $\\max(a, b) = \\max(b, a)$\n    \\item \\textbf{Associative Property.} $\\max(\\max(a, b), c) = \\max(a, \\max(b, c))$\n    \\item \\textbf{Identity Element.} $\\max(a, 0) = a$\n    \\item \\textbf{Distributive Property (Left).} $a \\times \\max(b, c) = \\max(a \\times b, a \\times c)$\n    \\item \\textbf{Distributive Property (Right).} $\\max(b, c) \\times a = \\max(b \\times a, c \\times a)$\n\\end{itemize}\nwhere the identity element and the distributive property hold for non-negative elements.\n\\end{proof}\n\n"
                }
            },
            "section 9": {
                "name": "Time Complexity of GNN Frameworks",
                "content": "\n\\label{app:complexity}\n\nHere we prove the time complexity for \\method and other GNN frameworks.\n\n",
                "subsection 9.1": {
                    "name": "\\method",
                    "content": "\n\n\\begin{lemma}\n\\label{lem:bellmanford}\nThe time complexity of one \\method run (Algorithm~\\ref{alg:framework}) is $O(T(|\\gE|d + |\\gV|d^2))$.\n\\end{lemma}\n\\begin{proof}\nWe break the time complexity by \\textsc{Indicator}, \\textsc{Message} and \\textsc{Aggregate} functions.\n\n\\textsc{Indicator} is called $|\\gV|$ times, and a single call to \\textsc{Indicator} takes $O(d)$ time. \\textsc{Message} is called $T(|\\gE| + |\\gV|)$ times, and a single call to \\textsc{Message}, i.e., a relation operator, takes $O(d)$ time. \\textsc{Aggregate} is called $T|\\gV|$ times over a total of $T|\\gE|$ messages with $d$ dimensions. Each call to \\textsc{Aggregate} additionally takes $O(d^2)$ time due to the linear transformations in the function.\n\nTherefore, the total complexity is summed to $O(T(|\\gE|d + |\\gV|d^2))$.\n\\end{proof}\n\nIn practice, we find a small constant $T$ works well for link prediction, and Lemma~\\ref{lem:bellmanford} can be reduced to $O(|\\gE|d + |\\gV|d^2)$ time.\n\nNow consider applying \\method to infer the likelihood of all possible triplets. Without loss of generality, assume we want to predict the tail entity for each head entity and relation $p(v | u, q)$. We group triplets with the same condition $u, q$ together, where each group contains $|\\gV|$ triplets. For triplets in a group, we only need to execute Algorithm~\\ref{alg:framework} once to get their predictions. Therefore, the amortized time for a single triplet is $O\\left(\\frac{|\\gE|d}{|\\gV|} + d^2\\right)$.\n\n"
                },
                "subsection 9.2": {
                    "name": "VGAE / RGCN",
                    "content": "\nRGCN is a message-passing GNN applied to multi-relational graphs, with the message function being a per-relation linear transformation. VGAE can be viewed as a special case of RGCN applied to single-relational graphs. The time complexity of RGCN is similar to Lemma~\\ref{lem:bellmanford}, except that each call to the message function takes $O(d^2)$ time due to the linear transformation. Therefore, the total complexity is $O(T(|\\gE|d^2 + |\\gV|d^2))$, where $T$ refers to the number of layers in RGCN. Since $|\\gV| \\leq |\\gE|$, the complexity is reduced to $O(T|\\gE|d^2)$\\footnote{By moving the linear transformations from the message function to the aggregation function, one can also get an implementation of RGCN with $O(T|\\gV||\\gR|d^2)$ time, which is better for dense graphs but worse for sparse graphs. For knowledge graph datasets used in this paper, the above $O(T|\\gE|d^2)$ implementation is better.}. In practice, $T$ is a small constant and we get $O(|\\gE|d^2)$ complexity.\n\nWhile directly executing RGCN once for each triplet is costly, a smart way to apply RGCN for inference is to first compute all node representations, and then perform link prediction with the node representations. The first step runs RGCN once for $|\\gV|^2|\\gR|$ triplets, while the second step takes $O(d)$ time. Therefore, the amortized time for a single triplet is $O\\left(\\frac{|\\gE|d^2}{|\\gV|^2|\\gR|} + d\\right)$. For large graphs and reasonable choices of $d$, we have $|\\gE|d \\leq |\\gV|^2|\\gR|$ and the amortized time can be reduced to $O(d)$.\n\n"
                },
                "subsection 9.3": {
                    "name": "NeuralLP / DRUM",
                    "content": "\nDRUM can be viewed as a special case of \\method with \\textsc{Message} being Hadamard product and \\textsc{Aggregate} being natural summation. NeuralLP is a special case of DRUM where the dimension $d$ equals to 1. Since there is no linear transformation in their \\textsc{Aggregate} functions, the amortized time complexity for the message passing part is $O\\left(\\frac{T|\\gE|d}{|\\gV|}\\right)$. Both DRUM and NeuralLP additionally use an LSTM to learn the edge weights for each layer, which additionally costs $O(Td^2)$ time for $T$ layers. $T$ is small and can be ignored like in other methods. Therefore, the amortized time of two parts is summed to $O\\left(\\frac{|\\gE|d}{|\\gV|} + d^2\\right)$.\n\n"
                },
                "subsection 9.4": {
                    "name": "SEAL / GraIL",
                    "content": "\nGraIL first extracts a local subgraph surrounding the link, and then applies RGCN to the local subgraph. SEAL can be viewed as a special case of GraIL applied to single-relational graphs. Therefore, their amortized time is the same as that of one RGCN run, which is $O(|\\gE|d^2)$.\n\nNote that one may still run GraIL on large graphs by restricting the local subgraphs to be very small, e.g., within 1-hop neighborhood of the query entities. However, this will severely harm the performance of link prediction. Moreover, most real-world graphs are small-world networks, and a moderate radius can easily cover a non-trivial number of nodes and edges, which costs a lot of time for GraIL.\n\n"
                }
            },
            "section 10": {
                "name": "Number of Parameters",
                "content": "\n\\label{app:num_param}\n\n\n\nOne advantage of \\method is that it requires much less parameters than embedding methods. For example, on FB15k-237, \\method requires 3M parameters while TransE requires 30M parameters. Table~\\ref{tab:num_param} shows a break down of number of parameters in \\method. Generally, the number of parameters in \\method scales linearly w.r.t. the number of relations, regardless the number of entities in the graph, which makes \\method more parameter-efficient for large graphs.\n\n"
            },
            "section 11": {
                "name": "Statistics of Datasets",
                "content": "\n\\label{app:dataset_stat}\n\nDataset statistics of two transductive settings, i.e., knowledge graph completion and homogeneous graph link prediction, are summarized in Table~\\ref{tab:kg_statistics} and \\ref{tab:homo_statistics}. Dataset statistics of inductive relation prediction is summarized in Table~\\ref{tab:inductive_statistics}.\n\nWe use the standard transductive splits~\\cite{toutanova2015observed, dettmers2018convolutional} and inductive splits~\\cite{teru2020inductive} for knowledge graphs. For homogeneous graphs, we follow previous works~\\cite{kipf2016variational, davidson2018hyperspherical} and randomly split the edges into train/validation/test sets with a ratio of 85:5:10. All the homogeneous graphs used in this paper are undirected. Note that for inductive relation prediction, the original paper~\\cite{teru2020inductive} actually uses a \\emph{transductive valid set} that shares the same set of fact triplets as the training set for hyperparameter tuning. The \\emph{inductive test set} contains entities, query triplets and fact triplets that never appear in the training set. The same data split is adopted in this paper for a fair comparison.\n\n\n\n\n\n\n"
            },
            "section 12": {
                "name": "Implementation Details",
                "content": "\n\\label{app:implementation}\n\n\n\nOur implementation generally follows the open source codebases of knowledge graph completion\\footnote{\\url{https://github.com/DeepGraphLearning/KnowledgeGraphEmbedding}. MIT license.} and homogeneous graph link prediction\\footnote{\\url{https://github.com/tkipf/gae}. MIT license.}. Table~\\ref{tab:hyperparameter} lists the hyperparameter configurations for different datasets. Table~\\ref{tab:wall_time} shows the wall time of training and inference on different datasets.\n\n\\textbf{Data Augmentation.} For knowledge graphs, we follow previous works~\\cite{yang2017differentiable, sadeghian2019drum} and augment each triplet \\edge{u, q, v} with a flipped triplet \\edge{v, q$^{-1}$, u}. For homogeneous graphs, we follow previous works~\\cite{kipf2016semi, kipf2016variational} and augment each node $u$ with a self loop \\edge{u, u}.\n\n\\textbf{Architecture Details.} We apply Layer Normalization~\\cite{ba2016layer} and short cut connection to accelerate the training of \\method. Layer Normalization is applied after each \\textsc{Aggregate} function. The feed-forward network $f(\\cdot)$ is instantiated as a MLP. ReLU is used as the activation function for all hidden layers. For undirected graphs, we symmetrize the pair representation by taking the sum of $\\vh_q(u, v)$ and $\\vh_q(v, u)$.\n\n\\textbf{Training Details.} We train \\method on 4 Tesla V100 GPUs with standard data parallelism. During training, we drop out edges that directly connect query node pairs to encourage the model to capture longer paths and prevent overfitting. We select the best checkpoint for each model based on its performance on the validation set. The selection criteria is MRR for knowledge graphs and AUROC for homogeneous graphs.\n\n\\textbf{Fused Message Passing.} To reduce memory footprint and better utilize GPU hardware, we follow the efficient implementation of GNNs~\\cite{huang2020ge} and implement customized PyTorch operators that combines \\textsc{Message} and \\textsc{Aggregate} functions into a single operation, without creating all messages explicitly. This reduces the memory complexity of NBFNet from $O(|\\gE|d)$ to $O(|\\gV|d)$.\n\n\n\n"
            },
            "section 13": {
                "name": "Experimental Results on OGB Datasets",
                "content": "\n\\label{app:ogb}\n\nTo demonstrate the effectiveness of \\method on large-scale graphs, we additionally evaluate our method on two knowledge graph datasets from OGB~\\cite{hu2020ogb}, ogbl-biokg and WikiKG90M. We follow the standard evaluation protocol of OGB link property prediction, and compute the mean reciprocoal rank (MRR) of the true entity against 1,000 negative entities.\n\n",
                "subsection 13.1": {
                    "name": "Results on ogbl-biokg",
                    "content": "\n\nOgbl-biokg is a large biomedical knowledge graph that contains 93,773 entities, 51 relations and 5,088,434 triplets. We compare \\method with 6 embedding methods on this dataset. Note by the time of this work, only embedding methods are available for such large-scale datasets. Table~\\ref{tab:ogbl-biokg} shows the results on ogbl-biokg. NBFNet achieves the best result compared to all methods reported on the official leaderboard\\footnote{\\url{https://ogb.stanford.edu/docs/leader_linkprop/\\#ogbl-biokg}} with much fewer parameters. Note the previous best model AutoSF is based on architecture search and requires more computation resource than NBFNet for training.\n\n\n\n"
                },
                "subsection 13.2": {
                    "name": "Results on WikiKG90M",
                    "content": "\n\nWikiKG90M is an extremely large dataset used in OGB large-scale challenge~\\cite{hu2021ogb}, hold at KDD Cup 2021. It is a general-purpose knowledge graph containing 87,143,637 entities, 1,315 relations and 504,220,369 triplets.\n\nTo apply \\method to such a large scale, we use a bidirectional breath-first-search (BFS) algorithm to sample a local subgraph for each query. Given a query, we generate a $k$-hop neighborhood for each of the head entity and the candidate tail entities, based on a BFS search. The union of all generated neighborhoods is then collected as the sampled graph. With this sampling algorithm, any path within a length of $2k$ between the head entity and any tail candidate is guaranteed to present in the sampled graph. See Figure~\\ref{fig:bfs_sampling} for illustration. While a standard single BFS algorithm computing the $2k$-hop neighborhood of the head entity has the same guarantee, a bidirectional BFS algorithm significantly reduces the number of nodes and edges in the sampled graph.\n\n\n\nWe additionally downsample the neighbors when expanding the neighbors of an entity, to tackle entities with large degrees. For each entity visited during the BFS algorithm, we downsample its outgoing neighbors and incoming neighbors to $m$ entities respectively.\n\nTable~\\ref{tab:ogb_lsc} shows the results of NBFNet on WikiKG90M validation set. Our best single model uses $k=2$ and $m=100$. While the validation set requires to rank the true entity against 1,000 negative entities, in practice it is not mandatory to draw 1,000 negative samples for each positive sample during training. We find that reducing the negative samples from 1,000 to 20 and increasing the batch size from 4 to 64 provides a better result, although it creates a distribution shift between sampled graphs in training and validation. We leave further research of such distribution shift as a future work.\n\n\n\n\n\n"
                }
            },
            "section 14": {
                "name": "Ablation Study",
                "content": "\n\\label{app:ablation}\n\nTable~\\ref{tab:msg_agg_full} shows the full results of different \\textsc{Message} and \\textsc{Aggregate} functions. Table~\\ref{tab:num_layer_full} shows the full results of \\method with different number of layers.\n"
            }
        },
        "tables": {
            "tab:comparison": "\\begin{table}[!h]\n    \\centering\n    \\caption{Comparison of GNN frameworks for link prediction. The time complexity refers to the \\emph{amortized time} for predicting a single edge or triplet. $|\\gV|$ is the number of nodes, $|\\gE|$ is the number of edges, and $d$ is the dimension of representations. The wall time is measured on FB15k-237 test set with 40 CPU cores and 4 GPUs. We estimate the wall time of GraIL based on a downsampled test set.}\n    \\label{tab:comparison}\n    \\begin{adjustbox}{max width=\\textwidth}\n    \\begin{tabular}{lccccc}\n         \\toprule\n         \\bf{Method} & \\bf{Inductive\\footnotemark} & \\bf{Interpretable} & \\bf{Learned Representation}  & \\bf{Time Complexity} & \\bf{Wall Time} \\\\\n         \\midrule\n         VGAE~\\cite{kipf2016variational} / &  &  & \\multirow{2}{*}{\\checkmark} & \\multirow{2}{*}{$O(d)$} & \\multirow{2}{*}{18 secs} \\\\\n         RGCN~\\cite{schlichtkrull2018modeling} \\\\\n         NeuralLP~\\cite{yang2017differentiable} / & \\multirow{2}{*}{\\checkmark} & \\multirow{2}{*}{\\checkmark} &  & \\multirow{2}{*}{$O\\left(\\frac{|\\gE|d}{|\\gV|} + d^2\\right)$} & \\multirow{2}{*}{2.1 mins} \\\\\n         DRUM~\\cite{sadeghian2019drum} \\\\\n         SEAL~\\cite{zhang2018link} / & \\multirow{2}{*}{\\checkmark} & & \\multirow{2}{*}{\\checkmark} & \\multirow{2}{*}{$O(|\\gE|d^2)$} & \\multirow{2}{*}{$\\approx$1 month} \\\\\n         GraIL~\\cite{teru2020inductive} \\\\\n         \\midrule\n         \\method & \\checkmark & \\checkmark & \\checkmark & $O\\left(\\frac{|\\gE|d}{|\\gV|} + d^2\\right)$ & 4.0 mins \\\\\n         \\bottomrule\n    \\end{tabular}\n    \\end{adjustbox}\n\\end{table}",
            "thm:katz_index": "\\begin{restatable}{thm}{katz}\n    Katz index is a path formulation with $\\oplus = +$, $\\otimes = \\times$ and $\\vw_q(e) = \\beta w_e$.\n    \\label{thm:katz_index}\n\\end{restatable}",
            "thm:pagerank": "\\begin{restatable}{thm}{pagerank}\n    Personalized PageRank is a path formulation with $\\oplus = +$, $\\otimes = \\times$ and $\\vw_q(e) = \\alpha w_{uv} / \\sum\\nolimits_{v'\\in\\gN(u)}w_{uv'}$.\n    \\label{thm:pagerank}\n\\end{restatable}",
            "thm:proximity": "\\begin{restatable}{thm}{distance}\n    Graph distance is a path formulation with $\\oplus = \\min$, $\\otimes = +$ and $\\vw_q(e) = w_e$.\n    \\label{thm:proximity}\n\\end{restatable}",
            "thm:widest_path": "\\begin{restatable}{thm}{widest}\n    Widest path is a path formulation with $\\oplus = \\max$, $\\otimes = \\min$ and $\\vw_q(e) = w_e$.\n    \\label{thm:widest_path}\n\\end{restatable}",
            "thm:reliable_path": "\\begin{restatable}{thm}{reliable}\n    Most reliable path is a path formulation with $\\oplus = \\max$, $\\otimes = \\times$ and $\\vw_q(e) = w_e$.\n    \\label{thm:reliable_path}\n\\end{restatable}",
            "th:bellman-ford": "\\begin{restatable}{thm}{bellman}\n    Katz index, personalized PageRank, graph distance, widest path and most reliable path can be solved via the generalized Bellman-Ford algorithm.\n    \\label{th:bellman-ford}\n\\end{restatable}",
            "tab:semiring_instance": "\\begin{table}[!h]\n    \\centering\n    \\caption{Comparison of operators in \\method and other methods from the view of path formulation.}\n    \\label{tab:semiring_instance}\n    \\begin{adjustbox}{max width=\\textwidth}\n        \\begin{tabular}{llcccc}\n            \\toprule\n            \\multirow{2}{*}{\\bf{Class}} & \\multirow{2}{*}{\\bf{Method}} & \\bf{\\textsc{Message}} & \\bf{\\textsc{Aggregate}} & \\bf{\\textsc{Indicator}} & \\bf{Edge Representation} \\\\\n            & & $\\vw_q(e_i) \\otimes \\vw_q(e_j)$ & $\\vh_q(P_i) \\oplus \\vh_q(P_j)$ & $\\ozero_q$, $\\oone_q$ & $\\vw_q(e)$ \\\\\n            \\midrule\n            \\multirow{3}{*}{\\bf{\\shortstack[l]{Traditional\\\\Link\\\\Prediction}}}\n            & Katz Index~\\cite{katz1953new} & $\\vw_q(e_i) \\times \\vw_q(e_j)$ & $\\vh_q(P_i) + \\vh_q(P_j)$ & $0, 1$ & $\\beta w_e$ \\\\\n            & Personalized PageRank~\\cite{page1999pagerank} & $\\vw_q(e_i) \\times \\vw_q(e_j)$ & $\\vh_q(P_i) + \\vh_q(P_j)$ & $0, 1$ & $\\alpha w_{uv} / \\sum_{v'\\in\\gN(u)}w_{uv'}$ \\\\\n            & Graph Distance~\\cite{liben2007link} & $\\vw_q(e_i) + \\vw_q(e_j)$ & $\\min(\\vh_q(P_i), \\vh_q(P_j))$ & $+\\infty, 0$ & $w_e$ \\\\\n            \\midrule\n            \\multirow{2}{*}{\\bf{\\shortstack[l]{Graph Theory\\\\Algorithms}}}\n            & Widest Path~\\cite{baras2010path} & $\\min(\\vw_q(e_i), \\vw_q(e_j))$ & $\\max(\\vh_q(P_i), \\vh_q(P_j))$ & $-\\infty, +\\infty$ & $w_e$ \\\\\n            & Most Reliable Path~\\cite{baras2010path} & $\\vw_q(e_i) \\times \\vw_q(e_j)$ & $\\max(\\vh_q(P_i), \\vh_q(P_j))$ & $0, 1$ & $w_e$ \\\\\n            \\midrule\n            \\multirow{2}{*}{\\bf{Logic Rules}}\n            & NeuralLP~\\cite{yang2017differentiable} / & \\multirow{2}{*}{$\\vw_q(e_i) \\times \\vw_q(e_j)$} & \\multirow{2}{*}{$\\vh_q(P_i) + \\vh_q(P_j)$} & \\multirow{2}{*}{0, 1} & Weights learned \\\\\n            & DRUM~\\cite{sadeghian2019drum} & & & & by LSTM~\\cite{hochreiter1997long} \\\\\n            \\midrule\n            & \\multirow{3}{*}{\\method} & Relational operators of & \\multirow{3}{*}{\\shortstack[c]{Learned set\\\\aggregators~\\cite{corso2020principal}}} & \\multirow{3}{*}{\\shortstack[c]{Learned indicator\\\\functions}} & \\multirow{3}{*}{\\shortstack[c]{Learned relation\\\\embeddings}} \\\\\n            & & knowledge graph \\\\\n            & & embeddings~\\cite{bordes2013translating, yang2015embedding, sun2019rotate} \\\\\n            \\bottomrule\n        \\end{tabular}\n    \\end{adjustbox}\n\\end{table}",
            "tab:kg_result": "\\begin{table}[!h]\n    \\centering\n    \\caption{Knowledge graph completion results. Results of NeuraLP and DRUM are taken from \\cite{sadeghian2019drum}. Results of RotatE, HAKE and LowFER are taken from their original papers~\\cite{sun2019rotate, zhang2020learning, amin2020lowfer}. Results of the other embedding methods are taken from \\cite{sun2019rotate}. Since GraIL has scalability issues in this setting, we evaluate it with 50 and 100 negative triplets for FB15k-237 and WN18RR respectively and report MR based on an unbiased estimation.}\n    \\label{tab:kg_result}\n    \\begin{adjustbox}{max width=\\textwidth}\n        \\begin{tabular}{llcccccccccc}\n            \\toprule\n            \\multirow{2}{*}{\\bf{Class}} & \\multirow{2}{*}{\\bf{Method}}\n            & \\multicolumn{5}{c}{\\bf{FB15k-237}} & \\multicolumn{5}{c}{\\bf{WN18RR}} \\\\\n            & & \\bf{MR} & \\bf{MRR} & \\bf{H@1} & \\bf{H@3} & \\bf{H@10} & \\bf{MR} & \\bf{MRR} & \\bf{H@1} & \\bf{H@3} & \\bf{H@10} \\\\\n            \\midrule\n            \\multirow{3}{*}{\\bf{Path-based}}\n            & Path Ranking~\\cite{lao2010relational} & 3521 & 0.174 & 0.119 & 0.186 & 0.285 & 22438 & 0.324 & 0.276 & 0.360 & 0.406 \\\\\n            & NeuralLP~\\cite{yang2017differentiable} & - & 0.240 & - & - & 0.362 & - & 0.435 & 0.371 & 0.434 & 0.566 \\\\\n            & DRUM~\\cite{sadeghian2019drum} & - & 0.343 & 0.255 & 0.378 & 0.516 & - & 0.486 & 0.425 & 0.513 & 0.586 \\\\\n            \\midrule\n            \\multirow{6}{*}{\\bf{Embeddings}}\n            & TransE~\\cite{bordes2013translating} & 357 & 0.294 & - & - & 0.465 & 3384 & 0.226 & - & - & 0.501 \\\\\n            & DistMult~\\cite{yang2015embedding} & 254 & 0.241 & 0.155 & 0.263 & 0.419 & 5110 & 0.43 & 0.39 & 0.44 & 0.49 \\\\\n            & ComplEx~\\cite{trouillon2016complex} & 339 & 0.247 & 0.158 & 0.275 & 0.428 & 5261 & 0.44 & 0.41 & 0.46 & 0.51 \\\\\n            & RotatE~\\cite{sun2019rotate} & 177 & 0.338 & 0.241 & 0.375 & 0.553 & 3340 & 0.476 & 0.428 & 0.492 & 0.571 \\\\\n            & HAKE~\\cite{zhang2020learning} & - & 0.346 & 0.250 & 0.381 & 0.542 & - & 0.497 & 0.452 & 0.516 & 0.582 \\\\\n            & LowFER~\\cite{amin2020lowfer} & - & 0.359 & 0.266 & 0.396 & 0.544 & - & 0.465 & 0.434 & 0.479 & 0.526 \\\\\n            \\midrule\n            \\multirow{3}{*}{\\bf{GNNs}}\n            & RGCN~\\cite{schlichtkrull2018modeling} & 221 & 0.273 & 0.182 & 0.303 & 0.456 & 2719 & 0.402 & 0.345 & 0.437 & 0.494 \\\\\n            & GraIL~\\cite{teru2020inductive} & 2053 & - & - & - & - & 2539 & - & - & - & - \\\\\n            & \\method & \\best{114} & \\best{0.415} & \\best{0.321} & \\best{0.454} & \\best{0.599} & \\best{636} & \\best{0.551} & \\best{0.497} & \\best{0.573} & \\best{0.666} \\\\\n            \\bottomrule\n        \\end{tabular}\n    \\end{adjustbox}\n\\end{table}",
            "tab:homo_result": "\\begin{table}[!h]\n    \\vspace{-1em}\n    \\centering\n    \\caption{Homogeneous graph link prediction results. Results of VGAE and S-VGAE are taken from their original papers~\\cite{kipf2016variational, davidson2018hyperspherical}.}\n    \\label{tab:homo_result}\n    \\begin{adjustbox}{max width=\\textwidth}\n        \\begin{tabular}{llcccccc}\n            \\toprule\n            \\multirow{2}{*}{\\bf{Class}} & \\multirow{2}{*}{\\bf{Method}}\n                    & \\multicolumn{2}{c}{\\bf{Cora}} & \\multicolumn{2}{c}{\\bf{Citeseer}} & \\multicolumn{2}{c}{\\bf{PubMed}} \\\\\n                &   & \\bf{AUROC} & \\bf{AP} & \\bf{AUROC} & \\bf{AP} & \\bf{AUROC} & \\bf{AP} \\\\\n            \\midrule\n            \\multirow{3}{*}{\\bf{Path-based}}\n            & Katz Index~\\cite{katz1953new} & 0.834 & 0.889 & 0.768 & 0.810 & 0.757 & 0.856 \\\\\n            & Personalized PageRank~\\cite{page1999pagerank} & 0.845 & 0.899 & 0.762 & 0.814 & 0.763 & 0.860 \\\\\n            & SimRank~\\cite{jeh2002simrank} & 0.838 & 0.888 & 0.755 & 0.805 & 0.743 & 0.829 \\\\\n            \\midrule\n            \\multirow{3}{*}{\\bf{Embeddings}}\n            & DeepWalk~\\cite{perozzi2014deepwalk} & 0.831 & 0.850 & 0.805 & 0.836 & 0.844 & 0.841 \\\\\n            & LINE~\\cite{tang2015line} & 0.844 & 0.876 & 0.791 & 0.826 & 0.849 & 0.888 \\\\\n            & node2vec~\\cite{grover2016node2vec} & 0.872 & 0.879 & 0.838 & 0.868 & 0.891 & 0.914 \\\\\n            \\midrule\n            \\multirow{5}{*}{\\bf{GNNs}}\n            & VGAE~\\cite{kipf2016variational} & 0.914 & 0.926 & 0.908 & 0.920 & 0.944 & 0.947 \\\\\n            & S-VGAE~\\cite{davidson2018hyperspherical} & 0.941 & 0.941 & \\best{0.947} & \\best{0.952} & 0.960 & 0.960 \\\\\n            & SEAL~\\cite{zhang2018link} & 0.933 & 0.942 & 0.905 & 0.924 & 0.978 & 0.979 \\\\\n            & TLC-GNN~\\cite{yan2021link} & 0.934 & 0.931 & 0.909 & 0.916 & 0.970 & 0.968 \\\\\n            & \\method             & \\best{0.956} & \\best{0.962} & 0.923 & 0.936 & \\best{0.983} & \\best{0.982} \\\\\n            \\bottomrule\n        \\end{tabular}\n    \\end{adjustbox}\n\\end{table}",
            "tab:inductive_result": "\\begin{table}[!h]\n    \\vspace{-1em}\n    \\centering\n    \\caption{Inductive relation prediction results (HITS@10). V1-v4 corresponds to the 4 standard versions of inductive splits. Results of compared methods are taken from \\cite{teru2020inductive}.}\n    \\label{tab:inductive_result}\n    \\footnotesize\n    \\begin{tabular}{llcccccccc}\n        \\toprule\n        \\multirow{2}{*}{\\bf{Class}} & \\multirow{2}{*}{\\bf{Method}} & \\multicolumn{4}{c}{\\bf{FB15k-237}} & \\multicolumn{4}{c}{\\bf{WN18RR}} \\\\\n        & & \\bf{v1} & \\bf{v2} & \\bf{v3} & \\bf{v4} & \\bf{v1} & \\bf{v2} & \\bf{v3} & \\bf{v4} \\\\\n        \\midrule\n        \\multirow{3}{*}{\\bf{Path-based}}\n        & NeuralLP~\\cite{gilmer2017neural} & 0.529 & 0.589 & 0.529 & 0.559 & 0.744 & 0.689 & 0.462 & 0.671 \\\\\n        & DRUM~\\cite{sadeghian2019drum} & 0.529 & 0.587 & 0.529 & 0.559 & 0.744 & 0.689 & 0.462 & 0.671 \\\\\n        & RuleN~\\cite{meilicke2018fine} & 0.498 & 0.778 & 0.877 & 0.856 & 0.809 & 0.782 & 0.534 & 0.716 \\\\\n        \\midrule\n        \\multirow{2}{*}{\\bf{GNNs}}\n        & GraIL~\\cite{teru2020inductive} & 0.642 & 0.818 & 0.828 & 0.893 & 0.825 & 0.787 & 0.584 & 0.734 \\\\\n        & \\method & \\best{0.834} & \\best{0.949} & \\best{0.951} & \\best{0.960} & \\best{0.948} & \\best{0.905} & \\best{0.893} & \\best{0.890} \\\\\n        \\bottomrule\n    \\end{tabular}\n    \\vspace{-1em}\n\\end{table}",
            "tab:ablation": "\\begin{table}[!h]\n    \\caption{Ablation studies of \\method on FB15k-237. Due to space constraints, we only report MRR here. For full results on all metrics, please refer to Appendix~\\ref{app:ablation}.}\n    \\label{tab:ablation}\n    \\footnotesize\n    \\begin{subtable}[t]{0.52\\textwidth}\n        \\centering\n        \\caption{Different \\textsc{Message} and \\textsc{Aggregate} functions. \\label{tab:msg_agg}}\n        \\vspace{-0.5em}\n        \\begin{adjustbox}{max width=\\textwidth}\n            \\begin{tabular}{lcccc}\n                \\toprule\n                \\multirow{2}{*}{\\bf{\\textsc{Message}}} & \\multicolumn{4}{c}{\\bf{\\textsc{Aggregate}}} \\\\\n                                                  & Sum & Mean & Max & PNA~\\cite{corso2020principal} \\\\\n                \\midrule\n                TransE~\\cite{bordes2013translating} & 0.297 & 0.310 & 0.377 & 0.383 \\\\\n                DistMult~\\cite{yang2017differentiable} & 0.388 & 0.384 & 0.374 & \\bf{0.415} \\\\\n                RotatE~\\cite{sun2019rotate}   & 0.392 & 0.376 & 0.385 & \\bf{0.414} \\\\\n                \\bottomrule\n            \\end{tabular}\n        \\end{adjustbox}\n    \\end{subtable}\n    \\hspace{0.3em}\n    \\begin{subtable}[t]{0.46\\textwidth}\n        \\centering\n        \\caption{Different number of layers. \\label{tab:num_layer}}\n        \\vspace{-0.5em}\n        \\begin{adjustbox}{max width=\\textwidth}\n            \\begin{tabular}{lcccc}\n                \\toprule\n                \\multirow{2}{*}{\\bf{Method}} & \\multicolumn{4}{c}{\\bf{\\#Layers ($T$)}} \\\\\n                & 2 & 4 & 6 & 8 \\\\\n                \\midrule\n                \\method & 0.345 & 0.409 & \\bf{0.415} & \\bf{0.416} \\\\\n                \\bottomrule\n            \\end{tabular}\n        \\end{adjustbox}\n    \\end{subtable}\n    \\centering\n    \\begin{subtable}[h]{\\textwidth}\n        \\centering\n        \\caption{Performance w.r.t. relation category. The two scores are the rankings over heads and tails respectively. \\label{tab:rel_category}}\n        \\vspace{-0.5em}\n        \\begin{adjustbox}{max width=0.8\\textwidth}\n            \\begin{tabular}{lcccc}\n                \\toprule\n                \\multirow{2}{*}{\\bf{Method}} & \\multicolumn{4}{c}{\\bf{Relation Category}} \\\\\n                & \\bf{1-to-1} & \\bf{1-to-N} & \\bf{N-to-1} & \\bf{N-to-N} \\\\\n                \\midrule\n                TransE~\\cite{bordes2013translating} & 0.498/0.488 & 0.455/0.071 & 0.079/0.744 & 0.224/0.330 \\\\\n                RotatE~\\cite{sun2011pathsim} & 0.487/0.484 & 0.467/0.070 & 0.081/0.747 & 0.234/0.338 \\\\\n                \\method & \\best{0.578}/\\best{0.600} & \\best{0.499}/\\best{0.122} & \\best{0.165}/\\best{0.790} & \\best{0.348}/\\best{0.456} \\\\\n                \\bottomrule\n            \\end{tabular}\n        \\end{adjustbox}\n    \\end{subtable}\n\\end{table}",
            "tab:visualization": "\\begin{table}[!h]\n    \\vspace{-0.5em}\n    \\centering\n    \\caption{Path interpretations of predictions on FB15k-237 test set. For each query triplet, we visualize the top-2 path interpretations and their weights. Inverse relations are denoted with a superscript $^{-1}$.}\n    \\label{tab:visualization}\n    \\begin{adjustbox}{max width=\\textwidth}\n        \\footnotesize\n        \\begin{tabular}{ll}\n            \\toprule\n            \\bf{Query} & \\edge{u, q, v}: \\edge{O. Hardy, nationality, U.S.} \\\\\n            \\midrule\n            0.243 & \\edge{O. Hardy, impersonate$^{-1}$, R. Little} $\\land$ \\edge{R. Little, nationality, U.S.} \\\\\n            0.224 & \\edge{O. Hardy, ethnicity$^{-1}$, Scottish American} $\\land$ \\edge{Scottish American, distribution, U.S.} \\\\\n            \\midrule\n            \\bf{Query} & \\edge{u, q, v}: \\edge{Florence, vacationer, D.C. Henrie} \\\\\n            \\midrule\n            0.251 & \\edge{Florence, contain$^{-1}$, Italy} $\\land$ \\edge{Italy, capital, Rome} $\\land$ \\edge{Rome, vacationer, D.C. Henrie} \\\\\n            0.183 & \\edge{Florence, place live$^{-1}$, G.F. Handel} $\\land$ \\edge{G.F. Handel, place live, Rome} $\\land$ \\edge{Rome, vacationer, D.C. Henrie} \\\\\n            \\midrule\n            \\bf{Query} & \\edge{u, q, v}: \\edge{Pearl Harbor (film), language, Japanese} \\\\\n            \\midrule\n            0.211 & \\edge{Pearl Harbor (film), film actor, C.-H. Tagawa} $\\land$ \\edge{C.-H. Tagawa, nationality, Japan} \\\\\n            & $\\land$ \\edge{Japan, country of origin, Yu-Gi-Oh!} $\\land$ \\edge{Yu-Gi-Oh!, language, Japanese} \\\\\n            0.208 & \\edge{Pearl Harbor (film), film actor, C.-H. Tagawa} $\\land$ \\edge{C.-H. Tagawa, nationality, Japan} \\\\\n            & $\\land$ \\edge{Japan, official language, Japanese} \\\\\n            \\bottomrule\n        \\end{tabular}\n    \\end{adjustbox}\n\\end{table}",
            "tab:num_param": "\\begin{table}[!h]\n    \\centering\n    \\caption{Number of parameters in \\method. The number of parameters only grows with the number of relations $|\\gR|$, rather than the number of nodes $|\\gV|$ or edges $|\\gE|$. For FB15k-237 augmented with flipped triplets, $|\\gR|$ is 474. Our best configuration uses $T=6$, $d=32$ and hidden dimension $m=64$.}\n    \\label{tab:num_param}\n    \\begin{tabular}{lcccc}\n        \\toprule\n                            & \\multicolumn{2}{c}{\\bf{\\#Parameter}} \\\\\n                            & \\bf{Analytic Formula} & \\bf{FB15k-237} \\\\\n        \\midrule\n        \\textsc{Indicator}  & $|\\gR|d$              & 15,168        \\\\\n        \\textsc{Message}    & $T|\\gR|d(d+1)$        & 3,003,264     \\\\\n        \\textsc{Aggregate}  & $Td(13d+3)$           & 80,448        \\\\\n        $f(\\cdot)$          & $m(2d+1)+m+1$         & 4,225         \\\\\n        \\midrule\n        Total               &                       & 3,103,105     \\\\\n        \\bottomrule\n    \\end{tabular}\n\\end{table}",
            "tab:inductive_statistics": "\\begin{table}[!h]\n    \\centering\n    \\caption{Dataset statistics for inductive relation prediction. Queries refer to the triplets that are used as training or test labels, while facts are the triplets used as training or test inputs. In the training sets, all queries are also provided as facts.}\n    \\label{tab:inductive_statistics}\n    \\begin{adjustbox}{max width=\\textwidth}\n        \\begin{tabular}{llcccccccccc}\n            \\toprule\n            \\multirow{2}{*}{\\bf{Dataset}} & & \\multirow{2}{*}{\\bf{\\#Relation}} & \\multicolumn{3}{c}{\\bf{Train}} & \\multicolumn{3}{c}{\\bf{Validation}} & \\multicolumn{3}{c}{\\bf{Test}} \\\\\n            & & & \\bf{\\#Entity} & \\bf{\\#Query} & \\bf{\\#Fact} & \\bf{\\#Entity} & \\bf{\\#Query} & \\bf{\\#Fact} & \\bf{\\#Entity} & \\bf{\\#Query} & \\bf{\\#Fact} \\\\\n            \\midrule\n            \\multirow{4}{*}{FB15k-237~\\cite{teru2020inductive}}\n            & v1 & 180 & 1,594 & 4,245 & 4,245 & 1,594 & 489 & 4,245 & 1,093 & 205 & 1,993\\\\\n            & v2 & 200 & 2,608 & 9,739 & 9,739 & 2,608 & 1,166 & 9,739 & 1,660 & 478 & 4,145 \\\\\n            & v3 & 215 & 3,668 & 17,986 & 17,986 & 3,668 & 2,194 & 17,986 & 2,501 & 865 & 7,406 \\\\\n            & v4 & 219 & 4,707 & 27,203 & 27,203 & 4,707 & 3,352 & 27,203 & 3,051 & 1,424 & 11,714 \\\\\n            \\multirow{4}{*}{WN18RR~\\cite{teru2020inductive}}\n            & v1 & 9 & 2,746 & 5,410 & 5,410 & 2,746 & 630 & 5,410 & 922 & 188 & 1,618 \\\\\n            & v2 & 10 & 6,954 & 15,262 & 15,262 & 6,954 & 1,838 & 15,262 & 2,757 & 441 & 4,011\\\\\n            & v3 & 11 & 12,078 & 25,901 & 25,901 & 12,078 & 3,097 & 25,901 & 5,084 & 605 & 6,327\\\\\n            & v4 & 9 & 3,861 & 7,940 & 7,940 & 3,861 & 934 & 7,940 & 7,084 & 1,429 & 12,334 \\\\\n            \\bottomrule\n        \\end{tabular}\n    \\end{adjustbox}\n\\end{table}",
            "tab:hyperparameter": "\\begin{table}[!h]\n    \\centering\n    \\caption{Hyperparameter configurations of \\method on different datasets. Adv. temperature corresponds to the temperature in self-adversarial negative sampling~\\cite{sun2019rotate}. Note for FB15k-237 and WN18RR, we use the same hyperparameters for their transductive and inductive settings. We find our model configuration is robust across all datasets, therefore we only tune the learning hyperparameters for each dataset. All the hyperparameters are chosen by the performance on the validation set.}\n    \\label{tab:hyperparameter}\n    \\begin{adjustbox}{max width=\\textwidth}\n        \\begin{tabular}{llccccc}\n            \\toprule\n            \\multicolumn{2}{l}{\\bf{Hyperparameter}}\n                                 & \\bf{FB15k-237} & \\bf{WN18RR} & \\bf{Cora} & \\bf{CiteSeer} & \\bf{PubMed} \\\\\n            \\midrule\n            \\multirow{2}{*}{\\bf{GNN}}\n                                 & \\#layer($T$) & 6         & 6      & 6    & 6        & 6      \\\\\n                                 & hidden dim.  & 32        & 32     & 32   & 32       & 32     \\\\\n            \\midrule\n            \\multirow{2}{*}{\\bf{MLP}}\n                                 & \\#layer     & 2         & 2      & 2    & 2        & 2      \\\\\n                                 & hidden dim. & 64        & 64     & 64   & 64       & 64    \\\\\n            \\midrule\n            \\multirow{2}{*}{\\bf{Batch}}\n                                 & \\#positive  & 256       & 128    & 256  & 256    & 64     \\\\\n                                 & \\#negative/\\#positive($n$) & 32     & 32   & 1      & 1     & 1      \\\\\n            \\midrule\n            \\multirow{4}{*}{\\bf{Learning}}\n                                 & optimizer     & Adam   & Adam   & Adam   & Adam   & Adam    \\\\\n                                 & learning rate & 5e-3   & 5e-3   & 5e-3   & 5e-3   & 5e-3    \\\\\n                                 & \\#epoch       & 20     & 20     & 20     & 20     & 20      \\\\\n                                 & adv. temperature & 0.5 & 1      & -      & -      & -       \\\\\n            \\bottomrule\n        \\end{tabular}\n    \\end{adjustbox}\n\\end{table}",
            "tab:wall_time": "\\begin{table}[!h]\n    \\centering\n    \\caption{Wall time of \\method on different datasets and in different settings (Table~\\ref{tab:kg_result}, \\ref{tab:homo_result} and \\ref{tab:inductive_result}). For inductive setting, the total time over 4 split versions is reported.}\n    \\label{tab:wall_time}\n    \\begin{adjustbox}{max width=\\textwidth}\n    \\begin{tabular}{lccccccc}\n        \\toprule\n        \\multirow{2}{*}{\\bf{Wall Time}} & \\multicolumn{5}{c}{\\bf{Transductive}} & \\multicolumn{2}{c}{\\bf{Inductive}} \\\\\n                       & FB15k-237 & WN18RR & Cora & CiteSeer & PubMed & FB15k-237 & WN18RR \\\\\n        \\midrule\n        \\bf{Training}  & 9.7 hrs  & 4.4 hrs  & 5.5 mins & 5.3 mins & 5.6 hrs & 23 mins & 41 mins \\\\\n        \\bf{Inference} & 4.0 mins & 2.4 mins & < 1 sec & < 1 sec & 25 secs & 6 secs & 20 secs \\\\\n        \\bottomrule\n    \\end{tabular}\n    \\end{adjustbox}\n\\end{table}",
            "tab:ogbl-biokg": "\\begin{table}[!h]\n    \\centering\n    \\caption{Knowledge graph completion results on ogbl-biokg. Results of compared methods are taken from the OGB leaderboard.}\n    \\label{tab:ogbl-biokg}\n    \\footnotesize\n    \\begin{tabular}{llccc}\n        \\toprule\n        \\bf{Class} & \\bf{Method} & \\bf{Test MRR} & \\bf{Validation MRR} & \\bf{\\#Params}\\\\\n        \\midrule\n        \\multirow{6}{*}{\\bf{Embeddings}}\n        & TransE~\\cite{bordes2013translating} & 0.7452 & 0.7456 & 187,648,000 \\\\\n        & DistMult~\\cite{yang2015embedding} & 0.8043 & 0.8055 & 187,648,000 \\\\\n        & ComplEx~\\cite{trouillon2016complex} & 0.8095 & 0.8105 & 187,648,000 \\\\\n        & RotatE~\\cite{sun2019rotate} & 0.7989 & 0.7997 & 187,597,000 \\\\\n        & AutoSF~\\cite{zhang2020autosf} & 0.8309 & \\best{0.8317} & 93,824,000 \\\\\n        & PairRE~\\cite{chao2021pairre} & 0.8164 & 0.8172 & 187,750,000 \\\\\n        \\midrule\n        \\bf{GNNs}\n        & \\method & \\best{0.8317} & \\best{0.8318} & 734,209\\\\\n        \\bottomrule\n    \\end{tabular}\n\\end{table}"
        },
        "figures": {
            "fig:bfs_sampling": "\\begin{figure}[!t]\n    \\centering\n    \\begin{subfigure}{0.32\\textwidth}\n        \\centering\n        \\includegraphics[width=\\textwidth]{figures/before_sampling.pdf}\n        \\caption{Original graph}\n    \\end{subfigure}\n    \\begin{subfigure}{0.32\\textwidth}\n        \\centering\n        \\includegraphics[width=\\textwidth]{figures/bfs_sampling.pdf}\n        \\caption{Bidirectional BFS}\n    \\end{subfigure}\n    \\begin{subfigure}{0.32\\textwidth}\n        \\centering\n        \\includegraphics[width=\\textwidth]{figures/after_sampling.pdf}\n        \\caption{Sampled graph}\n    \\end{subfigure}\n    \\caption{Illustration of bidirectional BFS sampling. For a \\textcolor{myblue}{head entity} and multiple \\textcolor{myorange}{tail candidates}, we use BFS to sample a $k$-hop neighborhood around each entity, regardless of the direction of edges. The neighborhood is denoted by dashed circles. The nodes and edges visited by the BFS algorithm are extracted to generate the sampled graph. Best viewed in color.}\n    \\label{fig:bfs_sampling}\n\\end{figure}"
        },
        "equations": {
            "eq:1": "\\begin{align}\n    \\restatableeq{\\link}{&\\vh_q(u, v) = \\vh_q(P_1) \\oplus \\vh_q(P_2) \\oplus ... \\oplus \\vh_q(P_{|\\gP_{uv}|}) \\vert_{P_i \\in \\gP_{uv}} \\triangleq \\bigoplus_{P \\in \\gP_{uv}} \\vh_q(P)}{eqn:link} \\\\\n    \\restatableeq{\\path}{&\\vh_q(P = (e_1, e_2, ..., e_{|P|})) = \\vw_q(e_1) \\otimes \\vw_q(e_2) \\otimes ... \\otimes \\vw_q(e_{|P|}) \\triangleq \\bigotimes_{i=1}^{|P|} \\vw_q(e_i)}{eqn:path}\n\\end{align}",
            "eq:2": "\\begin{align}\n    \\restatableeq{\\boundary}{\\vh_q^{(0)}(u, v) &\\leftarrow \\mathbbm{1}_q(u = v)}{eqn:boundary} \\\\\n    \\restatableeq{\\iteration}{\\vh_q^{(t)}(u, v) &\\leftarrow \\left(\\bigoplus_{(x, r, v)\\in\\gE(v)} \\vh_q^{(t-1)}(u, x) \\otimes \\vw_q(x, r, v)\\right) \\oplus \\vh_q^{(0)}(u, v)}{eqn:iteration}\n\\end{align}",
            "eq:3": "\\begin{align}\n    \\vh^{(0)}_v &\\leftarrow \\textsc{Indicator}(u, v, q) \\\\\n    \\vh^{(t)}_v &\\leftarrow \\textsc{Aggregate}\\left(\\left\\{\\textsc{Message}\\left(\\vh^{(t-1)}_x, \\vw_q(x, r, v)\\right) \\middle\\vert (x, r, v) \\in \\gE(v)\\right\\} \\cup \\left\\{\\vh^{(0)}_v\\right\\}\\right)\n\\end{align}",
            "eq:4": "\\begin{align}\n    &\\gL_{KG} = -\\log p(u, q, v) - \\sum_{i=1}^n \\frac{1}{n}\\log (1 - p(u_i', q, v_i'))\n    \\label{eqn:kg_loss} \\\\\n    &\\gL_{homo} = -\\log p(u, v) -\n    \\sum_{i=1}^n \\frac{1}{n}\\log (1 - p(u_i', v_i')),\n    \\label{eqn:homo_loss}\n\\end{align}",
            "eq:5": "\\begin{equation}\n    P_1, P_2, ..., P_k = \\topk_{P \\in \\gP_{uv}} \\frac{\\partial{p(u, q, v)}}{\\partial{P}}\n\\end{equation}",
            "eq:6": "\\begin{align}\n    \\link \\\\\n    \\path\n\\end{align}",
            "eq:7": "\\begin{equation}\n    \\vh_q(u,v) = \\bigoplus_{P\\in\\gP_{uv}} \\bigotimes_{i=1}^{|P|} \\vw_q(e_i)\n    \\label{eqn:compact}\n\\end{equation}",
            "eq:8": "\\begin{equation}\n    \\text{Katz}(u, v)\n    =\\sum_{t=1}^{\\infty} \\beta^t \\ve_u^\\top \\mA^t \\ve_v\n\\end{equation}",
            "eq:9": "\\begin{equation}\n    \\text{PPR}(u, v)\n    =(1-\\alpha)\\sum_{t=1}^{\\infty} \\alpha^t \\ve_u^\\top (\\mD^{-1}\\mA)^t \\ve_v\n\\end{equation}",
            "eq:10": "\\begin{align}\n    \\boundary \\\\\n    \\iteration\n\\end{align}"
        },
        "git_link": "https://github.com/DeepGraphLearning/NBFNet"
    }
}