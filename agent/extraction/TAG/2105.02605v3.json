{
    "meta_info": {
        "title": "GraphFormers: GNN-nested Transformers for Representation Learning on  Textual Graph",
        "abstract": "The representation learning on textual graph is to generate low-dimensional\nembeddings for the nodes based on the individual textual features and the\nneighbourhood information. Recent breakthroughs on pretrained language models\nand graph neural networks push forward the development of corresponding\ntechniques. The existing works mainly rely on the cascaded model architecture:\nthe textual features of nodes are independently encoded by language models at\nfirst; the textual embeddings are aggregated by graph neural networks\nafterwards. However, the above architecture is limited due to the independent\nmodeling of textual features. In this work, we propose GraphFormers, where\nlayerwise GNN components are nested alongside the transformer blocks of\nlanguage models. With the proposed architecture, the text encoding and the\ngraph aggregation are fused into an iterative workflow, {making} each node's\nsemantic accurately comprehended from the global perspective. In addition, a\n{progressive} learning strategy is introduced, where the model is successively\ntrained on manipulated data and original data to reinforce its capability of\nintegrating information on graph. Extensive evaluations are conducted on three\nlarge-scale benchmark datasets, where GraphFormers outperform the SOTA\nbaselines with comparable running efficiency.",
        "author": "Junhan Yang, Zheng Liu, Shitao Xiao, Chaozhuo Li, Defu Lian, Sanjay Agrawal, Amit Singh, Guangzhong Sun, Xing Xie",
        "link": "http://arxiv.org/abs/2105.02605v3",
        "category": [
            "cs.CL",
            "cs.AI",
            "cs.IR"
        ],
        "additionl_info": "Accepted to NeurIPS 2021"
    },
    "latex_extraction": {
        "content": {
            "section 1": {
                "name": "Introduction",
                "content": "\nThe textual graph is a widely existed data format, where each node is annotated with its textual feature. The representation learning on textual graph is to generate low-dimensional node embeddings based on the individual textual features and the information from the neighbourhood. In recent years, the breakthroughs in pretrained language models and graph neural networks contribute to the development of corresponding techniques. Particularly, with pretrained language models, such as BERT \\citep{devlin2018bert} and RoBERTa \\citep{liu2019roberta}, the underlying semantics of texts can be captured more precisely; at the same time, with graph neural networks, like GraphSage \\citep{hamilton2017inductive} and GAT \\citep{velivckovic2017graph}, neighbours can be effectively aggregated for more informative node embeddings. It is necessary to combine both techniques for better textual graph representation. As suggested by GraphSage \\citep{hamilton2017inductive} and PinSage \\citep{ying2018graph}, the textual feature can be independently modeled by text encoders and further aggregated by rear-mounted GNNs for the final node embeddings. Such a representation paradigm has been widely adopted by subsequent works on various scenarios \\citep{zhu2021textgnn,li2021adsgnn,hu2020gpt,liu2019fine,zhou2019gear}, where GNNs are combined with powerful PLM-based text encoders.\n\n\n\\setlength{\\textfloatsep}{10pt}\n\n\nThe above way of combination is called the ``Cascaded Transformers-GNN'' architecture (Figure \\ref{fig:1} A), as the language models (built upon Transformers) are deployed ahead of the GNN component. With the above architecture, the text encoding and the graph aggregation are performed in two consecutive steps, where there is no information exchange between the nodes when text embeddings are generated. However, the above workflow is defective considering that the linked nodes are correlated, whose underlying semantics can be mutually enhanced. For example, given a node ``notes on transformers'' and its neighbour ``tutorials on machine translation''; by making reference to the whole context, the ``transformers'' here can be interpreted as a machine learning model, rather than an electric device.\n\n\\textbf{Our Work}. We propose ``GNN-nested Transformers'' (\\textbf{GraphFormers}), which are highlighted for the fusion of GNNs and language models (Figure \\ref{fig:1} B). In GraphFormers, the GNN components are nested alongside the transformer layers (TRM) of language models, where the text encoding and graph aggregation are fused as an iteratively workflow. In each iteration, the linked nodes will exchange information with each other in the layerwise GNN component; thus, each node will be augmented by its neighbourhood information. The transformer component will work on the augmented node features, where increasingly informative node representations can be generated for the next iteration. Compared with the cascaded architecture, GraphFormers achieve more sufficient utilization of the cross-node information on graph, which significantly benefit the representation quality. Given that the layerwise GNN components merely involve simple and effective multi-head attention, GraphFormers preserve comparable running costs as the existing cascaded Transformers-GNN models.\n\nOn top of the proposed model architecture, we further improve GraphFormers' representation quality and practicability as follows. Firstly, the training of GraphFormers is likely to be shortcut: in many cases, the center node itself can be {``sufficiently informative''}, where {the training tasks can be accomplished without leveraging the neighbourhood information}. As such, GraphFormers may end up with insufficiently trained GNNs. Inspired by recent success of curriculum learning \\citep{bengio2009curriculum}, we propose to \\textbf{train the model progressively}: the first round of training is performed with manipulated data, where the nodes are randomly polluted; thus, it becomes harder to make prediction merely rely on the center nodes, and the model will be forced to leverage the whole input nodes. The second round of training gets back to the unpolluted data, where the model will be fit into the targeted distribution. Another concern about GraphFormers is that all the linked nodes are mutually dependent in the representation process: once a new node is presented, all the neighbours, regardless of whether they have been processed before, need to be encoded from scratch. As a result, a great deal of unnecessary computations will be incurred. We introduce \\textbf{unidirectional graph attention} to alleviate this problem: only the center node is required to make reference to the neighbours, while the neighbour nodes remain independently encoded. By this means, the existing neighbours' encoding results can be cached and {reused}, which significantly saves the computation cost. \n \nExtensive evaluations are conducted with three million-scale textual graph datasets: DBLP, Wiki and Product, where the representation quality is measured by the link prediction accuracy. According to our experiment results, GraphFormers significantly outperform the SOTA cascaded Transformers-GNN baselines with comparable running efficiency.\n\n"
            },
            "section 2": {
                "name": "Related Work",
                "content": "\nThe textual graph representation is an important research topic in multiple areas, such as natural language processing, information retrieval and graph learning \\citep{yang2015network,wang2016linked,wang2016text,yasunaga2017graph,wang2019improving,xu2019deep}. To learn high-quality representation for textual graph, techniques on natural language understanding and graph representation need to be jointly leveraged. In recent years, breakthroughs on pretrained language models (PLM) and graph neural networks (GNN) significantly advance the development of corresponding techniques.\n\n\\textbf{PLM}. The PLMs are proposed to learn universal language models with neural networks trained on large-scale corpus. The early works were based on shallow networks, e.g, word embeddings learned by Skip-Gram \\citep{mikolov2013distributed} and GloVe \\citep{pennington2014glove}. In recent years, the backbone networks are being quickly scaled up: from EMLo \\citep{peters2018deep}, GPT \\citep{radford2018improving}, to BERT \\citep{devlin2018bert}, XLNet \\citep{yang2019xlnet}, T5 \\citep{raffel2019exploring}, GPT-3 \\citep{brown2020language}. The large-scale models, which get fully trained with massive data, demonstrate superior performances on general NLP tasks. One of the most critical usages of PLMs is text representation, where the underlying semantics of texts are captured by low-dimensional embeddings. Such embeddings achieve competitive results on downstream tasks, like text retrieval and classification \\citep{reimers2019sentence,luan2020sparse,gao2021simcse,su2021whitening}.\n\n\\textbf{GNN}. Graph neural networks are recognized as powerful tools of modeling graph data \\citep{hamilton2017representation,zhou2020graph}. Such methods (e.g., GCN \\citep{kipf2016semi}, GAT \\citep{velivckovic2017graph}, GraphSage \\citep{hamilton2017inductive}) learn effective message passing mechanisms such that information between the nodes can get aggregated for expressive graph representations. \n\nGraph neural networks may also incorporate node attributes, like texts; and it's quite straightforward to leverage GNNs and PLMs for textual graph representation following the ``cascaded architecture'' suggested by GraphSage \\citep{hamilton2017inductive}: the node features are independently encoded at first; then, the node embeddings are aggregated via GNNs to generate the final representations. Such a representation paradigm is widely adopted by subsequent works \\citep{zhu2021textgnn,li2021adsgnn,hu2020gpt,liu2019fine,zhou2019gear}. However, the above approaches treat the text encoding and graph aggregation as two consecutive steps, where the node-level features are independently processed. Our work is different from these approaches as the text encoding and graph aggregation are fused as an iterative workflow based on the ``GNN-nested Transformers''.\n\n\n"
            },
            "section 3": {
                "name": "GraphFormers",
                "content": "\n% \\subsection{Problem Definition}\nIn this work, we deal with textual graph data, where each node $x$ is a text. The node $x$ together with its neighbours $N_x$ are denoted as $G_x$. Our model learns the embedding for node $x$ based on its own textual feature and the information of its neighbourhood $N_x$. The generated embeddings are expected to capture the relationship between the nodes, i.e., to accurately predict whether two nodes $x_q$ and $x_k$ are connected based on the embedding similarity.\n\n",
                "subsection 3.1": {
                    "name": "GNN-nested Transformers",
                    "content": "\\label{sec:gnlm}\nThe encoding process of GraphFormers is indicated as follows. The input nodes (the center node and its neighbours) are tokenized into sequences of tokens, with special tokens [CLS] padded in the front, whose states are used for node representation. The input sequences are mapped into the initial embedding sequences $\\{\\mathbf{H}^0_{g}\\}_G$ based on the summation of word embeddings and position embeddings. The embedding sequences are encoded by multiple layers of GNN-nested Transformers (shown as Figure \\ref{fig:3}), where the graph aggregation and text encoding are iteratively performed. \n\n$\\bullet$ \\textbf{Graph Aggregation in GNN}. Each node is enhanced by its neighbourhood information based on the layerwise graph aggregation. For each node in the $l$-th layer, the first token-level embedding (corre-sponding to [CLS]) is taken as the node-level embedding: $\\mathbf{z}^l_g \\leftarrow \\mathbf{H}^l_g[0]$. The node-level embeddings are gathered from all the nodes and passed to the layerwise GNN for graph aggregation. We leverage Multi-Head Attention (MHA) to encode the node-level embeddings $\\mathbf{Z}^l_G$ ($\\{\\mathbf{z}^l_g\\}_G$), similar as GAT \\citep{velivckovic2017graph}. For each attention head, the scaled dot-product attention is performed as:\n\\begin{equation}\\label{eq:1}\n\\begin{gathered}\n\\mathbf{\\hat{Z}}^l_G = \\mathrm{MHA}(\\mathbf{Z}^l_G); \n\\\\\n\\mathrm{MHA}(\\mathbf{Z}^l_G) = \\mathrm{Concat}(\\mathbf{head}_{1}, ... ,\\mathbf{head}_{h}); \n\\\\\n\\mathbf{head}_{j} = \\mathrm{softmax}(\\frac{\\mathbf{QK^T}}{\\sqrt{d}}+\\mathbf{B})\\mathbf{V};\n\\\\\n\\mathbf{Q} = \\mathbf{Z}^l_G\\mathbf{W}_{j}^Q; ~ \\mathbf{K} = \\mathbf{Z}^l_G\\mathbf{W}_{j}^K; ~ \\mathbf{V} = \\mathbf{Z}^l_G\\mathbf{W}_{j}^V; \n\\end{gathered}\n\\end{equation}\nIn the above equations, $\\mathbf{W}_{j}^Q$, $\\mathbf{W}_{j}^K$, and $\\mathbf{W}_{j}^V$ are the projection matrices of MHA, corresponding to the $j$-th attention head. A {learnable position} bias $\\mathbf{B}$ is added to the dot-product result; {the positions} differentiate the relationship between the nodes; i.e., ``center-to-center'' ($x$ to $x$), ``center-to-neighbour'' ($x$ to $N_x$), and ``neighbour-to-neighbour'' ($N_x$ to $N_x$), respectively.\n\nEach of the embeddings $\\mathbf{\\hat{z}}^l_g$ ($\\mathbf{\\hat{z}}^l_g \\in \\mathbf{\\hat{Z}}^l_G$) is dispatched to its original node and concatenated ({$\\oplus$}) with the token-level embeddings, which gives rise to the graph-augmented token-level embeddings:\n\\begin{equation}\n    \\widehat{\\mathbf{H}}^l_g \\leftarrow \\mathrm{Concat}(\\mathbf{\\hat{z}}^l_g, \\mathbf{H}^l_g).\n\\end{equation}\nIn this place, the GNN-processed node-level embeddings $\\mathbf{\\hat{Z}}^l_G$ can be interpreted as ``messagers'', with which the neighbourhood information can be introduced to each of the nodes. \n\n\n\n\n$\\bullet$ \\textbf{Text Encoding in Transformer}. The graph-augmented token-level embeddings {$\\widehat{\\mathbf{H}}^l_g$} are processed by the transformer component \\citep{vaswani2017attention}, where the following computations are performed:\n\\begin{equation}\n\\begin{gathered}\n     \\widehat{\\mathbf{H}}^l_g = \\mathrm{LN}(\\mathbf{{H}}^l_g + \\mathrm{MHA}^{asy}(\\widehat{\\mathbf{H}}^l_g)); \\\\\n     \\mathbf{H}^{l+1}_g = \\mathrm{LN}(\\widehat{\\mathbf{H}}^l_g + \\mathrm{MLP}(\\widehat{\\mathbf{H}}^l_g)).\n\\end{gathered}\n\\end{equation}\nIn the above equations, $\\mathrm{MLP}$ is the Multi-Layer Projection unit, and $\\mathrm{LN}$ is the Layer-Norm unit. We use asymmetric Multi-Head Attention ({$\\mathrm{MHA}^{asy}$}), where $\\mathbf{Q}$, $\\mathbf{K}$,  $\\mathbf{V}$ are computed as:  \n\\begin{equation}\n\\begin{gathered}\n\\mathbf{Q} = \\mathbf{{H}}^l_g\\mathbf{W}_{j}^Q; ~ \\mathbf{K} = \\widehat{\\mathbf{H}}^l_g\\mathbf{W}_{j}^K; ~ \\mathbf{V} = \\widehat{\\mathbf{H}}^l_g\\mathbf{W}_{j}^V.\n\\end{gathered}\n\\end{equation}\nTherefore, the output sequence $\\mathbf{H}^{l+1}_g$ will be of the same length as the input sequence $\\mathbf{{H}}^l_g$. The encoding result will be used as the input token-level embeddings for the next layer. The node-level embedding at the last layer $\\mathbf{z}^L_x$ (i.e., $\\mathbf{{H}}^L_g[0]$) will be used as the final node representation.\n\n$\\bullet$ \\textbf{Workflow}. We summarize GraphFormers' encoding workflow as Algorithm \\ref{alg:1}. The initial token-level embeddings $\\{\\mathbf{H}^{0}_g\\}_G$ are independently encoded by the first Transformer layer $\\mathrm{TRM}^0$. For a $L$-layer GraphFormers, the graph aggregation and text encoding are iteratively performed for the subsequent $L$-1 steps (from 1 to $L-1$). In each step, the node-level embeddings $\\mathbf{Z}^l_G$ are gathered and processed by the layerwise GNN component. The output node-level embeddings $\\mathbf{\\hat{Z}}^l_G$ are dispatched to their original nodes, which generates the graph-augmented token-level embeddings $\\widehat{\\mathbf{H}}^l_g$. The graph-augmented token-level embedding are further processed by the Transformer component. Finally, The node-level embedding (for the center node $x$) in the last layer $\\mathbf{z}^L_x$ is taken as our representation result.\n\n$\\bullet$ \\textbf{Encoding Complexity}. Given an input of $M$ nodes, each one has $P$ tokens; the time complexity of each layer's encoding operation is $O(M^2+MP^2)$: the graph aggregation takes $O(M^2)$, because $M$ node-level embeddings are gathered for multi-head attention; the text encoding takes $O(MP^2)$, as each of the $M$ node calls for the multi-head attention of $P$ tokens. Compared with Transformers, the GNN's computation cost is much smaller, mainly because of two reasons: 1) $M^2 \\ll MP^2$ in general,  2) operations like MLP are not needed in graph aggregation. Therefore, the working efficiency of GraphFormers is close to the cascaded GNN-Transformers as the extra computation cost of layerwise graph aggregation is relatively small. Such a property is also empirically verified in our experiment.\n\n% \\setlength{\\textfloatsep}{10pt}\n\\begin{algorithm}[t]\n\\caption{GraphFormers' Workflow}\\label{alg:1}\n\\LinesNumbered \n\\KwIn{The input graphs $G$ (consist of the center node $x$ and its neighbours).}\n\\KwOut{The embedding for the center node $\\mathbf{h}_x$.}\n\\Begin{\n    \\For{each text $g \\in G$}{\n        $\\mathbf{H}^{1}_g \\leftarrow \\mathrm{TRM}^0(\\mathbf{H}^{0}_g)$;\n        // Get the initial token-level embeddings\n        \\\\\n    }\n    \\For{$l = 1, ..., L-1$}{\n        $\\mathbf{Z}^l_G \\leftarrow \\{\\mathbf{z}^l_g|g{\\in}G\\}$; // Gather node-level embeddings to GNN\n        \\\\\n        $\\mathbf{\\hat{Z}}^l_G \\leftarrow \\mathrm{GNN}(\\mathbf{{Z}}^l_G)$; // Graph aggregation in GNN\n        \\\\\n        \\For{each text $g \\in G$}{\n            $\\widehat{\\mathbf{H}}^l_g \\leftarrow \\mathrm{Concat}(\\mathbf{\\hat{z}}^l_g, \\mathbf{H}^l_g)$; // Get graph-augmented token-level embeddings\n            \\\\\n            $\\mathbf{H}^{l+1}_g \\leftarrow \\mathrm{TRM}^l(\\widehat{\\mathbf{H}}^l_g)$; // Text encoding in Transformer\n            \\\\\n        }\n    }\n    Return $\\mathbf{h}_x \\leftarrow \\mathbf{z}_x^{L}$\\;\n}\n\\end{algorithm}\n\n"
                },
                "subsection 3.2": {
                    "name": "Model Simplification: Unidirectional Graph Aggregation",
                    "content": "\\label{sec:unidirection}\nOne concern about GraphFormers is that the input nodes are mutually dependent on each other during the encoding process. As a result, to generate the embedding for a node, all the related nodes in its neighbourhood need to be encoded from scratch, regardless of whether they have been processed before. Such a property is unfavorable in practice as a great deal of unnecessary computation cost might be incurred (i.e., a node will be repetitively encoded every time it serves as a neighbour node). We leverage a simple but effective simplification, the unidirectional graph aggregation, to address this problem. Particularly, only the center node $x$ is required to make reference to the neighbourhood; while the rest of nodes $N_x$ remain independently encoded all by their own textual features:\n\\begin{equation}\\label{eq:5}\n\\mathbf{H}^{l+1}_{g} = \n\\begin{cases}\n\\mathrm{TRM}^l(\\widehat{\\mathbf{H}^l_x}), ~ g = x; \\\\\n\\mathrm{TRM}^l(\\mathbf{H}^l_g), ~ \\forall g \\in N_x. \n\\end{cases}\n\\end{equation}\nBecause the encoding of the neighbour nodes is independent of the center node, the intermediate encoding results $\\{\\mathbf{z}^{1...L}_g\\}_{N_x}$ can be cached in storage\\footnote{The encoding results can be kept in low-cost devices, whose storage capacity can be regarded as infinite.} and reused in subsequent computations when they are needed. As a result, the nodes can be prevented from being encoded repetitively, which saves a great deal of unnecessary computation cost. We empirically verify that GraphFormers maintain similar performances when the above simplification is introduced.\n\n"
                },
                "subsection 3.3": {
                    "name": "Model Training: Two-Stage Progressive Learning",
                    "content": "\\label{sec:adapt}\n$\\bullet$ \\textbf{Training Objective}. We take advantage of link prediction as our training task. Given a pair of nodes $q$ and $k$, the model is learned to predict whether they are connected based on their embedding similarity. Particularly, the following classification loss is minimized for a positive pair of $q$ and $k$:\\footnote{We remove the naive cases where $q$ and $k$ are included by each other's neighbour set, $N_q$ and $N_k$.}\n\\begin{equation}\\label{eq:3}\n\\begin{gathered}\n\\mathcal{L} = - \\log \\frac{\\exp(\\langle\\mathbf{h}_q,\\mathbf{h}_k\\rangle)}{\\exp(\\langle\\mathbf{h}_q,\\mathbf{h}_k\\rangle) + \\sum_{r \\in R} \\exp(\\langle\\mathbf{h}_q,\\mathbf{h}_{r}\\rangle) }.\n\\end{gathered}\n\\end{equation}\nIn the above equation, $\\mathbf{h}_{q}$ and $\\mathbf{h}_{k}$ are the node embeddings; $\\langle\\cdot\\rangle$ denotes the computation of inner product; $R$ stands for the negative samples. In our implementation, we leverage ``in-batch negative samples'' \\citep{karpukhin2020dense,luan2020sparse} for the reduction of encoding cost: a positive sample in one training instance will be used as a negative sample in the rest of the training instances within the same mini-batch. \n\n$\\bullet$ \\textbf{Two-stage Training}. In GraphFormers, the information from the center node and neighbour nodes {are not treated equally}, which may undermine the model's training effect. Particularly, the center node's information can be directly utilized, while the neighbourhood information needs to be introduced via three steps: 1) encoded as node-level embeddings, 2) making graph aggregation with the center node, and 3) introduced to center node's graph augmented token-level embeddings. The message passing pathway can shortcut when the center nodes are ``sufficiently informative'', i.e., two nodes are sufficiently similar with each other in terms of their own textual features, such that their connection can be predicted without considering the neighbours. Given the existence of such cases, GraphFormers may end up with well-trained Transformers but insufficiently trained GNNs.\n\nTo alleviate the above problem, we introduce a warm-up training task, where the link prediction is made based on the polluted input nodes. Particularly, for each input node $g$, a subset of its tokens $g_m$ will be randomly masked\\footnote{We use the common MLM strategy, where 15\\% of the input tokens are masked: 80\\% of them are replaced by [MASK], the rest ones are replaced randomly or kept as the original tokens with the same probabilities.}. As a result, the classification loss becomes:\n\\begin{equation}\\label{eq:6-1}\n\\begin{gathered}\n\\mathcal{L}' = - \\log \\frac{\\exp(\\langle\\mathbf{h}_{\\tilde{q}},\\mathbf{h}_{\\tilde{k}}\\rangle)}{\\exp(\\langle\\mathbf{h}_{\\tilde{q}},\\mathbf{h}_{\\tilde{k}}\\rangle) + \\sum_{r \\in R} \\exp(\\langle\\mathbf{h}_{\\tilde{q}},\\mathbf{h}_{\\tilde{r}}\\rangle)},\n\\end{gathered}\n\\end{equation}\nwhere $\\mathbf{h}_{\\tilde{q}}$, $\\mathbf{h}_{\\tilde{k}}$, $\\mathbf{h}_{\\tilde{r}}$ are the embeddings generated from the polluted nodes. The masked tokens reduce the informativeness of each individual node; therefore, the model is forced to leverage the whole input nodes to make the right prediction. \n\nFinally, the model training is organized as a two-stage progressive learning process. In the first stage, the model is trained to minimize $\\mathcal{L}'$ based on the polluted nodes until its convergence, {which reinforce the model's capability of integrating information on graph}. In the second stage, the model is continually trained to minimize $\\mathcal{L}$ based on the original data until the convergence, {which makes the model fit into the target distribution}.\n\n"
                }
            },
            "section 4": {
                "name": "Experimental Studies",
                "content": "\n\n",
                "subsection 4.1": {
                    "name": "Data and Settings",
                    "content": "\nWe make use of the following three real-world textual graph datasets for our experimental studies. \n\n\\renewcommand{\\arraystretch}{1.2}\n\\newcommand\\ChangeRT[1]{\\noalign{\\hrule height #1}}\n% \\setlength{\\textfloatsep}{10pt}\n% \\vspace{-5pt}\n% \\begin{wraptable}{r}{0.51\\linewidth}\n\n\n$\\bullet$ \\textbf{DBLP}\\footnote{https://originalstatic.aminer.cn/misc/dblp.v12.7z}, which contains the paper citation graph from DBLP up to 2020-04-09. Two papers are linked if one is cited by the other one. The paper's title is used as the textual feature.\n\n$\\bullet$ \\textbf{Wikidata5M}\\footnote{https://deepgraphlearning.github.io/project/wikidata5m} (Wiki) \\citep{wang2019kepler}, which contains the entity graph from Wikipedia. The first sentence in each entity's introduction is taken as its textual feature.\n\n$\\bullet$ \\textbf{Product Graph} (Product), an even larger dataset of online products collected by a world-wide search engine. In this dataset, the users' web browsing behaviors are tracked for the targeted product webpages (e.g., Amazon webpages of Nike shoes). The user's continuously browsed webpages within a short period of time (e.g., 30 minutes) is called a ``\\textit{session}''. The products within a common session are connected in the graph (which is a common way of graph construction in e-commerce scenarios \\citep{ying2018graph,wang2018billion}). Each product has its unique textual description, which specifies information like the product name, brand, and saler, etc.\n\nThe textual features of all the datasets are in English. We make use of uncased WordPiece \\citep{wu2016google} to tokenize the input text. In our experiment, each text is associated with 5 uniformly sampled neighbours (without replacement); for texts with neighbourhood smaller than 5, all the neighbours will be utilized. We summarized the specifications of all the datasets with Table \\ref{tab:dataset}. The experiment results are evaluated in terms of link prediction accuracy, i.e., to predict whether a query node and key node are connected given the textual features of themselves and their neighbours. In each testing instance, one query is provided with 300 keys: 1 positive plus 299 randomly sampled negative cases. We leverage three common metrics to measure the prediction accuracy: \\textbf{Precision@1}, \\textbf{NDCG}, and \\textbf{MRR}. Without specifications, we will take the\\textbf{ unidirectional-simplified GraphFormers} trained with the \\textbf{two-stage progressive learning} as our default model. More details about the implementations and the training/testing configurations are summarized in an Appendix file. It is submitted together with our source code within the supplementary materials.\n\n% All the codes, checkpoints and open datasets will be made public-available.\n\n% \\vspace{-5pt}\n"
                },
                "subsection 4.2": {
                    "name": "Baselines",
                    "content": "\nWe focus on the comparison between GNN-nested Transformers and Cascaded Transformers-GNN. To make sure the difference between both architectures can be truthfully reflected from the evaluation results, GraphFormers and the Cascaded Transformers-GNN baselines are equipped with text encoders and graph aggregators of the same capacities. Particularly, we use the BERT-like \\textbf{PLM} as our text encoder, where UniLM-base\\footnote{An enhanced BERT-like PLM showing more competitive performances than peers like RoBERTa, XLNet.} \\citep{bao2020UniLMv2} is chosen as the network backbone for all related methods; the final layer's [CLS] token embedding is used for the text embedding. \n\n% We consider the following representative graph aggregators, which. The graph attention networks (\\textbf{GAT)} \\citep{velivckovic2017graph}, where the node embedding is generated as the weighted sum of all the text embeddings. Each text embedding's relative importance is calculated as the attention score with the center node. And \\textbf{GraphSage} \\citep{hamilton2017inductive}, where the graph aggregation result and the center node's text embedding are concatenated and linearly transformed for the final representation of the center node. Depending on the form of pooling function, we have the following variations: GraphSage-\\textbf{Max} and GraphSage-\\textbf{Mean}, where the graph aggregation is made by max-pooling and mean-pooling, respectively; and GraphSage-\\textbf{Att}, where the aggregation is made based on the attention scores with the center node's text embedding. By comparison, the neighbourhood information may get more emphasized with GAT; while the center node itself tends to be highlighted with GraphSage. \n\n{We enumerate the following representative graph aggregators as used in GAT \\citep{velivckovic2017graph}, GIN \\citep{xu2018powerful}, GraphSage \\citep{hamilton2017inductive}.} The \\textbf{GAT} aggregator, where the node embedding is generated as the weighted sum of all the text embeddings. Each text embedding's relative importance is calculated as the attention score with the center node. The \\textbf{Pooling-and-Concat} aggregators, where the center node's text embedding is concatenated with the neighbours' pooling result and linearly transformed for the final representation. Depending on the form of pooling function, we have the following options: \\textbf{Max} and \\textbf{Mean}, where neighbours are aggregated by max-pooling and mean-pooling, respectively; \\textbf{Att}, where the neighbours are summed up based on the attention weights with the center node. By comparison, the neighbourhood information may get more emphasized with GAT; while the center node itself tends to be highlighted with Pooling-and-Concat.\n\nWe consider two more baselines which make use of simplified text encoders (such as CNN) and network embeddings: \\textbf{TNVE} \\citep{wang2019improving} and \\textbf{IFTN} \\citep{xu2019deep}. We also include the \\textbf{PLM} only baseline, which merely leverages the textual feature of the center node. \n\n\\newcolumntype{C}[1]{>{\\centering\\let\\newline\\\\\\arraybackslash\\hspace{0pt}}m{#1}}\n\n\n\n\n% \\begin{wraptable}{r}{0.55\\linewidth}\n\n\n% \\vspace{-5pt}\n"
                },
                "subsection 4.3": {
                    "name": "Overall Evaluation",
                    "content": "\n\nThe overall evaluation results are reported in Table \\ref{tab:exp-main}. It's observed that GraphFormers consistently outperform all the baselines, especially the ones based on the cascaded Transformers-GNN, with notable advantages. Particularly, it achieves 2.9\\%, 4.8\\%, 6.5\\% relative improvements over the most competitive baselines (underlined) on each of the experimental datasets. Such an observation indicates that the relationship between the nodes can be captured more accurately based on the node embeddings generated by GraphFormers, which verifies the effectiveness of our proposed method. \n\nWe also observe the following underlying factors that may influence the representation quality. \n\nFirstly, the effective utilization of neighbourhood information is critical. With the joint consideration of the center node and neighbour nodes, the PLM+GNNs methods, including GraphFormers and the cascaded Transformers-GNN baselines, significantly outperform the PLM only baseline in most of the time. We further analyze the impact of neighbourhood size as Table \\ref{tab:exp-neighbour}, with a fraction of neighbour nodes randomly sampled for each center node (using DBLP for illustration). \nIt can be observed that both GraphFormers and PLM+Max (the most competitive baseline) achieve higher prediction accuracy than the PLM only method (P@1:0.5673, NDCG:0.7484, MRR:0.6777, as reported in Table \\ref{tab:exp-main}), even with fewer neighbour nodes included. With the increasing number of neighbour nodes, the advantages become gradually enlarged. However, the marginal gain is vanishing, as the relative improvement becomes smaller when more neighbours are included. In all the testing cases, GraphFormers maintain consistent advantages over PLM+Max, which reaffirms the effectiveness of our proposed methods.\n\nSecondly, the capacity of the text encoder is crucial for textual graph representation. All the pretrained language model based methods (GraphFormers, Cascaded Transformers-GNN baselines, PLM-only baseline) significantly outperform the baselines with simplified text encoders (TNVE, IFTN).\n\nThirdly, the representation quality is also sensitive to the form of graph aggregator. In Product, the cascaded Transformers-GNN baselines' performances are quite close to each other. In DBLP, PLM+(Max, Mean, Att) outperforms PLM+GAT. In Wiki, not only PLM+(Max, Mean, Att) but also PLM-only baseline outperform PLM+GAT. Such phenomenons could be attributed to the type of graph: whether it is homogeneous or heterogeneous. Particularly, both Product and DBLP can be regarded as homogeneous graphs as the nodes are connected based on the same relationships; i.e., co-view relationship in Product, and citation relationship in DBLP. In both homogeneous graphs, the connected nodes may have quite similar semantics (the co-viewed products usually serve similar user intents, and the citation relationships usually indicate similar research topics); thus, the incorporated neighbour nodes will probably provide complementary information for the link prediction between the center nodes. \nHowever, Wiki is a heterogeneous graph, where the connections between entities may have highly different semantics. As a result, the incorporation of neighbour nodes may not contribute to the link prediction task, especially when the incorporated neighbours and the prediction target are connected to the center nodes with totally different relationships. Considering that GAT tends to focus more on the neighbourhood, its performance can be vulnerable in such unfavorable situations. These findings suggest that the neighbourhood information should be properly handled in case that the information of the center node is wiped out.\n\nFinally, we may conclude different methods' utility in textual graph representation: \\textit{simplified text encoders} $\\prec$ \\textit{PLMs} $\\prec$ \\textit{Cascaded Transformers-GNN} $\\prec$ \\textit{GNNs-nested Transformers}. Such findings are consistent with our expectation that the precise modeling of individual textual feature and the effective integration of neighbourhood information will jointly contribute to high-quality textual graph representation. GraphFormers enjoy the high expressiveness of PLMs and leverage layerwise nested-GNNs to facilitate graph aggregation, which contributes to both of the above perspectives.\n\n\\renewcommand{\\arraystretch}{1.3}\n\n\n% \\vspace{-10pt}\n"
                },
                "subsection 4.4": {
                    "name": "Ablation Studies",
                    "content": "\nThe ablation studies (as Table \\ref{tab:exp-abl}) are performed to clarify the following issues: 1) the impact of two-stage progressive learning, and 2) the impact of unidirectional-simplified GraphFormers.\n\nFirstly, the two-stage progressive learning substantially improves GraphFormers' representation quality. Without such a training strategy (\"-Progressive\": training directly on the original data), the model's performance is decreased by 0.98\\%, 1.71\\%, and 1.18\\% in each of the datasets, respectively. \n\nSecondly, the performances between simplified and non-simplified (``-Simplified'') GraphFormers are comparable. In fact, the necessity of graph aggregation is not equivalent for the center node and the neighbour nodes: since the center node is the one for representation, it is much more important to ensure that the center node may extract complementary information from its neighbours. The unidirectional-simplified GraphFormers maintain such a property; thus, there is little impact on the final performances. Such a finding affirms that we may safely leverage the simplified model to save the cost of repetitively encoding the existing neighbours.\n\nWe make two additional ablation studies. ``-Shared GNNs'': the GNNs parameters sharing is disabled, where each layer maintains its own graph aggregator (by default, the layerwise GNN components in GraphFormers share the same set of parameters). ``-Position'': the learnable position bias ($\\mathbf{b}$ in Eq. \\ref{eq:1}) is disabled in GNNs. We find that model's performance is little affected from the above changes. \n\n\n"
                },
                "subsection 4.5": {
                    "name": "Efficiency Analysis",
                    "content": "\\label{sec:efc}\n\n% \\renewcommand{\\arraystretch}{1.3}\n\n\nWe compare the time efficiency between GNN-nested Transformers (GraphFormers) and Cascaded Transformers+GNN (using PLM+Max for comparison). The evaluation is made with a Nvidia P100 GPU. Each mini-batch contains 32 encoding instances; each instance contains one center and \\#N neighbour nodes; the token length of each node is 16. We report the average time and memory (GPU RAM) costs per mini-batch as Table \\ref{tab:exp-time}.\n\nFirstly, the time and memory costs of both methods grow linearly with the increment of neighbours. (There are overheads of time and memory costs. The time cost overhead may come from CPU processing; while the memory cost overhead is mainly due to the model parameters \\citep{rajbhandari2020zero}). We may approximately remove the overheads by deducting the time and memory costs where \\#N=3). Such a finding is consistent with our theoretical analysis in Section \\ref{sec:gnlm}.\n\nSecondly, the overall time and memory costs of GraphFormers are quite close to PLM+Max. When the number of neighbour nodes is small, the differences between both methods are almost ignorable. The differences become slightly larger when more neighbour nodes are included, because the layerwise graph aggregations in GraphFormers get increasingly time consuming. However, the differences are still relatively small: merely around 3.5\\% of the overall running costs when \\#N is increased to 200 (``\\#N=200'' is already more than enough for most of the real world scenarios).\n\nBased on the above observations, we may conclude that GraphFormers are more accurate, meanwhile equally efficient and scalable as the conventional cascaded Transformer+GNNs.\n\n"
                },
                "subsection 4.6": {
                    "name": "Online A/B Test on Bing Search",
                    "content": "\nGraphFormers has been deployed as one of the major ads retrieval algorithms on Bing Search, and it achieves highly competitive performance against the previous production system (the combination of a wide spectrum of semantic representation algorithms, including large-scale PLMs and cascaded PLMs-GNNs). Particularly, the primary objective of Ads service is to maximize the revenue meanwhile increasing the user clicks. Therefore, the following three metrics are taken as the major performance indicators: RPM\\footnote{\\scriptsize https://support.google.com/adsense/answer/190515?hl=en} (revenue per thousand impressions), CY (click yield), and CPC\\footnote{\\scriptsize https://support.google.com/google-ads/answer/116495?hl=en} (cost per click) . During our large-scale online A/B test, GraphFormers significantly improves the overall RPM, CY, CPC by 1.87\\%, 0.96\\% and 0.91\\%, respectively. A 11-day performance snapshot is demonstrated as Figure \\ref{fig:online}; it can be observed that in most of the time, all three metrics are significantly improved thanks to the utilization of GraphFormers (the daily performance are measured based on millions of impressions, thus having strong statistic significance).  \n\n\n\n\n% \\vspace{-5pt}\n"
                }
            },
            "section 5": {
                "name": "Conclusion",
                "content": "\nIn this paper, we propose a novel model architecture GraphFormers for textual graph representation. By having GNNs nested alongside each transformer layer of the pretrained language model, the underlying semantic of each textual node can be precisely captured and effectively integrated for high-quality textual graph representation. On top of the fundamental architecture, \nwe introduce the two-stage progressive training strategy to further strengthen GraphFormers' representation quality; we also simplify the model with the unidirectional graph aggregation, which eliminates the unnecessary computation cost. The experimental studies on three large-scale textual graph datasets verify the effectiveness of our proposed methods, where GraphFormers notably outperform the existing cascaded Transformer-GNNs methods with comparable running efficiency and scalability.\n\n"
            },
            "section 6": {
                "name": "Acknowledgement",
                "content": "\nWe are grateful to anonymous reviewers for their constructive comments on this work. The work was supported by grants from the National Natural Science Foundation of China (No. 62022077).\n\n% \\textbf{Limitations.} The current work is limited to a certain scope: it does not take the edge information into account; and it is only used for the textual graphs, rather than general graphs with rich attribute features. We'll continue to improve the generalizability of our work in the future.\n\n\n\\bibliographystyle{acl_natbib}\n\\bibliography{Camera_ready}\n\n\\newpage\n\n\\definecolor{codegreen}{rgb}{0.3,0.5,0.0}\n\\lstset{ %\n  language=python,               \n  basicstyle=\\fontsize{9pt}{10pt}\\ttfamily\\selectfont,\n  backgroundcolor=\\color{white},     \n  columns=fullflexible,\n%   frame=single,                   \n  rulecolor=\\color{black},       \n  captionpos=b,                   \n  breaklines=true,      \n  keywordstyle=\\bfseries,          \n  commentstyle=\\fontsize{5pt}{5pt}\\color{codegreen}\n}\n\n\n\n\n\n\n% \\bibliographystyle{acl_natbib}\n% \\bibliography{acl2021}\n\n\n\\appendix\n\n"
            },
            "section 7": {
                "name": "Implementation Details",
                "content": "\n\n\n\n\n",
                "subsection 7.1": {
                    "name": "Masking Strategy",
                    "content": "\n\n% \\setlength{\\textfloatsep}{10pt}\n% \\begin{algorithm}[h]\n% \\caption{MLM Strategy for Pre-Training}\\label{alg:mlm}\n%     \\LinesNumbered \n%     \\KwIn{$x=\\left[{x_1,...,x_{|x|}}\\right]$: Input sequence.}\n% \t\\KwOut{$x'=\\left[{x'_1,...,x'_{|x|}}\\right]$: Masked sequence.}\n%     \\Begin{\n%         $x'\\leftarrow x$; \\\\\n%         $index\\leftarrow$ random\\_shuffle($\\left[{1,...,|x|}\\right]$);\\\\\n%         \\Repeat{$15\\%$ of $x$ have been masked}\n%         {\n%             \\Repeat{$l\\leq 10$}{$l\\leftarrow Geo(p=0.2);$}\n%             $span_{left}\\leftarrow index$.pop();\\\\\n%             \\For{$i=span_{left},...,min(span_{left}+l-1,|x|$)}\n%             {\n%                 \\If{$x_i$ has not been masked}\n%                 {\n%                     $r\\leftarrow$ rand();\\\\\n%                     \\If {$r<0.8$}\n%                     {\n%                         $x'_i\\leftarrow$ [MASK];\n%                     }\n%                     \\ElseIf {$r<0.9$}\n%                     {\n%                         $x'_i\\leftarrow$ random token;\n%                     }\n%                     \\Else{$x'_i\\leftarrow x_i$;}\n%                 }\n%             }\n%         }\n%         Return $x'$\\;\n%     }\n% \\end{algorithm}\nWe use span masking \\citep{joshi2020spanbert} as our masking strategy. For each iteration, we sample and mask a span of text, until the ratio of masked tokens has reached the threshold. We follow the settings in \\citep{joshi2020spanbert}. The span length $l$ is generated from a geometric distribution $l\\sim Geo(p)$, where $p$ is set to 0.2 and $l$ is clipped at $l_{max}=10$. As in BERT \\citep{devlin2018bert}, 15\\% of the input tokens will be masked: 80\\% of them are replaced by [MASK], 10\\% are replaced by random tokens and 10\\% are kept as the original tokens.\n\n"
                },
                "subsection 7.2": {
                    "name": "GraphFormers’ Workflow",
                    "content": "\n\nAlgorithm \\ref{alg:graphformers} provides the pseudo-code of GraphFormers' workflow. We use original Multi-Head Attention in the first Transformer layer ($\\mathrm{Transformers[0]}$), and asymmetric Multi-Head Attention in the rest Transformer layers ($\\mathrm{Transformers[1..L-1]}$). In original Multi-Head Attention, $\\mathbf{Q}$, $\\mathbf{K}$, $\\mathbf{V}$ are computed as:  \n\\begin{equation}\n\\begin{gathered}\n\\mathbf{Q} = \\mathbf{{H}}^l_g\\mathbf{W}_{j}^Q; ~ \\mathbf{K} = \\mathbf{H}^l_g\\mathbf{W}_{j}^K; ~ \\mathbf{V} = \\mathbf{H}^l_g\\mathbf{W}_{j}^V.\n\\end{gathered}\n\\end{equation}\nIn asymmetric Multi-Head Attention, $\\mathbf{Q}$, $\\mathbf{K}$, $\\mathbf{V}$ are computed as:  \n\\begin{equation}\n\\begin{gathered}\n\\mathbf{Q} = \\mathbf{{H}}^l_g\\mathbf{W}_{j}^Q; ~ \\mathbf{K} = \\widehat{\\mathbf{H}}^l_g\\mathbf{W}_{j}^K; ~ \\mathbf{V} = \\widehat{\\mathbf{H}}^l_g\\mathbf{W}_{j}^V.\n\\end{gathered}\n\\end{equation}\nIn the above equations, $\\mathbf{{H}}^l_g$ are token-level embeddings, $\\widehat{\\mathbf{H}}^l_g$ are graph-augmented token-level embeddings, and $\\mathbf{W}_{j}^Q$, $\\mathbf{W}_{j}^K$, and $\\mathbf{W}_{j}^V$ are the projection matrices of Multi-Head Attention, corresponding to the $j$-th attention head.\n\nIn each step, we extract the embeddings of [CLS] tokens as node-level embeddings $\\mathbf{Z}^l_g$. The node-level embeddings $\\mathbf{Z}^l_g$ and a learnable bias vector $\\mathbf{b}$ are processed by the GNN component, which is a Multi-Head Attention layer. The output GNN-processed node-level embeddings $\\mathbf{\\hat{Z}}^l_g$ are concatenated with the original token-level embeddings $\\mathbf{H}^l_g$, which generates the graph-augmented token-level embeddings $\\widehat{\\mathbf{H}}^l_g$. Then $\\widehat{\\mathbf{H}}^l_g$ are processed by the Transformer component using asymmetric Multi-Head Attention. At last, the node-level embedding of the center node $\\mathbf{h}_x$ is returned as the representation of the graph.\n\n\\begin{algorithm}[h]\n\\begin{lstlisting}\n# Input:\n# Hg[0]: initial token-level embeddings (summation of word embeddings and position embeddings)\n# Output:\n# hx: output embeddings\n\n# B: batch size\n# N: number of nodes in the graph (0th node represents the center node)\n# SL: sequence length\n# D: hidden dimension\n# L: number of GNN-nested Transformer layers\n# b: learnable bias vector for nodes\n\n# token-level embeddings: BxNxSLxD \nHg[1] = Transformers[0](Hg[0].view(B * N, SL, D), asymmetric = False).view(B, N, SL, D) # \"asymmetric = False\" means we use original Multi-Head Attention in the Transformer\n\nfor l in range(1, L):\n    \n    # node-level embeddings: BxNxD\n    Zg[l] = Hg[l][:, :, 0]\n    \n    # GNN-processed node-level embeddings: BxNxD\n    Zg_hat[l] = MultiHeadAttention(Zg[l], b)\n\n    # graph-augmented token-level embeddings: BxNx(SL+1)xD\n    Hg_hat[l] = Concat([Zg_hat[l][:, :, None, :], Hg[l]], dim = 2)\n    \n    # token-level embeddings: BxNxSLxD    \n    Hg[l + 1] = Transformers[l](Hg_hat[l].view(B * N, SL + 1, D), asymmetric = True).view(B, N, SL, D) # \"asymmetric = True\" means we use asymmetric Multi-Head Attention in the Transformer\n\n# graph representations: BxD\nhx = Hg[L][:, 0, 0, :]\n\nreturn hx\n\n\n\n\\end{lstlisting}\n\\caption{GraphFormers’ Workflow in PyTorch-Like Style}\\label{alg:graphformers}\n\\end{algorithm}\n\n"
                }
            },
            "section 8": {
                "name": "Training Details",
                "content": "\n\nAs shown in Table \\ref{tab:training paras}, we present the hyperparameters used for training GraphFormers. The model is trained for at most 100 epochs on all datasets.\nFor the stability of the training process, we optimally tune the learning rate as 1$e{-5}$ for Product, 1$e{-6}$ for DBLP, and 5$e{-6}$ for Wiki. We use an early stopping strategy on P@1 with a patience of 2 epochs and Adam \\citep{kingma2014adam} with $\\beta_1$=0.9, $\\beta_2$=0.999, $\\epsilon$=1e-8 for optimization. We pad the sequence length to 32 for Product and DBLP, 64 for Wiki, depending on different text length of each dataset. To make full use of the GPU memory, we set the batch size as 240 for Product and DBLP, 160 for Wiki. Each training sample includes 12 nodes: 1 query with its 5 neighbours, and 1 keyword with its 5 neighbours. The training is on $8\\times$ Nvidia V100-16GB GPU clusters. The training of GraphFormers takes 58.8, 117.6, 151.2 hours on average to converge on each of the experimental datasets (Product, DBLP, Wiki). We use Python3.6 and PyTorch 1.6.0 for implementation. The random seeds of PyTorch and NumPy are fixed as 42. For two-stage training, the training processes of the two stages share the same settings as above.\n\n\n\n\n"
            }
        },
        "tables": {
            "tab:dataset": "\\begin{table*}\n    \\centering\n    % \\footnotesize\n    \\caption{Specifications of the experimental datasets: the number of items, the number of neighbour nodes on average, and the number of training, validation, testing cases.}\n    \\scriptsize\n    \\begin{tabular}{p{1.0cm} p{1.4cm} p{1.4cm} p{1.4cm}}\n    \\ChangeRT{1pt}\n        & \\textbf{Product} & \\textbf{DBLP} & \\textbf{Wiki} \\\\\n        \\hline\n        \\#Item & 5,643,688 & 4,894,081 & 4,818,679 \\\\\n        \\#N & 4.71 & 9.31 & 8.86 \\\\\n        \\#Train & 22,146,934 & 3,009,506 & 7,145,834 \\\\\n        \\#Valid & 30,000 & 60,000 & 66,167 \\\\\n        \\#Test & 306,742 & 100,000 & 100,000 \\\\\n    \\ChangeRT{1pt}\n    \\end{tabular}\n    \\label{tab:dataset}\n    % \\vspace{-10pt}\n\\end{table*}",
            "tab:exp-main": "\\begin{table*}[t]\n    \\centering\n    % \\footnotesize\n    \\caption{Overall evaluation (GraphFormers marked in bold, the best baseline underlined). GraphFormers outperforms all baselines, especially the ones based on cascaded Transformers-GNN.}\n    \\scriptsize\n    \\begin{tabular}{p{1.7cm}  C{0.9cm} C{0.9cm} C{0.9cm}  C{0.9cm} C{0.9cm} C{0.9cm}  C{0.9cm} C{0.9cm} C{0.9cm} }\n    \\ChangeRT{1pt}\n    & \\multicolumn{3}{c}{\\textbf{Product}} & \\multicolumn{3}{c}{\\textbf{DBLP}} & \\multicolumn{3}{c}{\\textbf{Wiki}}\n    \\\\\n    \\cmidrule(lr){1-1}\n    \\cmidrule(lr){2-4}\n    \\cmidrule(lr){5-7}\n    \\cmidrule(lr){8-10}\n         {Methods} & {P@1} & {NDCG} & {MRR} & {P@1} & {NDCG} & {MRR} & {P@1} & {NDCG} & {MRR} \\\\\n    \\hline\n       PLM & 0.6563 & 0.7911 & 0.7344 & 0.5673 & 0.7484 & 0.6777 & 0.3466 & 0.5799 & 0.4712  \\\\\n       TNVE & 0.4618 & 0.6204 & 0.5364 & 0.2978 & 0.5295 & 0.4163 & 0.1786 & 0.4274 & 0.2933 \\\\\n       IFTN & 0.5233 & 0.6740 & 0.5982 & 0.3691 & 0.5798 & 0.4773 & 0.1838 & 0.4276 & 0.2945 \\\\\n       PLM+GAT  & 0.7540 & 0.8637 & 0.8232 & 0.6633 & 0.8204 & 0.7667 & 0.3006 & 0.5430 & 0.4270  \\\\\n       PLM+Max & \\underline{0.7570} & \\underline{0.8678} & \\underline{0.8280} & \\underline{0.6934} & \\underline{0.8386} & \\underline{0.7900} & \\underline{0.3712} & \\underline{0.6071} & \\underline{0.5022} \\\\\n       PLM+Mean & 0.7550 & 0.8671 & 0.8271 & 0.6896 & 0.8359 & 0.7866 & 0.3664 & 0.6037 & 0.4980  \\\\\n       PLM+Att & 0.7513 & 0.8652 & 0.8246 & 0.6910 & 0.8366 & 0.7875 & 0.3709 & 0.6067 & 0.5018 \\\\\n       \\hline\n       GraphFormers & \\textbf{0.7786} & \\textbf{0.8793} & \\textbf{0.8430} & \\textbf{0.7267} & \\textbf{0.8565} & \\textbf{0.8133} & \\textbf{0.3952} & \\textbf{0.6230} & \\textbf{0.5220} \\\\\n    \\ChangeRT{1pt}\n    \\end{tabular}\n\n    \\label{tab:exp-main}\n    % \\vspace{-10pt}\n\\end{table*}",
            "tab:exp-neighbour": "\\begin{table*}\n    \\centering\n    \\caption{Impact of neighbour size (\\#N).}\n    \\scriptsize\n    \\begin{tabular}{p{0.2cm}  C{0.7cm} C{0.7cm} C{0.7cm} C{0.7cm} C{0.7cm} C{0.7cm} }\n    \\ChangeRT{1pt}\n    & \\multicolumn{3}{c}{\\textbf{GraphFormers}} & \\multicolumn{3}{c}{\\textbf{PLM+Max}} \n    \\\\\n    \\cmidrule(lr){1-1}\n    \\cmidrule(lr){2-4}\n    \\cmidrule(lr){5-7}\n         {\\#N} & {P@1} & {NDCG} & {MRR} & {P@1} & {NDCG} & {MRR} \\\\\n    \\hline\n        1 & 0.6485 & 0.8087 & 0.7522 & 0.6249 & 0.7946 & 0.7342  \\\\\n        2 & 0.6841 & 0.8308 & 0.7804 & 0.6538 & 0.8137 & 0.7583  \\\\\n        3 & 0.6980 & 0.8396 & 0.7916 & 0.6728 & 0.8256 & 0.7734  \\\\\n        4 & 0.7126 & 0.8485 & 0.8029 & 0.6823 & 0.8319 & 0.7814  \\\\\n        5 & 0.7267 & 0.8565 & 0.8133 & 0.6934 & 0.8386 & 0.7900  \\\\\n    \\ChangeRT{1pt}\n    \\end{tabular}\n\n    \\label{tab:exp-neighbour}\n    % \\vspace{-5pt}\n\\end{table*}",
            "tab:exp-abl": "\\begin{table*}[t]\n    \\centering\n    \\caption{Ablation Studies (The top ablated methods are marked in bold; ``$\\uparrow$''/``$\\downarrow$'': the performance is increased/decreased compared with the default setting). ``-Progressive'': two-stage progressive learning disabled; ``-Simplified'': unidirectional simplification disabled; ``-Shared GNNs'': GNNs parameters are not shared across the layers; ``-Position'': GNNs learnable position bias disabled.}\n    \\scriptsize\n    \\begin{tabular}{p{1.5cm}  C{0.9cm} C{0.9cm} C{0.9cm}  C{0.9cm} C{0.9cm} C{0.9cm}  C{0.9cm} C{0.9cm} C{0.9cm}}\n    \\ChangeRT{1pt}\n    & \\multicolumn{3}{c}{\\textbf{Product}} & \\multicolumn{3}{c}{\\textbf{DBLP}} & \\multicolumn{3}{c}{\\textbf{Wiki}}\n    \\\\\n    \\cmidrule(lr){1-1}\n    \\cmidrule(lr){2-4}\n    \\cmidrule(lr){5-7}\n    \\cmidrule(lr){8-10}\n        {Methods} & {P@1} & {NDCG} & {MRR} & {P@1} & {NDCG} & {MRR} & \\textbf{P@1} & {NDCG} & {MRR} \\\\\n    \\hline\n       GraphFormers & \\underline{0.7786} & \\underline{0.8793} & \\underline{0.8430} & \\underline{0.7267} & \\underline{0.8565} & \\underline{0.8133} & \\underline{0.3952} & \\underline{0.6230} & \\underline{0.5220}  \\\\\n       PLM+Max & {0.7570} & {0.8678} & {0.8280} & {0.6934} & {0.8386} & {0.7900} & {0.3712} & {0.6071} & {0.5022} \\\\\n       \\hline\n       - Progressive & 0.7688 & 0.8751 & 0.8373 & 0.7096 & 0.8468 & 0.8007 & 0.3834 & 0.6155 & 0.5127  \\\\\n       - Simplified & \\textbf{0.7795} $\\uparrow$ & \\textbf{0.8798} $\\uparrow$ & \\textbf{0.8436} $\\uparrow$ & 0.7225 & 0.8542 & 0.8102 & 0.3923 & {0.6209} & {0.5195}  \\\\\n       - Shared GNNs & 0.7788 & 0.8795 & 0.8433 & 0.7256 & 0.8558 & 0.8123 & \\textbf{0.3945} $\\downarrow$ & \\textbf{0.6221} $\\downarrow$ & \\textbf{0.5211} $\\downarrow$ \\\\\n       - Position & 0.7788 & 0.8795 & 0.8434 & \\textbf{0.7276} $\\uparrow$ & \\textbf{0.8570} $\\uparrow$ & \\textbf{0.8139} $\\uparrow$ & 0.3942 & 0.6222 & 0.5211 \\\\\n    \\ChangeRT{1pt}\n    \\end{tabular}\n    \n    % \\vspace{-5pt}\n    \\label{tab:exp-abl}\n\\end{table*}",
            "tab:exp-time": "\\begin{table*}\n    \\centering\n    \\caption{Time and memory costs per mini-batch for PLM+Max and GraphFormers, with neighbour size increased from 3 to 200. GraphFormers achieve similar efficiency and scalability as PLM+Max.}\n    \\scriptsize\n    \\begin{tabular}{p{2.2cm} p{1.2cm} p{1.2cm} p{1.2cm} p{1.2cm} p{1.2cm} p{1.2cm} p{1.2cm}}\n    \\ChangeRT{1pt} \n        \\#N & 3 & 5 & 10 & 20 & 50 & 100 & 200 \\\\\n    \\hline\n        Time: PLM+Max & 60.29 ms & 93.41 ms & 161.40 ms & 295.92 ms & 684.16 ms & 1357.93 ms & 2706.35 ms \\\\\n        Time: GraphFormers & 63.95 ms & 97.19 ms & 170.16 ms & 306.12 ms & 714.32 ms & 1411.09 ms & 2801.67 ms \\\\ \n    \\hline\n        Mem: PLM+Max & 1.33 GiB & 1.39 GiB & 1.55 GiB & 1.82 GiB & 2.67 GiB & 4.09 GiB & 6.92 GiB \\\\\n        Mem: GraphFormers & 1.33 GiB & 1.39 GiB & 1.55 GiB & 1.83 GiB & 2.70 GiB & 4.28 GiB & 7.33 GiB \\\\ \n    \\ChangeRT{1pt}\n    \\end{tabular}\n    \\label{tab:exp-time}\n    % \\vspace{-5pt}\n\\end{table*}",
            "tab:training paras": "\\begin{table}[h]\n\t\\centering\n\t\\caption{Hyperparameters for training GraphFormers}\n\t\\begin{tabular}{cccc}\n\t\t\\toprule\n\t\tOptimizer&\\multicolumn{3}{c}{Adam} \\\\ \n\t\tAdam $\\beta_1$& \\multicolumn{3}{c}{0.9}  \\\\\n\t\tAdam $\\beta_2$& \\multicolumn{3}{c}{0.999} \\\\\n\t\tAdam $\\epsilon$&\\multicolumn{3}{c}{1e-8} \\\\\n\t\tPyTorch random seed &\\multicolumn{3}{c}{42} \\\\\n\t\tNumPy random seed &\\multicolumn{3}{c}{42} \\\\\n        \\cmidrule(lr){1-4}\n\t\t\t& Product & DBLP & Wiki \\\\ \n\t\tMax training epochs & 100 & 100 & 100 \\\\ \n\t\tLearning rate & 1e-5&1e-6&5e-6  \\\\\n\t\tSequence length&32&32&64\\\\\n\t\tBatch size & 240&240&160\\\\\n\t\t\\bottomrule\n\t\\end{tabular}\n\t\\label{tab:training paras}\n\\end{table}"
        },
        "figures": {
            "fig:1": "\\begin{figure}[t]\n\\centering\n\\includegraphics[width=1.0\\columnwidth]{Figures/architect.pdf}\n\\caption{Model architecture comparison (a center node C is connected with two neighbours N1, N2). (A) Cascaded Transformers-GNN: text embeddings are independently generated by language models and aggregated by rear-mounted GNNs. (B) GNN-nested Transformers: the text encoding and graph aggregation are iteratively performed with the layerwise GNNs and Transformers (TRM).}\n\\label{fig:1}\n\\end{figure}",
            "fig:3": "\\begin{figure*}[t]\n\\centering\n\\includegraphics[width=1.05\\textwidth]{Figures/mainframe.pdf}\n\\caption{GNN-nested Transformers (using the $l$-th layer for illustration). The graph aggregation is performed in the first place: the node-level embeddings $\\{\\mathbf{z}^l_g\\}_G$ are gathered from all the nodes and processed by the GNN component (the leftmost rectangle). The GNN processed node-level embeddings $\\{\\mathbf{\\hat{z}}^l_g\\}_G$ are dispatched to their original nodes, which forms the graph-augmented token-level embeddings. The graph-augmented token-level embeddings are further encoded by Transformer.}\n\\label{fig:3}\n\\end{figure*}",
            "fig:online": "\\begin{figure*}[t]\n\\centering\n\\includegraphics[width=1.0\\textwidth]{Figures/online_exp2.pdf}\n\\caption{Online A/B Test: the relative improvements of RPM, CY and CPC against the last version of production system in Bing Search (green: positive; blue: negative). In most of the time, all three performance indicators are significantly improved thanks to the utilization of GraphFormers.}\n\\label{fig:online}\n\\end{figure*}"
        },
        "equations": {
            "eq:eq:1": "\\begin{equation}\\label{eq:1}\n\\begin{gathered}\n\\mathbf{\\hat{Z}}^l_G = \\mathrm{MHA}(\\mathbf{Z}^l_G); \n\\\\\n\\mathrm{MHA}(\\mathbf{Z}^l_G) = \\mathrm{Concat}(\\mathbf{head}_{1}, ... ,\\mathbf{head}_{h}); \n\\\\\n\\mathbf{head}_{j} = \\mathrm{softmax}(\\frac{\\mathbf{QK^T}}{\\sqrt{d}}+\\mathbf{B})\\mathbf{V};\n\\\\\n\\mathbf{Q} = \\mathbf{Z}^l_G\\mathbf{W}_{j}^Q; ~ \\mathbf{K} = \\mathbf{Z}^l_G\\mathbf{W}_{j}^K; ~ \\mathbf{V} = \\mathbf{Z}^l_G\\mathbf{W}_{j}^V; \n\\end{gathered}\n\\end{equation}",
            "eq:1": "\\begin{equation}\n    \\widehat{\\mathbf{H}}^l_g \\leftarrow \\mathrm{Concat}(\\mathbf{\\hat{z}}^l_g, \\mathbf{H}^l_g).\n\\end{equation}",
            "eq:2": "\\begin{equation}\n\\begin{gathered}\n     \\widehat{\\mathbf{H}}^l_g = \\mathrm{LN}(\\mathbf{{H}}^l_g + \\mathrm{MHA}^{asy}(\\widehat{\\mathbf{H}}^l_g)); \\\\\n     \\mathbf{H}^{l+1}_g = \\mathrm{LN}(\\widehat{\\mathbf{H}}^l_g + \\mathrm{MLP}(\\widehat{\\mathbf{H}}^l_g)).\n\\end{gathered}\n\\end{equation}",
            "eq:3": "\\begin{equation}\n\\begin{gathered}\n\\mathbf{Q} = \\mathbf{{H}}^l_g\\mathbf{W}_{j}^Q; ~ \\mathbf{K} = \\widehat{\\mathbf{H}}^l_g\\mathbf{W}_{j}^K; ~ \\mathbf{V} = \\widehat{\\mathbf{H}}^l_g\\mathbf{W}_{j}^V.\n\\end{gathered}\n\\end{equation}",
            "eq:eq:5": "\\begin{equation}\\label{eq:5}\n\\mathbf{H}^{l+1}_{g} = \n\\begin{cases}\n\\mathrm{TRM}^l(\\widehat{\\mathbf{H}^l_x}), ~ g = x; \\\\\n\\mathrm{TRM}^l(\\mathbf{H}^l_g), ~ \\forall g \\in N_x. \n\\end{cases}\n\\end{equation}",
            "eq:eq:3": "\\begin{equation}\\label{eq:3}\n\\begin{gathered}\n\\mathcal{L} = - \\log \\frac{\\exp(\\langle\\mathbf{h}_q,\\mathbf{h}_k\\rangle)}{\\exp(\\langle\\mathbf{h}_q,\\mathbf{h}_k\\rangle) + \\sum_{r \\in R} \\exp(\\langle\\mathbf{h}_q,\\mathbf{h}_{r}\\rangle) }.\n\\end{gathered}\n\\end{equation}",
            "eq:eq:6-1": "\\begin{equation}\\label{eq:6-1}\n\\begin{gathered}\n\\mathcal{L}' = - \\log \\frac{\\exp(\\langle\\mathbf{h}_{\\tilde{q}},\\mathbf{h}_{\\tilde{k}}\\rangle)}{\\exp(\\langle\\mathbf{h}_{\\tilde{q}},\\mathbf{h}_{\\tilde{k}}\\rangle) + \\sum_{r \\in R} \\exp(\\langle\\mathbf{h}_{\\tilde{q}},\\mathbf{h}_{\\tilde{r}}\\rangle)},\n\\end{gathered}\n\\end{equation}",
            "eq:4": "\\begin{equation}\n\\begin{gathered}\n\\mathbf{Q} = \\mathbf{{H}}^l_g\\mathbf{W}_{j}^Q; ~ \\mathbf{K} = \\mathbf{H}^l_g\\mathbf{W}_{j}^K; ~ \\mathbf{V} = \\mathbf{H}^l_g\\mathbf{W}_{j}^V.\n\\end{gathered}\n\\end{equation}"
        },
        "git_link": "https://github.com/microsoft/GraphFormers"
    }
}