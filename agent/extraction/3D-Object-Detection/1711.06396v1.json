{
    "meta_info": {
        "title": "VoxelNet: End-to-End Learning for Point Cloud Based 3D Object Detection",
        "abstract": "Accurate detection of objects in 3D point clouds is a central problem in many\napplications, such as autonomous navigation, housekeeping robots, and\naugmented/virtual reality. To interface a highly sparse LiDAR point cloud with\na region proposal network (RPN), most existing efforts have focused on\nhand-crafted feature representations, for example, a bird's eye view\nprojection. In this work, we remove the need of manual feature engineering for\n3D point clouds and propose VoxelNet, a generic 3D detection network that\nunifies feature extraction and bounding box prediction into a single stage,\nend-to-end trainable deep network. Specifically, VoxelNet divides a point cloud\ninto equally spaced 3D voxels and transforms a group of points within each\nvoxel into a unified feature representation through the newly introduced voxel\nfeature encoding (VFE) layer. In this way, the point cloud is encoded as a\ndescriptive volumetric representation, which is then connected to a RPN to\ngenerate detections. Experiments on the KITTI car detection benchmark show that\nVoxelNet outperforms the state-of-the-art LiDAR based 3D detection methods by a\nlarge margin. Furthermore, our network learns an effective discriminative\nrepresentation of objects with various geometries, leading to encouraging\nresults in 3D detection of pedestrians and cyclists, based on only LiDAR.",
        "author": "Yin Zhou, Oncel Tuzel",
        "link": "http://arxiv.org/abs/1711.06396v1",
        "category": [
            "cs.CV"
        ]
    },
    "latex_extraction": {
        "content": {
            "section 1": {
                "name": "Introduction",
                "content": "\n\n\n\n\n\nPoint cloud based 3D object detection is an important component of a variety of real-world applications, such as autonomous navigation~\\cite{REF:Geiger2012CVPR,REF:Drone}, housekeeping robots~\\cite{REF:Housekeeping}, and augmented/virtual reality~\\cite{REF:AR}. Compared to image-based detection, LiDAR provides reliable depth information that can be used to accurately localize objects and characterize their shapes~\\cite{REF:3DFCN, REF:cvpr17chen}. However, unlike images,  LiDAR point clouds are sparse and have highly variable point density, due to factors such as non-uniform sampling of the 3D space, effective range of the sensors, occlusion, and the relative pose. To handle these challenges, many approaches manually crafted feature representations for point clouds that are tuned for 3D object detection. Several methods project point clouds into a perspective view and apply image-based feature extraction techniques~\\cite{REF:FusionDPM-IROS14, REF:MV-RGBD-RF2015,REF:VeloFCN}. Other approaches rasterize point clouds into a 3D voxel grid and encode each voxel with hand-crafted features~\\cite{REF:Wang-RSS-15,REF:Vote3Deep,REF:Song2014,REF:DeepSlidingShapes,REF:3DFCN,REF:cvpr17chen}. However, these manual design choices introduce an information bottleneck that prevents these approaches from effectively exploiting 3D shape information and the required invariances for the detection task.  A major breakthrough in recognition~\\cite{REF:NIPS2012_4824} and detection~\\cite{REF:girshick2014rich} tasks on images was due to moving from hand-crafted features to machine-learned features.\n\n% Several methods projected point clouds onto a perspective view and \\cite{REF:FusionDPM-IROS14, REF:MV-RGBD-RF2015} extracted descriptors that were commonly used for images, such as HOG or LBP, while \\cite{REF:VeloFCN} used the cylindrical coordinates. Other approaches rasterized point clouds into a 3D voxel grid. More concretely, \\cite{REF:Wang-RSS-15, REF:Vote3Deep} encoded each nonempty voxel with 6 statistical quantities derived from all the residing points. \\cite{REF:DeepSlidingShapes} computed the truncated signed distance on the voxel grid. \\cite{REF:3DFCN} used binary encoding for the 3D voxel grid. \\cite{REF:cvpr17chen} proposed a multi-view representation for a LiDAR point cloud, by computing the multi-channel feature map in the bird's eye view and the cylindral coordinates in the frontal view. However, these manual design choices introduce an information bottleneck that prevents these approaches from effectively exploiting 3D shape information and required invariances for the detection task.  A major breakthrough in recognition~\\cite{REF:NIPS2012_4824} and detection~\\cite{REF:girshick2014rich} tasks on images was due to moving from hand-designed features to machine learned features.\n%{\\bf Note: summarize old 3D method in related work. (spin image, cite MS kinect.)}\n\nRecently, Qi \\textit{et al.}\\cite{REF:qi2017pointnet} proposed PointNet, an end-to-end deep neural network that learns point-wise features directly from point clouds. This approach demonstrated impressive results on 3D object recognition, 3D object part segmentation, and point-wise semantic segmentation tasks. In \\cite{REF:qi2017pointnetplusplus}, an improved version of PointNet was introduced which enabled the network to learn local structures at different scales. To achieve satisfactory results, these two approaches trained feature transformer networks on all input points ($\\sim$1k points). Since typical point clouds obtained using LiDARs contain $\\sim$100k points, training the architectures as in~\\cite{REF:qi2017pointnet,REF:qi2017pointnetplusplus} results in high computational and memory requirements.   Scaling up 3D feature learning networks to orders of magnitude more points and to 3D detection tasks are the main challenges that we address in this paper. \n\n%Scaling up feature learning to $\\sim$100k points for 3D object detection is one of our contributions.\n% it is still an open question on how to effectively learn features for the task of 3D object detection.\n\n\nRegion proposal network (RPN)~\\cite{REF:NIPS2015_5638} is a highly optimized algorithm for efficient object detection~\\cite{REF:ResNet2016,REF:cvpr17chen,REF:YOLO9000_2017,REF:SSD_Liu2016}. However, this approach requires data to be dense and organized in a tensor structure (e.g. image, video) which is not the case for typical LiDAR point clouds. In this paper, we close the gap between point set feature learning and RPN for 3D detection task.\n\nWe present VoxelNet, a generic 3D detection framework that simultaneously learns a discriminative feature representation from point clouds and predicts accurate 3D bounding boxes, in an end-to-end fashion, as shown in Figure~\\ref{fig:VoxelNet_flowchart}.\nWe design a novel voxel feature encoding (VFE) layer, which enables inter-point interaction within a voxel, by combining point-wise features with a locally aggregated feature. Stacking multiple VFE layers allows learning complex features for characterizing local 3D shape information. Specifically, VoxelNet divides the point cloud into equally spaced 3D voxels, encodes each voxel via stacked VFE layers, and then 3D convolution further aggregates local voxel features, transforming the point cloud into a high-dimensional volumetric representation. Finally, a RPN consumes the volumetric representation and yields the detection result. This efficient algorithm benefits both from the sparse point structure and efficient parallel processing on the voxel grid.\n\n% The key innovation of our approach lies in the newly designed Voxel Feature Encoding (VFE) layer, which enables inter-point interaction through the encoding process, by effectively combining point-wise features with a locally aggregated voxel-wise feature.  \n\nWe evaluate VoxelNet on the bird's eye view detection and the full 3D detection tasks, provided by the KITTI benchmark~\\cite{REF:Geiger2012CVPR}. Experimental results show that VoxelNet outperforms  the state-of-the-art LiDAR based 3D detection methods by a large margin. We also demonstrate that VoxelNet achieves highly encouraging results in detecting pedestrians and cyclists from LiDAR point cloud.\n\n",
                "subsection 1.1": {
                    "name": "Related Work",
                    "content": "\n\\label{sec:RelatedWork}\n\n%\\noindent {\\bf 3D feature descriptors}  \n\nRapid development of 3D sensor technology has motivated researchers to develop efficient representations to detect and localize objects in point clouds. Some of the earlier methods for feature representation are \\cite{REF:StructuralIndexing_Medioni92,REF:COSMOS_Jain97,REF:PointSignatures_Chua1997,REF:SpinImageHebert99,REF:Tuzel2014,REF:FPFH_Beetz2009,REF:RoboticAssembly_Oncel2012,REF:Mian2010,REF:Nishino2010,REF:MS_POSE_Blake2011,REF:bo_iros11}. These hand-crafted features yield satisfactory results when rich and detailed 3D shape information is available. However their inability to adapt to more complex shapes and scenes, and learn required invariances from data resulted in limited success for uncontrolled scenarios such as autonomous navigation. \n\n%Recently, Qi \\textit{et al.}\\cite{REF:qi2017pointnet} proposed PointNet and demonstrated that by learning features from raw point clouds in an end-to-end fashion, PointNet achieves impressive results on point cloud classification and point-wise segmentation tasks. As a sucessesor approach, PointNet++~\\cite{REF:qi2017pointnetplusplus} enabled the network~\\cite{REF:qi2017pointnet} to learn local structures at different scales. Scaling up 3D feature learning networks to an order of magnitude more points and to 3D detection tasks are the main challenges that we address in this paper. \n\n%However 3D feature learning which is one of the goals of this paper.\n\n%These two approaches include training a computationally expensive feature transformation network and thus typically require point clouds downsampled into $\\sim$1k points. Given that a high quality point cloud usually contains $\\sim$100k points, scaling up point based feature learning is a challenging problem.\n\n% Based on \\cite{REF:qi2017pointnet}, Zhao \\textit{et al.} proposed Pixel-Voxel Network to fuse RGB feature with point-wise feature for point-wise semantic segmentation. \n\n% With the rapid development of 3D sensor technology, many feature extraction approaches have been proposed~\\cite{REF:StructuralIndexing_Medioni92,REF:COSMOS_Jain97,REF:SpinImageHebert99,REF:Mian2010,REF:FPFH_Beetz2009,REF:MS_POSE_Blake2011}. These feature representations\n\n%\\noindent {\\bf 3D object detection}  \n% Recent years have witnessed the revolution of Deep Convolutional Neural Networks (DCNNs) in image-based detection~\\cite{REF:girshick2014rich,REF:Girshick:2015,REF:NIPS2015_5638}. Notably, Faster-RCNN~\\cite{REF:NIPS2015_5638} is a highly optimized deep convolutional object detection framework unifying region proposal and bounding box regression and it has contributed to several leading results on PASCAL VOC~\\cite{REF:PASCAL_VOC2010}, MSCOCO~\\cite{REF:MSCOCO2014} and ILSVRC~\\cite{REF:ILSVRC15} detection tasks. This method has influenced several top-performing image-based object detection algorithms~\\cite{REF:SSD_Liu2016,REF:YOLO9000_2017}.\n\nGiven that images provide detailed texture information, many algorithms infered the 3D bounding boxes from 2D images~\\cite{REF:nips15chen,REF:cvpr16chen,REF:xiang_cvpr15,REF:Zia2013,REF:Zia2014,REF:SFM2015}. However, the accuracy of  image-based 3D detection approaches are bounded by the accuracy of the depth estimation. \n\nSeveral LIDAR based 3D object detection techniques utilize a voxel grid representation.  \\cite{REF:Wang-RSS-15, REF:Vote3Deep} encode each nonempty voxel with 6 statistical quantities that are derived from all the points contained within the voxel. \\cite{REF:Song2014} fuses multiple local statistics to represent each voxel. \\cite{REF:DeepSlidingShapes} computes the truncated signed distance on the voxel grid. \\cite{REF:3DFCN} uses binary encoding for the 3D voxel grid. \\cite{REF:cvpr17chen} introduces a multi-view representation for a LiDAR point cloud by computing a multi-channel feature map in the bird's eye view and the cylindral coordinates in the frontal view. Several other studies project point clouds onto a perspective view and then use image-based feature encoding schemes~\\cite{REF:FusionDPM-IROS14, REF:MV-RGBD-RF2015,REF:VeloFCN}. \n\nThere are also several multi-modal fusion methods that combine images and LiDAR to improve detection accuracy~\\cite{REF:Enzweiler2011,REF:Gonzalez2017,REF:cvpr17chen}. These methods provide improved performance compared to LiDAR-only 3D detection, particularly for small objects (pedestrians, cyclists) or when the objects are far, since cameras provide an order of magnitude more measurements than LiDAR. However the need for an additional camera that is time synchronized and calibrated with the LiDAR restricts their use and makes the solution more sensitive to sensor failure modes. In this work we focus on LiDAR-only detection.\n\n%\\paragraph{Contributions:}\n"
                },
                "subsection 1.2": {
                    "name": "Contributions",
                    "content": "\n%The main contributions of the paper are as follows:\n\n\\begin{itemize}\n\t\\item  We propose a novel end-to-end trainable deep architecture for point-cloud-based 3D detection, VoxelNet, that directly operates on sparse 3D points and avoids information bottlenecks introduced by manual feature engineering.\n\t\\item We present an efficient method to implement VoxelNet which benefits both from the sparse point structure and efficient parallel processing on the voxel grid.\n\t\\item We conduct experiments on KITTI benchmark and show that VoxelNet produces state-of-the-art results in LiDAR-based car, pedestrian, and cyclist detection benchmarks.\n\\end{itemize}\n\n\n\n\n% The proposed VoxelNet is generally applicable to point cloud captured by various depth sensors, \\textit{e.g., } RGB-D camera, LiDAR, etc. However, in this paper we mainly focus on LiDAR.\n\n%------------------------------------------------------------------------\n%\\input{Section_RelatedWork}\n\n\n%-------------------------------------------------------------------------\n"
                }
            },
            "section 2": {
                "name": "VoxelNet",
                "content": "\n\\label{sec:VoxelNet}\nIn this section we explain the architecture of VoxelNet, the loss function used for training, and an efficient algorithm to implement the network.  \n\n",
                "subsection 2.1": {
                    "name": "VoxelNet Architecture",
                    "content": " \nThe proposed VoxelNet consists of three functional blocks: (1) Feature learning network, (2) Convolutional middle layers, and (3) Region proposal network~\\cite{REF:NIPS2015_5638}, as illustrated in Figure~\\ref{fig:VoxelNet_flowchart}. We provide a detailed introduction of VoxelNet in the following sections.\n\n",
                    "subsubsection 2.1.1": {
                        "name": "Feature Learning Network",
                        "content": "\n\\label{subsec:Feature_Learning}\n\\noindent{\\bf Voxel Partition } Given a point cloud, we subdivide the 3D space into equally spaced voxels as shown in Figure~\\ref{fig:VoxelNet_flowchart}. Suppose the point cloud encompasses 3D space with range $D$, $H$, $W$ along the Z, Y, X axes respectively. We define each voxel of size $v_D$, $v_H$, and $v_W$ accordingly. The resulting 3D voxel grid is of size $D' = D/v_D, H' = H/v_H, W' = W/v_W$. Here, for simplicity, we assume $D$, $H$, $W$ are a multiple of  $v_D$, $v_H$, $v_W$. \n\n\\noindent{\\bf Grouping } We group the points according to the voxel they reside in. Due to factors such as distance, occlusion, object's relative pose, and non-uniform sampling, the LiDAR point cloud is sparse and has highly variable point density throughout the space. Therefore, after grouping, a voxel will contain a variable number of points. An illustration is shown in Figure~\\ref{fig:VoxelNet_flowchart}, where Voxel-1 has significantly more points than Voxel-2 and Voxel-4, while Voxel-3  contains no point. \n% To circumvent this difficulty {\\bf need to change here}, most existing LiDAR-based works~\\cite{REF:VeloFCN, REF:3DFCN, REF:cvpr17chen} choose to transform the point cloud into different compact views, such as bird's eye view projection and frontal view representation~\\cite{REF:cvpr17chen}, which however suffer from the drawback of losing intrinsic 3D shape information within the point cloud. Therefore, it is very much desired to seek a more effective representation for characterizing the underlying shape information of point cloud. \n\n\\noindent{\\bf Random Sampling } Typically a high-definition LiDAR point cloud is composed of $\\sim$100k points. Directly processing all the points not only imposes increased memory/efficiency burdens on the computing platform, but also highly variable point density throughout the space might bias the detection. To this end, we  randomly sample a fixed number, $T$, of points from those voxels containing more than $T$ points. This sampling strategy has two purposes, (1) computational savings (see Section~\\ref{subsec:implementation} for details); and (2) decreases the imbalance of points between the voxels which reduces the sampling bias, and adds more variation to training.\n\n\n%introduces several practical benefits: 1) computational savings(see Section~\\ref{subsec:implementation} for details); 2) regularizing the training to improve generatization~\\cite{REF:JMLR:v15:srivastava14a}; 3) and more importantly, reducing the unbalanced effect caused by variational point density and hence enforcing the network to learn the most intrinsic shape information from the raw point cloud. \n% {\\bf Need proof to justify these statements.}\n\n\\noindent{\\bf Stacked Voxel Feature Encoding } The key innovation is the chain of VFE  layers. For simplicity, Figure~\\ref{fig:VoxelNet_flowchart} illustrates the hierarchical feature encoding process for one voxel. Without loss of generality, we use VFE Layer-1 to describe the details in the following paragraph. Figure~\\ref{fig:VFE} shows the architecture for VFE Layer-1. \n\n\n\n\n\n\nDenote $\\mathbf{V} = \\{\\mathbf{p}_i=[x_i, y_i, z_i, r_i]^{T} \\in \\mathbb{R}^4\\}_{i=1 \\ldots t}$ as a non-empty voxel containing $t \\leq T$ LiDAR points, where $\\mathbf{p}_i$ contains XYZ coordinates for the $i$-th point and $r_i$ is the received reflectance. We first compute the local mean as the centroid of all the points in $\\mathbf{V}$, denoted as $(v_x, v_y, v_z)$. Then we augment each point $\\mathbf{p}_i$ with the relative offset w.r.t. the centroid  and obtain the input feature set $\\mathbf{V}_{\\textrm{in}} = \\{ \\hat{\\mathbf{p}}_i=[x_i, y_i, z_i, r_i, x_i-v_x, y_i-v_y, z_i-v_z]^{T} \\in \\mathbb{R}^7 \\}_{i=1 \\ldots t}$. Next, each $\\hat{\\mathbf{p}}_i$ is transformed through the fully connected network (FCN) into a feature space, where we can aggregate information from the point features $\\mathbf{f}_i \\in \\mathbb{R}^m$ to encode the shape of the surface contained within the voxel. The FCN is composed of a linear layer, a batch normalization (BN) layer, and a rectified linear unit (ReLU) layer. After obtaining point-wise feature representations, we use element-wise MaxPooling across all $\\mathbf{f}_i$ associated to $\\mathbf{V}$ to get the locally aggregated feature $\\tilde{\\mathbf{f}} \\in \\mathbb{R}^m$ for $\\mathbf{V}$. Finally, we augment each $\\mathbf{f}_i$ with $\\tilde{\\mathbf{f}}$ to form the point-wise concatenated feature as $\\mathbf{f}_i^{out} = [\\mathbf{f}_i^{T}, \\tilde{\\mathbf{f}}^{T}]^{T} \\in \\mathbb{R}^{2m}$. Thus we obtain the output feature set $\\mathbf{V}_{\\textrm{out}} = \\{ \\mathbf{f}_i^{out} \\}_{i \\ldots t}$. All non-empty voxels are encoded in the same way and they share the same set of parameters in FCN. \n\nWe use $\\textrm{VFE-i}(c_{in}, c_{out})$ to represent the $i$-th VFE layer that transforms input features of dimension $c_{in}$ into output features of dimension $c_{out}$. The linear layer learns a matrix of size $c_{in} \\times (c_{out}/2)$, and the point-wise concatenation yields the output of dimension $c_{out}$.\n\nBecause the output feature combines both point-wise features and locally aggregated feature, stacking VFE layers encodes point interactions within a voxel and enables the final feature representation to learn descriptive shape information. The voxel-wise feature is obtained by transforming the output of VFE-$n$ into $\\mathbb{R}^{C}$ via FCN and applying element-wise Maxpool where $C$ is the dimension of the voxel-wise feature, as shown in Figure~\\ref{fig:VoxelNet_flowchart}.\n\n\n\\noindent{\\bf Sparse Tensor Representation } By processing only the non-empty voxels, we obtain a list of voxel features, each uniquely associated to the spatial coordinates of a particular non-empty voxel. The obtained list of voxel-wise features can be represented as a sparse 4D tensor, of size $C \\times D' \\times H' \\times W'$ as shown in Figure~\\ref{fig:VoxelNet_flowchart}. Although the point cloud contains $\\sim$100k points, more than $90\\%$ of voxels typically are empty. Representing non-empty voxel features as a sparse tensor greatly reduces the memory usage and computation cost during backpropagation, and it is a critical step in our efficient implementation.\n% , which considers input range $D=10m$, $H=80m$, $W=70.4m$ and chooses voxel size $v_D=0.2m$, $v_H=0.2m$, $v_W=0.4m$.\n\n%\\subsection{End-to-End Training}\n%\\label{subsec:e2e_training}\n\n%\\noindent{\\bf Convolutional Middle Layers } \n\n"
                    },
                    "subsubsection 2.1.2": {
                        "name": "Convolutional Middle Layers",
                        "content": "\nWe use $\\textrm{Conv}M\\textrm{D}(c_{in}, c_{out}, \\mathbf{k}, \\mathbf{s}, \\mathbf{p})$ to represent an $M$-dimensional convolution operator where $c_{in}$  and $c_{out}$ are the number of input and output channels, $\\mathbf{k}$, $\\mathbf{s}$, and $\\mathbf{p}$ are the $M$-dimensional vectors corresponding to kernel size, stride size and padding size respectively. When the size across the $M$-dimensions are the same, we use a scalar to represent the size e.g. $k$ for $\\mathbf{k} = (k,k,k)$. \n\nEach convolutional middle layer applies 3D convolution, BN layer, and ReLU layer sequentially. The convolutional middle layers aggregate voxel-wise features within a progressively expanding receptive field, adding more context to the shape description. The detailed sizes of the filters in the convolutional middle layers are explained in Section~\\ref{sec:training_details}.\n\n%\\noindent{\\bf Region Proposal Net (RPN)}\n\n\n"
                    },
                    "subsubsection 2.1.3": {
                        "name": "Region Proposal Network",
                        "content": "\n\n Recently, region proposal networks~\\cite{REF:NIPS2015_5638} have become an important building block of top-performing object detection frameworks~\\cite{REF:DeepSlidingShapes,REF:cvpr17chen,REF:focalloss}. In this work, we make several key modifications to the  RPN architecture proposed in~\\cite{REF:NIPS2015_5638}, and combine it with the feature learning network and convolutional middle layers to form an end-to-end trainable pipeline. \n\nThe input to our RPN is the feature map provided by the convolutional middle layers.  The architecture of this network is illustrated in Figure~\\ref{fig:RPN}. The network has three blocks of fully convolutional layers. The first layer of each block downsamples the feature map by half via a convolution with a stride size of 2, followed by a sequence of convolutions of stride 1 ($\\times q$ means $q$ applications of the filter). After each convolution layer, BN and ReLU operations are applied. We then upsample the output of every block to a fixed size and concatanate to construct the high resolution feature map. Finally, this feature map is mapped to the desired learning targets: (1) a probability score map and (2) a regression map. \n\n\n%\\noindent{\\bf Loss Function} \n\n"
                    }
                },
                "subsection 2.2": {
                    "name": "Loss Function",
                    "content": "\n\nLet $\\{ a^{\\text{\\scriptsize pos}}_i \\}_{i=1 \\ldots N_{\\text{\\scriptsize pos}}}$ be the set of $N_{\\text{\\scriptsize pos}}$ positive anchors and $\\{ a^{\\text{\\scriptsize neg}}_j \\}_{j=1 \\ldots N_{\\text{\\scriptsize neg}}}$ be the set of $N_{\\text{\\scriptsize neg}}$ negative anchors. We parameterize a 3D ground truth box as $(x_c^g, y_c^g, z_c^g, l^g, w^g, h^g, \\theta^g)$, where $x_c^g, y_c^g, z_c^g$ represent the center location, $l^g, w^g, h^g$ are length, width, height of the box, and $\\theta^g$ is the yaw rotation around Z-axis. To retrieve the ground truth box from a matching positive anchor parameterized as $(x_c^a, y_c^a, z_c^a, l^a, w^a, h^a, \\theta^a)$, we define the residual vector $\\mathbf{u}^* \\in \\mathbb{R}^7$  containing the 7 regression targets corresponding to center location $\\Delta x, \\Delta y, \\Delta z$, three dimensions $\\Delta l, \\Delta w, \\Delta h$, and the rotation $\\Delta \\theta$, which are computed as:\n\\begin{align}\n\\scriptsize\n    &\\Delta x = \\frac{x_c^g - x_c^a}{d^a} , \\Delta y = \\frac{y_c^g - y_c^a}{d^a} , \n    \\Delta z = \\frac{z_c^g - z_c^a}{h^a} , \\nonumber \\\\\n    &\\Delta l = \\log(\\frac{l^g}{l^a}) , \\Delta w = \\log(\\frac{w^g}{w^a}) , \\Delta h = \\log(\\frac{h^g}{h^a}) , \\\\\n    &\\Delta \\theta = \\theta^g - \\theta^a \\nonumber\n\\label{eqn:reg_targets}\n\\end{align}\nwhere $d^a = \\sqrt{(l^a)^2 + (w^a)^2}$ is the diagonal of the base of the anchor box. Here, we aim to directly estimate the oriented 3D box and normalize $\\Delta x$ and $\\Delta y$ homogeneously with the diagonal $d^a$, which is different from \\cite{REF:NIPS2015_5638,REF:DeepSlidingShapes,REF:VeloFCN, REF:3DFCN,REF:nips15chen,REF:cvpr16chen,REF:cvpr17chen}. We define the loss function as follows:\n\n\\begin{eqnarray}\n    L & = & \\alpha\\frac{1}{N_{\\text{\\scriptsize pos}}} \\sum\\limits_{i} L_{\\text{\\scriptsize cls}}(p^{\\text{\\scriptsize pos}}_i, 1) + \n            \\beta\\frac{1}{N_{\\text{\\scriptsize neg}}} \\sum\\limits_{j} L_{\\text{\\scriptsize cls}}(p^{\\text{\\scriptsize neg}}_j, 0) \\nonumber \\\\\n            & + & \\frac{1}{N_{\\text{\\scriptsize pos}}} \\sum\\limits_{i} L_{\\text{\\scriptsize reg}}(\\mathbf{u}_i, \\mathbf{u}_i^*)\n\\label{eqn:loss_function}\n\\end{eqnarray}\nwhere $p^{\\text{\\scriptsize pos}}_i$ and $p^{\\text{\\scriptsize neg}}_j$ represent the softmax output for positive anchor $a^{\\text{\\scriptsize pos}}_i$ and negative anchor $a^{\\text{\\scriptsize neg}}_j$ respectively, while $\\mathbf{u}_i \\in \\mathbb{R}^7$ and $\\mathbf{u}_i^* \\in \\mathbb{R}^7$ are the regression output and ground truth for positive anchor $a^{\\text{\\scriptsize pos}}_i$. The first two terms are the normalized classification loss for $\\{ a^{\\text{\\scriptsize pos}}_i \\}_{i=1 \\ldots N_{\\text{\\scriptsize pos}}}$ and $\\{ a^{\\text{\\scriptsize neg}}_j \\}_{j=1 \\ldots N_{\\text{\\scriptsize neg}}}$, where the $L_{\\text{\\scriptsize cls}}$ stands for binary cross entropy loss and $\\alpha$, $\\beta$ are postive constants balancing the relative importance. The last term $L_{reg}$ is the regression loss, where we use the SmoothL1 function~\\cite{REF:Girshick:2015,REF:NIPS2015_5638}.\n\n\n% \\begin{equation}\n% \tL_{cls} = \\frac{1}{N_{pos}}L_{cls}(a_{pos}, a_{pos}^*) + \\frac{1}{N_{neg}}L_{cls}(a_{neg}, a_{neg}^*)\n% \\label{eqn:classification}\n% \\end{equation}\n\n\n\n\n"
                },
                "subsection 2.3": {
                    "name": "Efficient Implementation",
                    "content": "\n\\label{subsec:implementation}\n\n\n\n\n% \\noindent{\\bf Efficient Parallel Implementation} \nGPUs are optimized for processing dense tensor structures. The problem with working directly with the point cloud is that the points are sparsely distributed across space and each voxel has a variable number of points.  We devised a method that converts the point cloud into a dense tensor structure where stacked VFE operations can be processed in parallel  across points and voxels. \n\nThe method is summarized in Figure~\\ref{fig:Implementation}. We initialize a $K \\times T \\times 7$ dimensional tensor structure to store the voxel input feature buffer where $K$ is the maximum number of non-empty voxels, $T$ is the maximum number of points per voxel, and $7$ is the input encoding dimension for each point. The points are randomized before processing. For each point in the point cloud, we check if the corresponding voxel already exists. This lookup operation is done efficiently in $O(1)$ using a hash table where the voxel coordinate is used as the hash key. If the voxel is already initialized we insert the point to the voxel location if there are less than $T$ points, otherwise the point is ignored. If the voxel is not initialized, we initialize a new voxel, store its coordinate in the voxel coordinate buffer, and insert the point to this voxel location. The voxel input feature and coordinate buffers can be constructed via a single pass over the point list, therefore its complexity is $O(n)$.  To further improve the memory/compute efficiency it is possible to only store a limited number of voxels ($K$) and ignore points coming from voxels with few points. \n%The described randomized selection algorithm will ignore the voxels with fewer number of points with exponentially higher probability if a hard limit on $K$ is set. \n\nAfter the voxel input buffer is constructed, the stacked VFE only involves point level and voxel level dense operations which can be computed on a GPU in parallel. Note that,  after concatenation operations in VFE, we reset the features corresponding to empty points to zero such that they do not affect  the computed voxel features. Finally, using the stored coordinate buffer we reorganize the computed sparse voxel-wise structures to the dense voxel grid. The following  convolutional middle layers and RPN operations work on a dense voxel grid which can be efficiently implemented on a GPU.\n\n\n% \\noindent{\\bf Training Details} \n% In this work, our experimental setup is based on the LiDAR specifications of the KITTI dataset.\n\n\n% 1) For car detection, we consider point cloud within the range of $[-3, 1] \\times [-40, 40] \\times [0, 70.4]$ meters along Z, Y, X axis respectively. Points that are projected outside of image boundaries are removed~\\cite{REF:cvpr17chen}. We choose voxel size as $v_D=0.4, v_H=0.2, v_W=0.2$ meters, which leads to $D'=10$, $H'=400$, $W'=352$. We set $T=35$ as the maximum number of randomly sampled points in each non-empty voxel. We use two VFE layers $\\textrm{VFE-1}(7, 32)$ and $\\textrm{VFE-2}(32, 128)$. The final Fully Connected Neural Net (FCNN) maps VFE-2 output to $\\mathbb{R}^{128}$. Thus our Feature Learning Net generates a sparse tensor of shape $128 \\times 10 \\times 400 \\times 352$. To aggregate voxel-wise features, we employ three Convolution Mid Layers sequentially as Conv3D(128, 64, 3, (2,1,1), (1,1,1)), Conv3D(64, 64, 3, (1,1,1), (0,1,1)) and Conv3D(64, 64, 3, (2,1,1), (1,1,1)), which yields 4D tensor of size $64 \\times 2 \\times 400 \\times 352$. After reshaping, the input to Region Proposal Net is a feature map of size $128 \\times 400 \\times 352$, where the dimensions correspond to channel, height and width of the 3D tensor, as illustrated in Figure~\\ref{fig:RPN}. An anchor is assigned as positive if it has the highest Intersection over Union (IoU) with a ground truth or its IoU with ground truth is above 0.6. An anchor is considered as negative if it has IoU with any ground truth less than 0.45. We treat anchors as don't care that have IoU with any ground truth\n\n\n% 2) For detecting pedestrian and cyclist, the input range is $[-3, 1] \\times [-20, 20] \\times [0, 48]$ meters along Z, Y, X axis respectively\\footnote{Our empirical observation suggests that beyond this range, LiDAR reflections from a pedestrian or cyclist become very sparse and therefore detection results will be unreliable.}. We use the same voxel size as for car detection, which yields $D=10$, $H=200$, $W=240$. We set $T=45$ in order to obtain more LiDAR points for better capturing shape information. \n\n\n\n\n\n%-------------------------------------------------------------------------\n"
                }
            },
            "section 3": {
                "name": "Training Details",
                "content": "\n\\label{sec:training_details}\nIn this section, we explain the implementation details of the VoxelNet and the training procedure. \n% \\noindent{\\bf Training Details}\n",
                "subsection 3.1": {
                    "name": "Network Details",
                    "content": " \nOur experimental setup is based on the LiDAR specifications of the KITTI dataset~\\cite{REF:Geiger2012CVPR}.\n\n\\noindent{\\bf Car Detection }  For this task, we consider point clouds within the range of $[-3, 1] \\times [-40, 40] \\times [0, 70.4]$ meters along Z, Y, X axis respectively. Points that are projected outside of image boundaries are removed~\\cite{REF:cvpr17chen}. We choose a voxel size of $v_D=0.4, v_H=0.2, v_W=0.2$ meters, which leads to $D'=10$, $H'=400$, $W'=352$. We set $T=35$ as the maximum number of randomly sampled points in each non-empty voxel. We use two VFE layers $\\textrm{VFE-1}(7, 32)$ and $\\textrm{VFE-2}(32, 128)$. The final FCN maps VFE-2 output to $\\mathbb{R}^{128}$. Thus our feature learning net generates a sparse tensor of shape $128 \\times 10 \\times 400 \\times 352$. To aggregate voxel-wise features, we employ three convolution middle layers sequentially as Conv3D(128, 64, 3, (2,1,1), (1,1,1)), Conv3D(64, 64, 3, (1,1,1), (0,1,1)), and Conv3D(64, 64, 3, (2,1,1), (1,1,1)), which yields a 4D tensor of size $64 \\times 2 \\times 400 \\times 352$. After reshaping, the input to RPN is a feature map of size $128 \\times 400 \\times 352$, where the dimensions correspond to channel, height, and width of the 3D tensor. Figure~\\ref{fig:RPN} illustrates the detailed network architecture for this task. Unlike \\cite{REF:cvpr17chen}, we use only one anchor size, $l^a=3.9, w^a=1.6, h^a=1.56$ meters, centered at $z_c^a = -1.0$ meters with two rotations, 0 and 90 degrees. \nOur anchor matching criteria is as follows: An anchor is considered as positive if it has the highest Intersection over Union (IoU) with a ground truth or its IoU with ground truth is above 0.6 (in bird's eye view). An anchor is considered as negative if the IoU between it and all ground truth boxes is less than 0.45. We treat anchors as don't care if they have $0.45 \\leq \\textrm{IoU} \\leq 0.6$ with any ground truth. We set $\\alpha = 1.5$ and $\\beta = 1$ in Eqn.~\\ref{eqn:loss_function}.\n\n\\noindent{\\bf Pedestrian and Cyclist Detection } The input range\\footnote{Our empirical observation suggests that beyond this range, LiDAR returns from pedestrians and cyclists become very sparse and therefore detection results will be unreliable.} is $[-3, 1] \\times [-20, 20] \\times [0, 48]$ meters along Z, Y, X axis respectively. We use the same voxel size as for car detection, which yields $D=10$, $H=200$, $W=240$. We set $T=45$ in order to obtain more LiDAR points for better capturing shape information. The feature learning network and convolutional middle layers are identical to the networks used in the car detection task. For the RPN, we make one modification to block 1 in Figure~\\ref{fig:RPN} by changing the stride size in the first 2D convolution from 2 to 1. This allows finer resolution in anchor matching, which is necessary for detecting pedestrians and cyclists. We use anchor size $l^a=0.8, w^a=0.6, h^a=1.73$ meters  centered at $z_c^a = -0.6$ meters with 0 and 90 degrees rotation for pedestrian detection and use anchor size $l^a=1.76, w^a=0.6, h^a=1.73$ meters centered at $z_c^a = -0.6$ with 0 and 90 degrees rotation for cyclist detection.\nThe specific anchor matching criteria is as follows: We assign an anchor as postive if it has the highest IoU with a ground truth, or its IoU with ground truth is above 0.5. An anchor is considered as negative if its IoU with every ground truth is less than 0.35. For anchors having $0.35 \\leq \\textrm{IoU} \\leq 0.5$ with any ground truth, we treat them as don't care. \n%We set $\\alpha = 1.5$ and $\\beta = 1$ in Eqn.~\\ref{eqn:loss_function}.\n\nDuring training, we use stochastic gradient descent (SGD) with learning rate 0.01 for the first 150 epochs and decrease the learning rate to 0.001 for the last 10 epochs. We use a batchsize of 16 point clouds.\n\n\n\n"
                },
                "subsection 3.2": {
                    "name": "Data Augmentation",
                    "content": "\nWith less than 4000 training point clouds, training our network from scratch will inevitably suffer from overfitting. To reduce this issue, we introduce three different forms of data augmentation. The augmented training data are generated on-the-fly without the need to be stored on disk~\\cite{REF:NIPS2012_4824}. \n% All of these data augmentation techniques are implemented in Python and executed on CPU with negligible computation cost. The augmented training samples are thusly generated on-the-fly without the need to be stored on a disk~\\cite{REF:NIPS2012_4824}. \n% l, w, h should be dilated slightly.\n\nDefine set $\\mathbf{M} = \\{ \\mathbf{p}_i=[x_i, y_i, z_i, r_i]^T \\in \\mathbb{R}^4 \\}_{i=1, \\ldots, N}$ as the whole point cloud, consisting of $N$ points.\nWe parameterize a  3D bouding box $\\mathbf{b}_i$ as $(x_c, y_c, z_c, l, w, h, \\theta)$, where $x_c, y_c, z_c$ are center locations, $l, w, h$ are length, width, height, and $\\theta$ is the yaw rotation around Z-axis. We define $\\Omega_i=\\{\\mathbf{p} | x \\in [x_c - l/2, x_c + l/2], y \\in [y_c - w/2, y_c + w/2], z \\in [z_c - h/2, z_c + h/2], \\mathbf{p} \\in \\mathbf{M}\\}$ as the set containing all LiDAR points within $\\mathbf{b}_i$, where $\\mathbf{p}=[x, y, z, r]$ denotes a particular LiDAR point in the whole set $\\mathbf{M}$.\n\nThe first form of data augmentation applies perturbation independently to each ground truth 3D bounding box together with those LiDAR points within the box. Specifically, around Z-axis we rotate $\\mathbf{b}_i$ and the associated $\\Omega_i$ with respect to $(x_c, y_c, z_c)$ by a uniformally distributed random variable $\\Delta\\theta \\in [-\\pi/10, +\\pi/10]$. Then we add a translation $(\\Delta x, \\Delta y, \\Delta z)$ to the XYZ components of $\\mathbf{b}_i$ and to each point in $\\Omega_i$, where $\\Delta x$, $\\Delta y$, $\\Delta z$ are drawn independently from a Gaussian distribution with mean zero and standard deviation 1.0. To avoid physically impossible outcomes, we perform a collision test between any two boxes after the perturbation and revert to the original if a collision is detected. Since the perturbation is applied to each ground truth box and the associated LiDAR points independently, the network is able to learn from substantially more variations than from the original training data.\n\nSecondly, we apply global scaling to all ground truth boxes $\\mathbf{b}_i$ and to the whole point cloud $\\mathbf{M}$. Specifically, we multiply the XYZ coordinates and the three dimensions of each $\\mathbf{b}_i$, and the XYZ coordinates of all points in $\\mathbf{M}$ with a random variable drawn from uniform distribution $[0.95, 1.05]$. Introducing global scale augmentation improves robustness of the network for detecting objects with various sizes and distances as shown in image-based classification~\\cite{REF:Simonyan14c, REF:journals/corr/Howard13} and detection tasks~\\cite{REF:Girshick:2015, REF:ResNet2016}.\n\nFinally, we apply global rotation to all ground truth boxes $\\mathbf{b}_i$ and to the whole point cloud $\\mathbf{M}$. The rotation is applied along Z-axis and around $(0, 0, 0)$. The global rotation offset is determined by sampling from uniform distribution $[-\\pi/4, +\\pi/4]$. By rotating the entire point cloud, we simulate the vehicle making a turn.\n%------------------------------------------------------------------------\n\n\n\n\n\n\n"
                }
            },
            "section 4": {
                "name": "Experiments",
                "content": "\n\\label{sec:Experiment}\nWe evaluate VoxelNet on the KITTI 3D object detection benchmark~\\cite{REF:Geiger2012CVPR} which contains 7,481 training images/point clouds and 7,518 test images/point clouds, covering three categories: \\textit{Car}, \\textit{Pedestrian}, and \\textit{Cyclist}. For each class, detection outcomes are evaluated based on three difficulty levels: \\textit{easy}, \\textit{moderate}, and \\textit{hard}, which are determined according to the object size, occlusion state, and truncation level. Since the ground truth for the test set is not available and the access to the test server is limited, we conduct comprehensive evaluation using the protocol described in~\\cite{REF:nips15chen,REF:cvpr16chen,REF:cvpr17chen} and subdivide the training data into a training set and a validation set, which results in 3,712 data samples for training and 3,769 data samples for validation. The split avoids samples from the same sequence being included in both the training and the validation set~\\cite{REF:cvpr16chen}. Finally we also present the test results using the KITTI server.\n\nFor the \\textit{Car} category, we compare the proposed method with several top-performing algorithms, including image based approaches: Mono3D~\\cite{REF:cvpr16chen} and 3DOP~\\cite{REF:nips15chen}; LiDAR based approaches: VeloFCN~\\cite{REF:VeloFCN} and 3D-FCN~\\cite{REF:3DFCN}; and a multi-modal approach MV~\\cite{REF:cvpr17chen}. Mono3D~\\cite{REF:cvpr16chen}, 3DOP~\\cite{REF:nips15chen} and MV~\\cite{REF:cvpr17chen}  use a pre-trained model for initialization whereas we train VoxelNet from scratch using only the LiDAR data provided in KITTI.\n\nTo analyze the importance of end-to-end learning, we implement a strong baseline that is derived from the VoxelNet architecture but uses hand-crafted features instead of the proposed feature learning network. We call this model the hand-crafted baseline (HC-baseline). HC-baseline uses the bird's eye view features described in \n\\cite{REF:cvpr17chen} which are computed at $0.1$m resolution. Different from \\cite{REF:cvpr17chen}, we increase the number of height channels from 4 to 16 to capture more detailed shape information-- further increasing the number of height channels did not lead to performance improvement. We replace the convolutional middle layers of VoxelNet with similar size 2D convolutional layers, which are Conv2D(16, 32, 3, 1, 1), Conv2D(32, 64, 3, 2, 1), Conv2D(64, 128, 3, 1, 1). Finally RPN is identical in VoxelNet and HC-baseline. The total number of parameters in HC-baseline and VoxelNet are very similar. We train the HC-baseline using the same training procedure and data augmentation described in Section~\\ref{sec:training_details}. \n\n% \\subsection{Data Augmentation}\n% We parameterize a specific 3D bouding box $\\mathbf{b}_i$ as $(x_c, y_c, z_c, l, w, h, \\theta)$, where $x_c, y_c, z_c$ are center locations of $\\mathbf{b}_i$, $l, w, h$ are length, width, height of the box, and $\\theta$ is the yaw rotation around Z-axis. We define $\\Omega_i=\\{\\mathbf{p} | x \\in [x_c - l/2, x_c + l/2], y \\in [y_c - w/2, y_c + w/2], z \\in [z_c - h/2, z_c + h/2], \\mathbf{p}=[x, y, z, r] \\in \\mathbf{M}\\}$ as the set containing all LiDAR points within $\\mathbf{b}$, where $\\mathbf{M} \\in \\mathbb{R}^4$ represents whole point cloud and $\\mathbf{p}=[x, y, z, r]$ denotes a particular LiDAR points containing XYZ location and reflectance information.\n\n% With less than 4000 training samples, training our network from scratch will inevitably suffer from overfitting. To reduce this issue, we introduce three different forms of data augmentation. All of these data augmentation techniques are implemented in Python and executed on CPU with negligible computation cost. The augmented training samples are thusly generated on-the-fly without the need to be stored on a disk~\\cite{REF:NIPS2012_4824}. \n% % l, w, h should be dilated slightly.\n\n% The first form of data augmentation considers applying perturbation independently to each ground truth 3D bounding box together with those LiDAR points within the box. Specifically, around Z-axis we rotate $\\mathbf{b}_i$ and the associated $\\Omega_i$ with respect to $(x_c, y_c, z_c)$ by a uniformally distributed random variable $\\Delta\\theta \\in [-\\pi/10, +\\pi/10]$. Then we add a translation $(\\Delta x, \\Delta y, \\Delta z)$ to the XYZ components of $\\mathbf{b}_i$ and each point in $\\Omega_i$, where $\\Delta x$, $\\Delta y$, $\\Delta z$ are drawn independently from a Gaussian distribution with mean zero and standard deviation 1.0. To avoid physically impossible outcomes, we perform collision test between any two boxes after the perturbation and recover to the original if collision is detected. Since the perturbation is applied to each ground truth and the associated LiDAR points independently, the network is able to learn from substantially more variations than from the original training data.\n\n% Secondly, we apply global scaling to all ground truth boxes $\\mathbf{b}_i, \\forall i$ and the whole point cloud $\\mathbf{M}$. Specifically, we multiply a random variable drawn from uniform distribution $[0.95, 1.05]$ to the XYZ coordinates and three dimensions for each $\\mathbf{b}_i$ and multiply the same scaling factor to XYZ coordinates of every points in $\\mathbf{M}$. Introduction of scaling randomness improves network robustness in detecting objects from different distance and with diverse sizes. This technique has proven effective in image-based classification~\\cite{REF:Simonyan14c, REF:journals/corr/Howard13} and detection tasks~\\cite{REF:Girshick:2015:FR:2919332.2920125, REF:ResNet2016}\n\n% Finally, we employ global rotation around Z-axis to all ground truth boxes $\\mathbf{b}_i, \\forall i$ and the whole point cloud $\\mathbf{M}$, with respect to $(0, 0, 0)$. The global rotation offset is determined by sampling from uniform distribution $[-\\pi/4, +\\pi/4]$. By rotating the entire point cloud, we simulate the situations when the ego-vehicle is making turns.\n\n\n\n\n\n",
                "subsection 4.1": {
                    "name": "Evaluation on KITTI Validation Set",
                    "content": "\n\\paragraph{Metrics} \nWe follow the official KITTI evaluation protocol, where the IoU threshold is 0.7 for class \\textit{Car} and is 0.5 for class \\textit{Pedestrian} and \\textit{Cyclist}. The IoU threshold is the same for both bird's eye view and full 3D evaluation. We compare the methods using the average precision (AP) metric.\n\n\n\n\\paragraph{Evaluation in Bird's Eye View} \n\nThe evaluation result is presented in Table~\\ref{table:BEV_detection_comparison}. VoxelNet consistently outperforms all the competing approaches across all three difficulty levels. HC-baseline also achieves satisfactory performance compared to the state-of-the-art~\\cite{REF:cvpr17chen}, which shows that our base region proposal network (RPN) is effective. For \\textit{Pedestrian} and \\textit{Cyclist} detection tasks in bird's eye view, we compare the proposed VoxelNet with HC-baseline. VoxelNet yields substantially higher AP than the HC-baseline for these more challenging categories, which shows that end-to-end learning is essential for point-cloud based detection.\n\nWe would like to note that \\cite{REF:3DFCN} reported 88.9\\%, 77.3\\%, and 72.7\\% for \\textit{easy}, \\textit{moderate}, and \\textit{hard} levels respectively, but these results are obtained based on a different split of 6,000 training frames and $\\sim$1,500 validation frames, and they are not directly comparable with algorithms in Table~\\ref{table:BEV_detection_comparison}. Therefore, we do not include these results in the table.\n\n\n\\paragraph{Evaluation in 3D}\nCompared to the bird's eye view detection, which requires only accurate localization of objects in the 2D plane, 3D detection is a more challenging task as it requires finer localization of shapes in 3D space. Table~\\ref{table:3D_detection_comparison} summarizes the  comparison. For the class \\textit{Car}, VoxelNet significantly outperforms all other approaches in AP across all difficulty levels. Specifically, using only LiDAR, VoxelNet significantly outperforms the state-of-the-art method MV (BV+FV+RGB)~\\cite{REF:cvpr17chen} based on LiDAR+RGB, by 10.68\\%, 2.78\\% and 6.29\\% in \\textit{easy}, \\textit{moderate}, and \\textit{hard} levels respectively. HC-baseline achieves similar accuracy to the MV~\\cite{REF:cvpr17chen} method.\n\nAs in the bird's eye view evaluation, we also compare VoxelNet with HC-baseline on 3D \\textit{Pedestrian} and \\textit{Cyclist} detection. Due to the high variation in 3D poses and shapes, successful detection of these two categories requires better 3D shape representation. As shown in Table~\\ref{table:3D_detection_comparison} the improved performance of VoxelNet is emphasized for more challenging 3D detection tasks (from $\\sim$8\\% improvement in bird's eye view to $\\sim$12\\% improvement on 3D detection) which suggests that VoxelNet is more effective in capturing 3D shape information than hand-crafted features.\n\n\n\n"
                },
                "subsection 4.2": {
                    "name": "Evaluation on KITTI Test Set",
                    "content": "\n\nWe evaluated VoxelNet on the KITTI test set by submitting detection results to the official server. The results are summarized in Table~\\ref{table:test_set_result}. VoxelNet,  significantly outperforms the previously published state-of-the-art~\\cite{REF:cvpr17chen}  in all the tasks (bird's eye view and 3D detection) and all difficulties. We would like to note that many of the other leading methods listed in KITTI benchmark  use both RGB images and LiDAR point clouds whereas VoxelNet  uses only LiDAR.\n\n\n%In addition, currently, it  leads all the methods submitted to the KITTI test server across all the task, categories and difficulty levels. Similar to validation results, improvement is more emphasized  for more challenging \\textit{Pedestrian} and \\textit{Cyclist} categories.\n\n%\\subsection{Qualitative Results}\n\nWe present several 3D detection examples in Figure~\\ref{fig:Qualitative_demo}. For better visualization  3D boxes detected using LiDAR are projected on to the RGB images. As shown, VoxelNet provides highly accurate 3D bounding boxes in all categories.\n\n%\\subsection{Computation Time}\n\nThe inference time for the VoxelNet is 225ms where the voxel input feature computation takes 5ms, feature learning net takes 20ms, convolutional middle layers take 170ms, and region proposal net takes 30ms on a TitanX GPU and 1.7Ghz CPU.\n\n\n\n\n\n\n\n\n% \\begin{figure*}[!h]\n% \\centering\n%     \\begin{tabular}{ccc}\n%     \\centering\n%     % \\subfigure[]{\n%          % \\label{fig:subfig:YaleB_1}\n%          \\includegraphics[width=0.333\\linewidth,height=0.30\\linewidth]{./figures/001755_vox_combined.png} & \\hspace{-0.45cm}\n\n%     % \\subfigure[]{\n%         % \\label{fig:subfig:YaleB_2}\n%         \\includegraphics[width=0.333\\linewidth,height=0.30\\linewidth]{./figures/001755_mv_combined.png} & \\hspace{-0.45cm}\n\n%     % \\subfigure[]{\n%         % \\label{fig:subfig:YaleB_3}\n%         \\includegraphics[width=0.333\\linewidth,height=0.30\\linewidth]{./figures/001755_baseline_combined.png} \\\\\n\n%     % \\hspace{-0.2cm}\n%     % \\subfigure[]{\n%          % \\label{fig:subfig:VoxelNet}\n%          \\includegraphics[width=0.333\\linewidth,height=0.30\\linewidth]{./figures/002721_vox_combined.png} & \\hspace{-0.45cm}\n%     % \\subfigure[]{\n%         % \\label{fig:subfig:MV}\n%         \\includegraphics[width=0.333\\linewidth,height=0.30\\linewidth]{./figures/002721_mv_combined.png} & \\hspace{-0.45cm}\n%     % \\subfigure[]{\n%         % \\label{fig:subfig:Baseline}\n%         \\includegraphics[width=0.333\\linewidth,height=0.30\\linewidth]{./figures/002721_baseline_combined.png} \\\\\n\n%         VoxelNet & MV~\\cite{REF:cvpr17chen} & Baseline \\\\\n%     \\end{tabular}\n%     %     \\caption{Qualitative comparison among approaches. Three approaches, \\textit{i.e., } the proposed VoxelNet (1st column), MV~\\cite{REF:cvpr17chen} (2nd column) and our own baseline (3rd column) are compared qualitatively in two example scenes. For each method, the detection results are visualized in image plane after 3D bounding box projection and in 3D point cloud directly.}\n%     % \\label{fig:Qualitative_vehicle}\n%     \\caption{Qualitative comparison of three approaches in two example scenes. Detection outcomes generated by the proposed VoxelNet (1st column), MV~\\cite{REF:cvpr17chen} (2nd column) and our own baseline (3rd column) are highlighted in green, cyan and yellow respectively. For each method, the detection results are visualized in image plane after 3D bounding box projection and in 3D point cloud directly. In each 3D point cloud, the ground truth box is displayed in red. }\n%     \\label{fig:Qualitative_vehicle}\n% \\end{figure*}\n%------------------------------------------------------------------------\n% \\input{Section_Discussion}\n\n%------------------------------------------------------------------------\n"
                }
            },
            "section 5": {
                "name": "Conclusion",
                "content": "\nMost existing methods in LiDAR-based 3D detection rely on hand-crafted feature representations, for example, a bird's eye view projection. In this paper, we remove the bottleneck of manual feature engineering and propose VoxelNet, a novel end-to-end trainable deep architecture for point cloud based 3D detection. Our approach can operate directly on sparse 3D points and capture 3D shape information effectively. We also present an efficient implementation of VoxelNet that benefits from point cloud sparsity and parallel processing on a voxel grid. Our experiments on the KITTI car detection task show that VoxelNet outperforms state-of-the-art LiDAR based 3D detection methods by a large margin. On more challenging tasks, such as 3D detection of pedestrians and cyclists, VoxelNet also demonstrates encouraging results showing that it provides a better 3D representation. Future work includes extending VoxelNet for joint LiDAR and image based end-to-end 3D detection to further improve detection and localization accuracy.\n\n%can learn a good representation for various geometries.\n\n%due to its capability in effectively capturing various geometries.\n\n%Furture work includes extending VoxelNet by fusing RGB and jointly training a box refinement network to further improve detection accuracy. In addition, training VoxelNet with multi-class supervision information may overcome the ambiguity between similar classes.\n\n%------------------------------------------------------------------------\n\\paragraph{Acknowledgement:} \n\nWe are grateful to our colleagues Russ Webb, Barry Theobald, and Jerremy Holland for their valuable input.\n{\\small\n\\bibliographystyle{ieee}\n\\bibliography{refb}\n}\n\n"
            }
        },
        "tables": {
            "table:BEV_detection_comparison": "\\begin{table*}[!t]\n% \\setlength{\\abovecaptionskip}{0pt}\n% \\setlength{\\belowcaptionskip}{0pt}\n\\centering\n\\scalebox{0.9}{\n\\begin{tabular}{|c|c||c|c|c||c|c|c||c|c|c|}\n\\hline\n\\multirow{2}{*}{Method} & \\multirow{2}{*}{Modality} & \\multicolumn{3}{c||}{Car} & \\multicolumn{3}{c||}{Pedestrian} & \\multicolumn{3}{c|}{Cyclist} \\\\\\cline{3-11}\n     & & Easy & Moderate & Hard & Easy & Moderate & Hard & Easy & Moderate & Hard  \\\\\n\\hline\nMono3D~\\cite{REF:cvpr16chen} & Mono & 5.22 & 5.19 & 4.13 & N/A & N/A & N/A & N/A & N/A & N/A \\\\ \n\n3DOP~\\cite{REF:nips15chen} & Stereo & 12.63 & 9.49 & 7.59 & N/A & N/A & N/A & N/A & N/A & N/A \\\\\n\nVeloFCN~\\cite{REF:VeloFCN} & LiDAR & 40.14 & 32.08 & 30.47 & N/A & N/A & N/A & N/A & N/A & N/A \\\\\n\nMV (BV+FV)~\\cite{REF:cvpr17chen} & LiDAR & 86.18 & 77.32 & 76.33 & N/A & N/A & N/A & N/A & N/A & N/A \\\\\n\nMV (BV+FV+RGB)~\\cite{REF:cvpr17chen} & LiDAR+Mono & 86.55 & 78.10 & 76.67 & N/A & N/A & N/A & N/A & N/A & N/A \\\\\n\\hline\nHC-baseline & LiDAR & 88.26 & 78.42 & 77.66  & 58.96 & 53.79 & 51.47 & 63.63 & 42.75 & 41.06 \\\\\n\nVoxelNet & LiDAR & \\bf{89.60} & \\bf{84.81} & \\bf{78.57} & \\bf{65.95} & \\bf{61.05} & \\bf{56.98} & \\bf{74.41} & \\bf{52.18} & \\bf{50.49} \\\\\n\\hline\n\\end{tabular}\n}\n\\caption{Performance comparison in bird's eye view detection: average precision (in \\%) on KITTI validation set.}\n\\vspace{-0.3cm}\n\n\\label{table:BEV_detection_comparison}\n\\end{table*}",
            "table:3D_detection_comparison": "\\begin{table*}[!t]\n% \\setlength{\\abovecaptionskip}{0pt}\n% \\setlength{\\belowcaptionskip}{0pt}\n\\centering\n\\scalebox{0.9}{\n\\begin{tabular}{|c|c||c|c|c||c|c|c||c|c|c|}\n\\hline\n\\multirow{2}{*}{Method} & \\multirow{2}{*}{Modality} & \\multicolumn{3}{c||}{Car} & \\multicolumn{3}{c||}{Pedestrian} & \\multicolumn{3}{c|}{Cyclist} \\\\\\cline{3-11}\n     & & Easy & Moderate & Hard & Easy & Moderate & Hard & Easy & Moderate & Hard  \\\\\n\\hline\nMono3D~\\cite{REF:cvpr16chen} & Mono & 2.53 & 2.31 & 2.31 & N/A & N/A & N/A & N/A & N/A & N/A \\\\ \n\n3DOP~\\cite{REF:nips15chen} & Stereo & 6.55 & 5.07 & 4.10 & N/A & N/A & N/A & N/A & N/A & N/A \\\\\n\nVeloFCN~\\cite{REF:VeloFCN} & LiDAR & 15.20 & 13.66 & 15.98 & N/A & N/A & N/A & N/A & N/A & N/A \\\\\n\nMV (BV+FV)~\\cite{REF:cvpr17chen} & LiDAR & 71.19 & 56.60 & 55.30 & N/A & N/A & N/A & N/A & N/A & N/A \\\\\n\nMV (BV+FV+RGB)~\\cite{REF:cvpr17chen} & LiDAR+Mono & 71.29 & 62.68 & 56.56 & N/A & N/A & N/A & N/A & N/A & N/A \\\\\n\\hline\nHC-baseline & LiDAR & 71.73 & 59.75 & 55.69 & 43.95 & 40.18 & 37.48 & 55.35 & 36.07 & 34.15 \\\\\n\nVoxelNet & LiDAR & \\bf{81.97} & \\bf{65.46} & \\bf{62.85} & \\bf{57.86} & \\bf{53.42} & \\bf{48.87} & \\bf{67.17} & \\bf{47.65} & \\bf{45.11} \\\\\n\\hline\n\\end{tabular}\n}\n\\caption{Performance comparison in 3D detection: average precision (in \\%) on KITTI validation set.}\n\\vspace{-0.1cm}\n\\label{table:3D_detection_comparison}\n\\end{table*}",
            "table:test_set_result": "\\begin{table}[!t]\n\\centering\n\\scalebox{0.9}{\n\\begin{tabular}{| c | c | c | c |}\n\\hline\n{\\bf Benchmark} & {\\bf Easy} & {\\bf Moderate} & {\\bf Hard} \\\\ \n\\hline\nCar (3D Detection) & 77.47  & 65.11  & 57.73 \\\\\nCar (Bird's Eye View) & 89.35  & 79.26  & 77.39 \\\\\n\\hline\nPedestrian (3D Detection) & 39.48  & 33.69  & 31.51 \\\\\nPedestrian (Bird's Eye View) & 46.13  & 40.74  & 38.11 \\\\\n% Pedestrian (3D Detection) & 42.43  & 36.30  & 33.67 \\\\\n% Pedestrian (Bird's Eye View) & 47.83  & 42.08  & 39.63 \\\\\n\\hline\nCyclist (3D Detection) & 61.22  & 48.36  & 44.37 \\\\\nCyclist (Bird's Eye View) & 66.70  & 54.76  & 50.55  \\\\ \n\\hline\n\\end{tabular}\n}\n\\caption{Performance evaluation on KITTI test set.}\n\\label{table:test_set_result}\n\\end{table}"
        },
        "figures": {
            "fig:1st_figure": "\\begin{figure}[!ht]\n\\centering\n    \\includegraphics[width=0.9\\linewidth]{1st_figure_cartoon_new.png}\n\\caption{VoxelNet directly operates on the raw point cloud (no need for feature engineering)  and produces the 3D detection results using a single end-to-end trainable network. }\n%Car, pedestrian and cyclist are detected with 3D bounding boxes in green, yellow and cyan respectively. \n\\label{fig:1st_figure}\n\\end{figure}",
            "fig:VoxelNet_flowchart": "\\begin{figure*}[!th]\n\\centering\n    \\includegraphics[width=0.80\\linewidth]{VoxelNet_new.png}\n    \\vspace{-0.1cm}\n\\caption{VoxelNet architecture. The feature learning network takes a raw point cloud as input, partitions the space into voxels, and transforms points within each voxel to a vector representation characterizing the shape information. The space is represented as a sparse 4D tensor. The convolutional middle layers processes the 4D tensor to aggregate spatial context. Finally, a RPN generates the 3D detection.}\n\\label{fig:VoxelNet_flowchart}\n\\end{figure*}",
            "fig:VFE": "\\begin{figure}[!t]\n\\centering\n    \\includegraphics[width=0.8\\linewidth]{./VFE_layer.pdf}\n      \\vspace{-0.3cm}\n\\caption{Voxel feature encoding layer.}\n\\label{fig:VFE}\n\\end{figure}",
            "fig:RPN": "\\begin{figure*}[!t]\n\\centering\n    \\includegraphics[width=0.8\\linewidth]{RPN_new.pdf}\n    \\vspace{-0.3cm}\n\\caption{Region proposal network architecture.}\n\\label{fig:RPN}\n\\end{figure*}",
            "fig:Implementation": "\\begin{figure}[!t]\n\\centering\n    \\includegraphics[width=0.75\\linewidth]{Implementation.pdf}\n\\caption{Illustration of efficient implementation.}\n\\vspace{-0.3cm}\n\\label{fig:Implementation}\n\\end{figure}",
            "fig:Qualitative_demo": "\\begin{figure*}[!t]\n\\centering\n    \\begin{tabular}{ccc}\n    \\centering\n   \n\\vspace{-0.30cm}\n    % \\subfigure[]{\n         % \\label{fig:subfig:YaleB_1}\n        \\hspace{-0.75cm} \\includegraphics[width=0.38\\linewidth]{001755_vox_rgb.png} & \\hspace{-1.25cm}\n\n    % \\subfigure[]{\n        % \\label{fig:subfig:YaleB_2}\n        \\includegraphics[width=0.38\\linewidth]{005467_ped.png} & \\hspace{-1.25cm}\n\n    % \\subfigure[]{\n        % \\label{fig:subfig:YaleB_3}\n        \\includegraphics[width=0.38\\linewidth]{006407_cyclist.png} \\\\\n\n\\vspace{-0.30cm}\n\n    % \\hspace{-0.2cm}\n    % \\subfigure[]{\n         % \\label{fig:subfig:VoxelNet}\n        \\hspace{-0.75cm} \\includegraphics[width=0.38\\linewidth]{002254_vox_rgb.png} & \\hspace{-1.25cm}\n    % \\subfigure[]{\n        % \\label{fig:subfig:MV}\n        \\includegraphics[width=0.38\\linewidth]{005840_ped.png} & \\hspace{-1.25cm}\n    % \\subfigure[]{\n        % \\label{fig:subfig:Baseline}\n        \\includegraphics[width=0.38\\linewidth]{003763_cyclist.png} \\\\\n\n\\vspace{-0.30cm}\n\n    % \\hspace{-0.2cm}\n    % \\subfigure[]{\n         % \\label{fig:subfig:VoxelNet}\n        \\hspace{-0.75cm} \\includegraphics[width=0.38\\linewidth]{000519_car.png} & \\hspace{-1.25cm}\n    % \\subfigure[]{\n        % \\label{fig:subfig:MV}\n        \\includegraphics[width=0.38\\linewidth]{006210_ped.png} & \\hspace{-1.25cm}\n    % \\subfigure[]{\n        % \\label{fig:subfig:Baseline}\n        \\includegraphics[width=0.38\\linewidth]{000383_cyclist.png} \\\\\n\n\\vspace{-0.30cm}\n\n    % \\hspace{-0.2cm}\n    % \\subfigure[]{\n         % \\label{fig:subfig:VoxelNet}\n        \\hspace{-0.75cm} \\includegraphics[width=0.38\\linewidth]{000669_car.png} & \\hspace{-1.25cm}\n    % \\subfigure[]{\n        % \\label{fig:subfig:MV}\n        \\includegraphics[width=0.38\\linewidth]{005910_ped.png} & \\hspace{-1.25cm}\n    % \\subfigure[]{\n        % \\label{fig:subfig:Baseline}\n        \\includegraphics[width=0.38\\linewidth]{003677_cyclist.png} \\\\\n\n\n        \\hspace{-0.75cm} Car & \\hspace{-1.25cm} Pedestrian & \\hspace{-1.25cm} Cyclist \\\\\n    \\end{tabular}\n    %     \\caption{Qualitative results. The detection results are visualized in image plane after 3D bounding box projection and in 3D point cloud directly.}\n    % \\label{fig:Qualitative_vehicle}\n    \\caption{Qualitative results. For better visualization  3D boxes detected using LiDAR are projected on to the RGB images.}\n    \\label{fig:Qualitative_demo}\n\\end{figure*}"
        },
        "equations": {
            "eq:1": "\\begin{align}\n\\scriptsize\n    &\\Delta x = \\frac{x_c^g - x_c^a}{d^a} , \\Delta y = \\frac{y_c^g - y_c^a}{d^a} , \n    \\Delta z = \\frac{z_c^g - z_c^a}{h^a} , \\nonumber \\\\\n    &\\Delta l = \\log(\\frac{l^g}{l^a}) , \\Delta w = \\log(\\frac{w^g}{w^a}) , \\Delta h = \\log(\\frac{h^g}{h^a}) , \\\\\n    &\\Delta \\theta = \\theta^g - \\theta^a \\nonumber\n\\label{eqn:reg_targets}\n\\end{align}"
        }
    }
}