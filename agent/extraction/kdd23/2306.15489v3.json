{
    "meta_info": {
        "title": "Precursor-of-Anomaly Detection for Irregular Time Series",
        "abstract": "Anomaly detection is an important field that aims to identify unexpected\npatterns or data points, and it is closely related to many real-world problems,\nparticularly to applications in finance, manufacturing, cyber security, and so\non. While anomaly detection has been studied extensively in various fields,\ndetecting future anomalies before they occur remains an unexplored territory.\nIn this paper, we present a novel type of anomaly detection, called\nPrecursor-of-Anomaly (PoA) detection. Unlike conventional anomaly detection,\nwhich focuses on determining whether a given time series observation is an\nanomaly or not, PoA detection aims to detect future anomalies before they\nhappen. To solve both problems at the same time, we present a neural controlled\ndifferential equation-based neural network and its multi-task learning\nalgorithm. We conduct experiments using 17 baselines and 3 datasets, including\nregular and irregular time series, and demonstrate that our presented method\noutperforms the baselines in almost all cases. Our ablation studies also\nindicate that the multitasking training method significantly enhances the\noverall performance for both anomaly and PoA detection.",
        "author": "Sheo Yon Jhin, Jaehoon Lee, Noseong Park",
        "link": "http://arxiv.org/abs/2306.15489v3",
        "category": [
            "cs.AI"
        ],
        "additionl_info": "KDD 2023 accepted paper"
    },
    "latex_extraction": {
        "content": {
            "section 1": {
                "name": "Introduction",
                "content": "\n\nAnomaly detection is an important and difficult task that has been extensively studied for many real-world applications~\\citep{eskin2002geometric,zhang2013medmon,ten2011anomaly,goldstein2016comparative}. The goal of anomaly detection is to find unexpected or unusual data points and/or trends that may indicate errors, frauds, or other abnormal situations requiring further investigations.\n\n\\paragraph{\\textbf{Novel task definition:}} Among many such studies, one of the most popular setting is \\emph{multivariate time series anomaly detection} since many real-world applications deal with time series, ranging from natural sciences, finance, cyber security, and so on. Irregular time series anomaly detection~\\citep{wu2019lstm,liu2020deep,chandola2010anomaly} is of utmost importance since time series data is frequently irregular. Many existing time series anomaly detection designed for regular time series show sub-optimal outcomes when being applied to irregular time series. Irregular time series typically have complicated structures with uneven inter-arrival times.\n\nIn addition, it is also important to forecast whether there will be an anomaly in the future given a time series input, which we call \\emph{\\textbf{P}recursor-of-\\textbf{A}nomaly} (PoA) detection. The precursor-of-anomaly detection refers to the process of identifying current patterns/signs that may indicate upcoming abnormal events. The goal is to detect these precursors before actual anomalies occur in order to take preventive actions (cf. Fig.~\\ref{fig:comparison1}). The precursor-of-anomaly detection can be applied to various fields such as finance, medical care, and geophysics. For example, in finance, the precursor-of-anomaly detection can be used to identify unusual patterns in stock prices that may indicate a potential market collapse, and in geophysics, the precursor-of-anomaly detection can detect unusual geometric activities that can indicate earthquakes. Despite of its practical usefulness, the precursor-of-anomaly detection has been overlooked for a while due to its challenging nature except for a handful of work to detect earthquakes based on manual statistical analyses~\\citep{bhardwaj2017review,saraf2009advances,ghosh2009anomalous}.\n\nTo this end, we mainly focus on the following two tasks for multivariate and irregular time series: i) detecting whether the input time series sample has anomaly or not, i.e., detecting an anomaly, and ii) detecting whether anomaly will happen after the input time series sample, i.e., detecting the precursor-of-anomaly. In particular, we are the first detecting the precursor-of-anomaly for general domains. Moreover, we solve the two related problems at the same time with a single framework.\n\n\\paragraph{\\textbf{Novel method design:}} Our work is distinctive from existing work not only in its task definition but also in its deep learning-based method design. Recent anomaly detection methods can be divided into three main categories: i) clustering-based ii) density estimation-based iii) reconstruction-based methods. Clustering-based methods use historical data to identify and measure the distance between normal and abnormal clusters but can struggle to detect anomalies in complex data where distinct abnormal patterns are unknown~\\citep{agrawal2015survey}. Density estimation-based methods estimate a density function to detect anomalies. These methods assume that abnormal samples lie in a low density region. However, there is a limitation in data where the difference between low-probability normal and abnormal samples is not clear~\\citep{zong2018deep}. On the other hand, reconstruction-based methods aim to identify abnormal patterns by learning low-dimensional representations of data and detecting anomalies based on reconstruction errors. However, these methods may have limitations in modeling dependencies and temporal dependencies in time series, making them unsuitable for detecting certain types of anomalies~\\citep{an2015variational,zenati2018efficient}. To detect anomalies that may not be apparent in raw time-series, there are several advanced methods~\\citep{moghaddass2019anomaly,knorn2008adaptive}.\n\nIn this paper, we propose i) a unified framework of detecting the anomaly and precursor-of-anomaly based on neural controlled differential equations (NCDEs) and ii) its multi-task learning and knowledge distillation-based training algorithm with self-supervision. NCDEs are recently proposed differential equation-based \\emph{continuous-time recurrent neural networks} (RNNs), which have been widely used for irregular time series forecasting and classification. For the first time, we adopt NCDEs to time series (precursor of) anomaly detection. Our method, called (\\underline{\\textbf{P}}recursor of) \\underline{\\textbf{A}}nomaly \\underline{\\textbf{D}}etection (PAD), is able to provide both the anomaly and the precursor-of-anomaly detection capabilities.\n\n\nAs shown in Fig.~\\ref{fig:overall} there are two co-evolving NCDEs: i) the anomaly NCDE layer for the anomaly detection, ii) and the PoA NCDE layer for the precursor-of-anomaly detection. They are trained as a single unified framework under the multi-task training and knowledge distillation regime. Since our method is trained in a self-supervised manner, we resample the normal training dataset to create artificial anomalies (see Section ~\\ref{sec:data_augmentation}). To train the PoA NCDE layer, we apply a knowledge distillation method where the anomaly NCDE layer becomes as a teacher and the PoA NCDE becomes a student. By conducting a training by knowledge distillation, the PoA NCDE can inherit the knowledge of the anomaly NCDE. In other words, the PoA NCDE layer, which reads a temporal window up to time $i$, mimics the inference of the anomaly NCDE which reads a window up to time $i+1$ and decide whether it is an anomaly, which is a possible PoA detection approach since the PoA NCDE layer sees only past information. The two different NCDEs co-evolve while interacting with each other. At the end, our proposed method is trained for all the two tasks. They also partially share trainable parameters, which is a popular the multi-task design.\n\nWe performed experiments with 17 baselines and 3 datasets. In addition to the experiments with full observations, we also test after dropping random observations in order to create challenging detection environments. In almost all cases, our proposed method, called \\emph{PAD}, shows the best detection ability. Our ablation studies prove that the multi-task learning method enhances our method's capability. We highlight the following contributions in this work: \n\\begin{enumerate}\n    \\item We are the first solving the anomaly and the PoA detection at the same time.\n    \\item We propose PAD which is an NCDE-based unified framework for the anomaly and the PoA detection.\n    % \\item \\textcolor{red}{Knowledge distillation}\n    \\item To this end, we also design a multi-task and knowledge distillation learning method.\n    \\item In addition, the above learning method is conducted in a self-supervised manner. Therefore, we also design an augmentation method to create artificial anomalies for our self-supervised training.\n    \\item We perform a comprehensive set of experiments, including various irregular time series experiments. Our PAD marks the best accuracy in almost all cases.\n    \\item Our code is available at this link \\footnote{https://github.com/sheoyon-jhin/PAD}, and we refer readers to Appendix for the information on reproducibility.\n    \\end{enumerate}\n\n    \n"
            },
            "section 2": {
                "name": "Related Work",
                "content": "\n",
                "subsection 2.1": {
                    "name": "Anomaly Detection in Time Series",
                    "content": "\n\nAnomaly detection in time series data has been a popular research area in the fields of statistics, machine learning and data mining. Over the years, various techniques have been proposed to identify anomaly patterns in time series data, including machine learning algorithms, and deep learning models.\n\nMachine learning algorithms and deep learning-based anomaly detection methods in time series can be categorized into 4 methods including i) classical methods, ii) clustering-based methods, iii) density-estimation methods, iv) reconstruction-based methods. \n\nClassical methods find unusual samples using traditional machine learning methods such as OCSVM and Isolation Forest~\\citep{tax2004support,liu2008isolation}. \nClustering-based methods are a type of unsupervised machine learning method for detecting anomalies in time-series data such as Deep SVDD, ITAD, and THOC~\\citep{ruff2019deep,shin2020itad,shen2020timeseries}. This method splits the data into multiple clusters based on the similarity between the normal data points and then identifies abnormal data points that do not belong to any clusters. However, clustering-based methods are not suitable for complex data to train. Density-estimation-based methods~\\citep{breunig2000lof,yairi2017data} are a type of unsupervised machine learning method for detecting anomalies in time series data such as LOF. In density-estimation based anomaly detection, the time-series data is transformed into a feature space, and the probability density function of the normal data points is estimated using techniques such as kernel density estimation or gaussian mixture models. The data points are then ranked based on their density, and anomalies are identified as data points that have low density compared to the normal data points. However, this method may not perform well in cases where the data contains significant non-stationary patterns or where the anomalies are not well represented by the estimated density function. Additionally, this method can also be computationally expensive, as it requires estimating the density function for the entire data. Reconstruction-based methods are~\\citep{park2018multimodal,su2019robust, audibert2020usad, li2021multivariate} a representative methodology for detecting anomalies in time series data such as USAD~\\citep{audibert2020usad}. In this method, a deep learning model reconstructs normal time-series data and then identifies abnormal time-series data with high reconstruction errors. Also, reconstruction-based methods can be effective in detecting anomalies in time-series data, especially when the anomalies are not well separated from the normal data points and the data contains complex patterns. The reconstruction-based methods are also robust to missing values and noisy data, as the reconstructed data can be used to fill in missing values and reduce the impact of noise. However, this method can be sensitive to the choice of reconstruction model, and may not perform well in cases where the anomalies are not well represented by the reconstruction model. Additionally, this method may be computationally expensive, as it requires training a complex model on the data.\n\nIn this paper, we mainly focus on self-supervised learning-based anomaly detection. Anomaly detection methods based on self-supervised learning have been extensively studied~\\citep{cutpaste2021,puzzleae,ijcai2022p394,https://doi.org/10.48550/arxiv.2007.08176}. Unlike the unsupervised-learning method, self-supervised learning learns using negative samples generated by applying data augmentation to the training data~\\citep{ijcai2022p394,https://doi.org/10.48550/arxiv.2007.08176}. Data augmentation can overcome the limitations of existing training data. In this paper, we train our method, PAD, on time series dataset generated by data augmentation. \n\n% \\textcolor{red}{On the other hand, autogregressive methods~\\citep{tariq2019detecting,Anderson1976TimeSeries2E} are based on prediction, such as VAR and LSTM. autogregressive methods divide the input time series sample into past and future sequences and use the past sequence to predict the future sequence. This model detects an anomaly sequence based on the difference between the predicted future value and the ground-truth of the future sequence. The auto-regressive-based model uses the past and future sequence as the input for the anomaly detection, however, our proposed method, PAD, uses only the past sequence as the input for the anomaly detection.}\n\n\n\n\n% \\subsubsection{Precursor-of-anomaly detection} In this section, we clearly tell precursor-of-anomaly detection from conventional anomaly detection. As we said before, conventional anomaly detection is to figure out whether a given time series sample is anomalous (unusual). However, precursor-of-anomaly detection wants to know that future observations forecast from the given time series are likely to be anomalous, regardless of the given time series. (cf. Fig.~\\ref{fig:comparison1})\n\n\n"
                },
                "subsection 2.2": {
                    "name": "Neural Controlled Differential Equations",
                    "content": "\nRecently, differential equation-based deep learning models have been actively researched. Neural controlled differential equations (NCDEs) are a type of machine learning method for modeling and forecasting time-series data. NCDE combines the benefits of neural networks and differential equations to create a flexible and powerful model for time-series data.\nUnlike traditional time series models (e.g., RNNs), differential equation-based neural networks estimate the continuous dynamics of hidden vectors $\\mathbf{z(t)}$ (i.e., $\\frac{d\\mathbf{z(t)}}{dt}$). Neural ordinary differential equations (NODEs) use the following equations to model a hidden dynamics~\\citep{NIPS2018_7892}:\n\\begin{align}\n    \\mathbf{z}(T) = \\mathbf{z}(0) + \\int_{0}^{T}f(\\mathbf{z}(t),t;\\mathbf{\\theta}_f)dt.\n\\end{align}\n\nIn contrast to NODEs, neural controlled differential equations (NCDEs) utilize the riemann–stieltjes integral~\\citep{NEURIPS2020_4a5876b4}. Let $\\{\\mathbf{x}_i\\}_{i=0}^N$ be time series observations whose length is $N$ and $\\{t_i\\}_{i=0}^N$ be its observation time-points. NCDEs can be formulated as the following equations:\n% NCDEs, a continuous analogue to RNNs,\n% NCDEs are considered more advanced than NODEs since NODEs are theoretically a special case of NCDEs --- e.g., Eq.~\\eqref{eq:ncde} reduces to Eq.~\\eqref{eq:node} when $\\frac{dX(t)}{dt} = 1$. \n\\begin{align}\n\\mathbf{z}(T) &= \\mathbf{z}(0) + \\int_{0}^{T} f(\\mathbf{z}(t);\\mathbf{\\theta}_f) dX(t),\\\\\n &=\\mathbf{z}(0) + \\int_{0}^{T} f(\\mathbf{z}(t);\\mathbf{\\theta}_f) \\frac{dX(t)}{dt} dt,\\label{eq:ncde}\n\\end{align} where $X(t)$ is a continuous time series path  interpolated from $\\{(\\mathbf{x}_i, \\mathbf{t}_i)\\}_{i=0}^N$. With interpolation methods, we can obtain a continuous time series path from discrete observations $\\{(\\mathbf{x}_i, \\mathbf{t}_i)\\}_{i=0}^N$. Typically, natural cubic spline~\\citep{mckinley1998cubic} is used as the interpolation method --- note that the adaptive step size solver works properly if the path $X(t)$ is twice continuously differentiable~\\citep{NEURIPS2020_4a5876b4}.\n\n\nThe main difference between NODEs and NCDEs is the existence of the continuous time series path $X(t)$. NCDEs process a hidden vector $\\mathbf{z}(t)$ along the interpolated path $X(t)$. (cf. Fig.~\\ref{fig:ncde}) In this regard, NCDEs can be regarded as a continuous analogue to RNNs. Because there exists $X(t)$, NCDEs can learn what NODEs cannot (See Theorem C.1 in~\\citep{NEURIPS2020_4a5876b4}). Additionally, NCDEs have the ability to incorporate domain-specific knowledge into the model, by using expert features as inputs to the neural networks. This can improve the performance and robustness of the model, as well as provide a deeper understanding of the relationships between the variables in the data. Therefore, NCDEs enable us to model more complex patterns in continuous time series. \n% Also, both NCDEs and NODEs can use an adjoint sensitivity method which can reduce the space complexity of gradient calculation, compared to a conventional backpropagation method.\n% Because of these characteristics, we use NCDEs in our model.\n\n"
                },
                "subsection 2.3": {
                    "name": "Knowledge Distillation",
                    "content": " \nKnowledge distillation~\\citep{hinton2015distilling} is a technique used to transfer knowledge from large, complex models to smaller, simpler models. In the context of time series data, knowledge distillation can be used to transfer knowledge from complex deep learning models to smaller, more efficient models.\nThe knowledge extraction process involves training complex models such as deep neural networks on large datasets of time series data. The complex model is then used to generate predictions for the same data set. These predictions are then used to train simpler models such as linear regression models or decision trees. In this paper, we use these predictions in precursor-of-anomaly detection.\nDuring the training process, simpler models are optimized to minimize the difference between their predictions and those of complex models. This allows simple models to learn patterns and relationships in time series data captured by complex models.\nFurthermore, knowledge distillation can also help improve the interpretability of the model. The simpler model can be easier to understand and analyze, and the knowledge transferred from the complex model can provide insights into the important features and relationships in the time-series data.\nThe advantages of distilling knowledge from time series include faster and more efficient model training, reduced memory requirements, and improved interpretability of the model~\\citep{ay2022study,xu2022contrastive}.\n\n"
                },
                "subsection 2.4": {
                    "name": "Multi-task Learning",
                    "content": "\nMulti-task learning (MTL) is a framework for learning multiple tasks jointly with shared parameters, rather than learning them independently~\\citep{zhang2021survey}. By training multiple tasks simultaneously, MTL can take advantage of shared structures between tasks to improve the generalization performance of each individual task.\nSeveral different MTL architectures have been proposed in the literature, including hard parameter sharing, soft parameter sharing, and task-specific parameter sharing~\\citep{ruder2017overview}.\nHard parameter sharing involves using a shared set of parameters for all tasks, while soft parameter sharing allows for different parameter sets for each task, but encourages them to be similar. Task-specific parameter sharing has their own set of task-specific parameters for each task, and lower-level parameters are shared between tasks. This approach allows for greater task-specific adaptation while still leveraging shared information at lower levels. \n\nOne of the major challenges of MTL is balancing task-specific and shared representation. Using more shared representations across tasks yields better generalization and performance across all tasks, but at the expense of task-specific information. Therefore, the choice of MTL architecture and the amount of information shared between tasks depends on the specific problem and task relationship. In this paper, we train our model with a task-specific parameter sharing architecture considering shared information and task relationships.\nMTL is applied to various areas such as natural language processing, computer vision. In natural language processing, MTL has been used for tasks such as named entity recognition, part-of-speech tagging, and sentiment analysis~\\citep{chen2021multi}. In computer vision, MTL has been used for tasks such as object recognition, object detection, and semantic segmentation~\\citep{liu2019end}. \n   \nThese architectures have demonstrated promising results on several benchmark datasets, and in this paper, we conduct research on time-series anomaly detection using MTL, showing excellent performance for all 17 baselines. \n\n\n\n\n"
                }
            },
            "section 3": {
                "name": "Proposed Method",
                "content": "\nIn this section, we describe the problem statement of our window-based time series anomaly and precursor-of-anomaly detection in detail and introduce the overall architecture of our proposed method, PAD, followed by our NCDE-based neural network design, its multi-task learning strategy and the knowledge distillation.\n\n",
                "subsection 3.1": {
                    "name": "Problem Statement",
                    "content": "\n\nIn this section, we define the anomaly detection and the precursor-of-anomaly detection tasks in irregular time series settings --- those problems in the regular time series setting can be similarly defined. \n\nIn our study, we focus on multivariate time series, defined as $\\mathbf{x}_{0:T}=\\{\\mathbf{x}_0,\\mathbf{x}_1,...,\\mathbf{x}_T\\}$, where $T$ is the time-length. An observation at time $t$, denoted $\\mathbf{x}_t$, is an $N$-dimensional vector, i.e., $\\mathbf{x}_t \\in \\mathbb{R}^N$. For irregular time-series, the time-interval between two consecutive observations is not a constant --- for regular time-series, the time-interval is fixed. We use a window-based approach where time series $\\mathbf{x}_{0:T}$ is divided into non-overlapping windows, i.e., $\\mathbf{w}_{i} = [\\mathbf{x}_{t^i_0},\\mathbf{x}_{t^i_1},...,\\mathbf{x}_{t^i_b}]$ where $t^i_j = i  \\times b + j - 1$ with a window size of $b$. There are $\\lceil \\frac{T}{b} \\rceil$ windows in total for $\\mathbf{x}_{0:T}$. Each window is individually taken as an input to our network for the anomaly or the precursor-of-anomaly detection.\n\nGiven an input window $\\mathbf{w}_i$, for the anomaly detection, our neural network decides whether $\\mathbf{w}_i$ contains abnormal observations or not, i.e., a binary classification of anomaly vs. normal. On the other hand, it is determined whether the very next window $\\mathbf{w}_{i+1}$ is likely to contain abnormal observations for the precursor-of-anomaly detection, i.e., yet another binary classification.\n\n"
                },
                "subsection 3.2": {
                    "name": "Overall Workflow",
                    "content": "\n\nFig.~\\ref{fig:overall} shows the detailed design of our method, PAD. The overall workflow is as follows: \n\n\\begin{enumerate}\n    \\item For self-supervised learning, we create augmented training data with data augmentation techniques (see Section~\\ref{sec:data_augmentation}).\n    % \\item The continuous path $X(t)$ is created from discrete time series observations $\\mathbf{x}_{0:T}$ by an interpolation algorithm. \n    % \\item The feature extractor creates the two initial hidden representations $\\mathbf{h}(0)$ and $\\mathbf{z}(0)$ from $\\mathbf{x}_0$ in Eq.~\\ref{eq:co-evolving_ncde}.\n    \\item There are two co-evolving NCDE layers which produce the last hidden representations $\\mathbf{h}(T)$ and $\\mathbf{z}(T)$ in Eq.~\\eqref{eq:co-evolving_ncde}.\n    \\item In the training progress, the anomaly NCDE gets two inputs, $w_i$ for the anomaly detection and $w_{i+1}$ for the PoA detection. \n    \\item There are 2 output layers for the anomaly detection and the PoA detection, respectively. These two different tasks are integrated into a single training method via our shared parameter $\\theta_c$ for multi-task learning. \n    \\item In the training progress, the anomaly NCDE creates the two outputs $\\hat{y}^a_i$ and $\\hat{y}^a_{i+1}$ for the knowledge distillation.\n\\end{enumerate}\n\n\n"
                },
                "subsection 3.3": {
                    "name": "Neural Network Architecture based on Co-evolving NCDEs",
                    "content": "\nWe describe our proposed method based on dual co-evolving NCDEs: one for the anomaly detection and the other for the precursor-of-anomaly (PoA) detection. Given a discrete time series sample $\\mathbf{x}_{1:T}$, we create a continuous path $X(t)$ using an interpolation method, which is a pre-processing step of NCDEs. After that, the following co-evolving NCDEs are used to derive the two hidden vectors $\\mathbf{h}(T)$ and $\\mathbf{z}(T)$:\n\\begin{align}\\begin{split}\n    &\\mathbf{h}(T) = \\mathbf{h}(0) + \\int_{0}^{T} f(\\mathbf{h}(t);\\mathbf{\\theta}_f,\\mathbf{\\theta}_c) \\frac{dX(t)}{dt} dt,\\\\\n    &\\mathbf{z}(T)=\\mathbf{z}(0) + \\int_{0}^{T} g(\\mathbf{z}(t);\\mathbf{\\theta}_g,\\mathbf{\\theta}_c) \\frac{dX(t)}{dt} dt,\n\\end{split}\\label{eq:co-evolving_ncde}\\end{align} where the two functions (neural networks) $f$ and $g$ have their own parameter and shared parameter $c$ \n\nFor instance, $\\mathbf{\\theta}_f$ is specific to the function $f$ whereas $\\mathbf{\\theta}_c$ is a common parameter shared by $f$ and $g$. The exact architectures of $f$ and $g$ are as follows:\n\\begin{align}\n    f(\\mathbf{h}(t);\\theta_f,\\theta_c) &= \\underbrace{\\rho(\\texttt{FC}(\\phi(\\texttt{FC}(\\mathbf{h}(t)))))}_{\\theta_f}+ \\underbrace{\\rho(\\texttt{FC}(\\phi(\\texttt{FC}(\\mathbf{h}(t)))))}_{\\theta_c},\\\\\n    g(\\mathbf{z}(t);\\theta_g,\\theta_c) &= \\underbrace{\\rho(\\texttt{FC}(\\phi(\\texttt{FC}(\\mathbf{z}(t)))))}_{\\theta_g}+ \\underbrace{\\rho(\\texttt{FC}(\\phi(\\texttt{FC}(\\mathbf{z}(t)))))}_{\\theta_c}\n\\end{align}\nwhere $\\phi$ means the rectified linear unit (ReLU) and $\\rho$ means the hyperbolic tangent. \n\nTherefore, our proposed architecture falls into the category of \\emph{task-specific parameter sharing} of the multi-task learning paradigm. We perform the anomaly detection task and the PoA detection tasks with $\\mathbf{h}(T)$ and $\\mathbf{z}(T)$, respectively. We ensure that the two NCDEs co-evolve by using the shared parameters $\\theta_c$ that allow them to influence each other during the training process. Although those two tasks' goals are ultimately different, those two tasks share common characteristics to some degree, i.e., capturing key patterns from time series. By controlling the sizes of $\\mathbf{\\theta}_f$, $\\mathbf{\\theta}_g$, and $\\mathbf{\\theta}_c $, we can control the degree of their harmonization. After that, we have the following two output layers:\n\\begin{align}\n\\hat{y}_{i}^a=&\\sigma(\\texttt{FC}_{\\theta_a}(\\mathbf{h}(T))),\\textrm{ for the anomaly detection},\\\\\n\\hat{y}_{i}^p=&\\sigma(\\texttt{FC}_{\\theta_p}(\\mathbf{z}(T))),\\textrm{ for the precursor-of-anomaly detection},\\label{eq:pd}\n\\end{align} where each fully-connected (\\texttt{FC}) layer is defined for each task and $\\sigma$ is the sigmoid activation for binary classification.\n\nWhen implementing the co-evolving NCDEs, we implement the following augmented state and solve the two initial value problems in Eq.~\\eqref{eq:co-evolving_ncde} at the same time with an ODE solver:\n\\begin{align} \\label{eq3}\n\\frac{d}{dt}{\\begin{bmatrix}\n  \\mathbf{h}(t) \\\\\n  \\mathbf{z}(t)\n  \\end{bmatrix}\\!} = {\\begin{bmatrix}\n  f(\\mathbf{h}(t);\\mathbf{\\theta}_f,\\mathbf{\\theta}_c) \\frac{dX(t)}{dt} \\\\\n  g(\\mathbf{z}(t);\\mathbf{\\theta}_g,\\mathbf{\\theta}_c) \\frac{dX(t)}{dt}\n  \\end{bmatrix},\\!}\n\\end{align} and \n% \\vspace{-2em}\n\\begin{align}\n{\\begin{bmatrix}\n  \\mathbf{h}(0) \\\\\n  \\mathbf{z}(0)\n  \\end{bmatrix}\\!} = {\\begin{bmatrix}\n  \\texttt{FC}_{\\theta_\\mathbf{h}}(X(0)) \\\\\n  \\texttt{FC}_{\\theta_\\mathbf{z}}(X(0))\n  \\end{bmatrix}.\\!}\n\\end{align}\n\n\\paragraph{\\textbf{Well-posedness of the problem:}} The well-posedness of the initial value problem of NCDEs was proved in previous work, such as~\\citep{lyons2004differential,NEURIPS2020_4a5876b4} under the condition of Lipschitz continuity, which means that the optimal form of the last hidden state at time $T$ is uniquely defined given an training objective. Our method, PAD, also has this property, as almost all activation functions (e.g. ReLU, Leaky ReLU, Sigmoid, ArcTan, and Softsign) have a Lipschitz constant of 1~\\citep{NEURIPS2020_4a5876b4}. Other neural network layers, such as dropout, batch normalization, and pooling methods, also have explicit Lipschitz constant values. Therefore, Lipschitz continuity can be fulfilled in our case.\n\n\n\n"
                },
                "subsection 3.4": {
                    "name": "Training Algorithm",
                    "content": "\\label{sec:training_alg}\n\n\\paragraph{\\textbf{Loss function:}} We use the cross-entropy (CE) loss to train our model. $L_{KD}$ and $L_a$ mean the CE loss for the knowledge distillation and the anomaly detection, respectively:\n% In Alg.~\\ref{alg:train}, those loss functions are denoted as $L_a$, $L_t$, and $L_p$, respectively.\n\\begin{align}\n    \\begin{split}\\label{eq:kd_loss_function}\n        L_{KD} &= CE(\\hat{y}^a_{i+1},\\hat{y}^p_{i+1}), \\\\\n    \\end{split}\n\\end{align} where $\\hat{y}^a_{i+1}$ denotes the anomaly NCDE model's output, $\\hat{y}^p_{i+1}$ denotes the PoA NCDE model's output and \n\\begin{align}\n\\begin{split}\\label{eq:anomaly_loss_function}\n        L_a &= CE(\\hat{y}^a_i,y_i),\\\\\n    \\end{split}\n\\end{align}\nwhere $y_i$ denotes the ground-truth of anomaly detection. As shown in Eq.~\\eqref{eq:kd_loss_function}, we use the cross entropy (CE) loss between $\\hat{y}^a_{i+1}$ and $\\hat{y}^p_{i+1}$ to distill the knowledge of the anomaly NCDE into the PoA NCDE. \n\\paragraph{\\textbf{Training with the adjoint method:}}\n\nWe train our method using the adjoint sensitivity method ~\\citep{NIPS2018_7892,pontryagin1962the,giles2000an,hager2001runge}, which requires a memory of $\\mathcal{O}(T+H)$ where $T$ is the integral time domain and $H$ is the size of the NCDE's vector field. This method is used in Lines~\\ref{alg:train1} to ~\\ref{alg:train2} of Alg.~\\ref{alg:train}. However, our framework uses two NCDEs, which increases the required memory to $\\mathcal{O}(2T + H_f + H_g)$, where $H_f$ and $H_g$ are the sizes of the vector fields for the two NCDEs, respectively. \n\nTo train them, we need to calculate the gradients of each loss w.r.t. the parameters $\\theta_f$, $\\theta_g$, and $\\theta_c$. In this paragraph, we describe how we can space-efficiently calculate them. The gradient to train each parameter can be defined as follows:\n% of $L_{\\mathbf{h}}$ w.r.t. $\\mathbf{\\theta}_f$ can be calculated as follows:\n\n\\begin{align}\n    \\begin{split}\n        \\nabla_{\\mathbf{\\theta}_f} L_a &= -\\int^{0}_{T}\\frac{\\partial L_a}{\\partial\\mathbf{h}(t)}^T\\frac{\\partial f(\\mathbf{h}(t),t;\\theta_f,\\theta_c)}{\\partial \\theta_f} \\frac{dX(t)}{dt} dt,\\\\\n        \\nabla_{\\mathbf{\\theta}_f} L_{KD} &= -\\int^{0}_{T}\\frac{\\partial L_{KD}}{\\partial\\mathbf{h}(t)}^T\\frac{\\partial f(\\mathbf{h}(t),t;\\theta_f,\\theta_c)}{\\partial \\theta_f}\\frac{dX(t)}{dt} dt,\\\\\n        \\nabla_{\\mathbf{\\theta}_g} L_{KD} &= -\\int^{0}_{T}\\frac{\\partial L_{KD}}{\\partial\\mathbf{z}(t)}^T\\frac{\\partial g(\\mathbf{z}(t),t;\\theta_g,\\theta_c)}{\\partial \\theta_g}\\frac{dX(t)}{dt} dt,\\\\\n         \\nabla_{\\mathbf{\\theta}_c} L_a + L_{KD}&= -\\int^{0}_{T}\\frac{\\partial L_a + L_{KD}}{\\partial\\mathbf{h}(t)}^T\\frac{\\partial f(\\mathbf{h}(t),t;\\theta_f,\\theta_c)}{\\partial \\theta_c} \\frac{dX(t)}{dt} dt \\\\\n        & -\\int^{0}_{T}\\frac{\\partial L_a + L_{KD}}{\\partial\\mathbf{z}(t)}^T\\frac{\\partial g(\\mathbf{z}(t),t;\\theta_g,\\theta_c)}{\\partial \\theta_c} \\frac{dX(t)}{dt} dt.\n    \\end{split}\n\\end{align}\n\n\n\\begin{algorithm}[t]\n\\SetAlgoLined\n\\caption{How to train PAD}\\label{alg:train}\n\\KwIn{Training data $D_{train}$, Validating data $D_{val}$, Maximum iteration number $max\\_iter$}\n% \\KwOut{$\\mathbf{\\theta}$, $(d,t) \\in H$, and $\\alpha_{i,j}$ for all $i,j$}\n\\tcc{$\\mathbf{\\theta}_{others} = \\{\\theta_\\mathbf{h}, \\theta_\\mathbf{z}, \\mathbf{\\theta}_a, \\mathbf{\\theta}_t, \\mathbf{\\theta}_p\\}$}\nInitialize $\\mathbf{\\theta}_f$, $\\mathbf{\\theta}_g$, $\\mathbf{\\theta}_c$, and $\\mathbf{\\theta}_{others}$;\n\n$k \\gets 0$;\n\n\\While {$k < max\\_iter$}{\n    Train $\\mathbf{\\theta}_f$ and $\\mathbf{\\theta}_{others}$ with $L_a$;\\\\ \\label{alg:train1}\n    Train $\\mathbf{\\theta}_g$  and $\\mathbf{\\theta}_{others}$ with $L_{KD}$;\\\\ \\label{alg:train2}\n    Train the common parameter $\\mathbf{\\theta}_c$ with $L_a, L_{KD}$;\\\\  \n    Validate and update the best parameters, $\\mathbf{\\theta}^*_f$, $\\mathbf{\\theta}^*_g$,$\\mathbf{\\theta}^*_c$, $\\mathbf{\\theta}^*_{others}$ with $D_{val}$\\;\n    $k \\gets k + 1$;\n}\n\\Return $\\mathbf{\\theta}^*_f$, $\\mathbf{\\theta}^*_g$, $\\mathbf{\\theta}^*_c$, and $\\mathbf{\\theta}^*_{others}$;\n\\end{algorithm}\n\n"
                },
                "subsection 3.5": {
                    "name": "Data Augmentation Methods for Self-supervised Learning",
                    "content": " \\label{sec:data_augmentation}\nIn general, the dataset for anomaly detection do not provide labels for training samples but have labels only for testing samples. Thus, we rely on the self-supervised learning technique. We mainly use re-sampling methods for data augmentation, and we resort to the following steps for augmenting training samples with anomalous patterns:\n\\begin{enumerate}\n    \\item Maintain an anomaly ratio $\\gamma = \\frac{L}{T}$ for each dataset;\n    \\item The starting points $t_{start}$ of anomaly data points are all designated randomly;\n    \\item The length vector $\\textbf{l}$ of abnormal data  are randomly selected between sequence 100 to sequence 500;\n    \\item The re-sampled data is randomly selected from the training samples. \n\\end{enumerate}\n\n% $L = \\sum^{N}_{i=1} l_i$ , $T = \\sum^M_{j=1} t_j$. \n$L$ is the total length of abnormal data points, and $T$ is the total length of data points. A detailed data augmentation algorithm is in Appendix.\n% \\textcolor{red}{We transform $n$ data points out of the total $N$ data points to maintain the anomaly ratio in the training sample. Then we randomly select $n$ data points and convert them to anomaly data points as long as the random length.}\n\n\n% We apply all the following transformation methods simultaneously for each training time series sample to implant synthetic anomalies with their labels~\\citep{wen2019time,ronneberger2015u,DBLP:journals/corr/abs-2002-12478} --- Fig.~\\ref{fig:data_aug} (b) (highlighted in yellow) is an example of augmented time series from the original time series in Fig.~\\ref{fig:data_aug} (a):\n% \\begin{enumerate}\n%     \\item The time-warp transforms the time derivative of observed values.\n%     \\item The data maximization maximizes observed values, i.e., we replace a value with its maximum value.\n%     \\item The time-reverse reverse the observed values.\n%     \\item The noise addition adds gaussian noises to observed values. \n%     \\item The concatenating resampling method concatenate anomaly resampled values and original values. \n% \\end{enumerate}\n\n% data augmentation 방법에 대한 설명 추가\n% \\begin{figure}\n%     \\centering\n%     \\subfigure[Original time series on MSL]{\\includegraphics[width=0.46\\columnwidth]{images/org_exp202.pdf}} \\hfill\n%     \\subfigure[Augmented time series on MSL]{\\includegraphics[width=0.46\\columnwidth]{images/aug_exp2022.pdf}}\n%     % {\\includegraphics[width=0.45\\columnwidth]{images/google/0_google_25_new_new.pdf}}\n%     \\caption{Comparison between original vs. transformed time series with anomalies}\n%     \\label{fig:data_aug}\n%     \\vspace{-1em}\n% \\end{figure}\n\n\n"
                }
            },
            "section 4": {
                "name": "Experiments",
                "content": "\nIn this section, we describe our experimental environments and results. All experiments were conducted in the following software and hardware environments: \\textsc{Ubuntu} 18.04 LTS, \\textsc{Python} 3.8.13, \\textsc{Numpy} 1.21.5, \\textsc{Scipy} 1.7.3, \\textsc{Matplotlib} 3.3.1, \\textsc{PyTorch} 1.7.0, \\textsc{CUDA} 11.0, \\textsc{NVIDIA} Driver 417.22, i9 CPU, and \\textsc{NVIDIA RTX 3090}. \n\n\n",
                "subsection 4.1": {
                    "name": "Datasets",
                    "content": "\n\n\n\\paragraph{\\textbf{Mars Science Laboratory:}}\nThe mars science laboratory (MSL) dataset is also from NASA, which was collected by a spacecraft en route to Mars. This dataset is a publicly available dataset from NASA-designated data centers. It is one of the most widely used dataset for the anomaly detection research due to the clear distinction between pre and post-anomaly recovery. It is comprised of the health check-up data of the instruments during the journey. This dataset is a multivariate time series dataset, and it has 55 dimensions with an anomaly ratio of approximately 10.72\\%~\\citep{hundman2018detecting}.\n\n\\paragraph{\\textbf{Secure Water Treatment:}}\nThe secure water treatment (SWaT) dataset is a reduced representation of a real industrial water treatment plant that produces filtered water. This data set contains important information about effective measures that can be implemented to avoid or mitigate cyberattacks on water treatment facilities. The data set was collected for a total of 11 days, with the first 7 days collected under normal operating conditions and the subsequent 4 days collected under simulated attack scenarios. SWaT has 51 different values in an observation and an anomaly ratio of approximately 11.98\\%~\\citep{goh2017dataset}.\n\n\\paragraph{\\textbf{Water Distribution:}}\nThe water distribution (WADI) data set is compiled from the WADI testbed, an extension of the SWaT testbed. It is measured over 16 days, of which 14 days are measured in the normal state and 2 days are collected in the state of the attack scenario. WADI has 123 different values in an observation and an anomaly ratio of approximately 5.99\\%~\\citep{mathur2016swat}.\n\n% \\paragraph{\\textbf{Soil Moisture Active Passive:}}\n% The soil moisture active passive (SMAP) dataset is a publicly available dataset from NASA-designated data centers. It contains a range of telemetry data such as radiation, temperature, power, and computational activities. It is one of the most widely used dataset for the anomaly detection research due to the clear distinction between pre and post-anomaly recovery. The SMAP dataset is a multivariate time series dataset with 25 dimensions and an anomaly ratio of approximately 13.13\\%~\\citep{hundman2018detecting}.\n% \\paragraph{\\textbf{Sever Machine Dataset:}}\n% The sever machine dataset (SMD) is a publicly available dataset that had been gathered by a major Internet company. It is composed of data from 28 different servers and includes various performance metrics such as CPU load, network usage, and memory usage. SMD has 38 different values in an observation and an anomaly ratio of approximately 4.16\\%~\\citep{su2019robust}.\n\n\n\n\n\n% \\begin{table*}[t]\n% \\caption{Experimental results for the anomaly detection on 3 regular time-series datasets. P, R, and F1 denote Precision, recall and F1 score as \\%, respectively. The best scores are in bold face.}\\label{tbl:result}\n% % \\renewcommand{\\arraystretch}{1.05}%#{1.4}\n% \\begin{tabular}{cclllllllll}\n% \\hline\n% \\multicolumn{2}{c}{Datasets}                                 & \\multicolumn{3}{c}{SMD} & \\multicolumn{3}{c}{MSL} & \\multicolumn{3}{c}{SMAP} \\\\ \\hline\n% \\multicolumn{2}{c}{Methods}                                   & P      & R      & F1    & P      & R      & F1    & P      & R      & F1     \\\\ \\hline\n% \\multicolumn{1}{c|}{\\multirow{2}{*}{Classical Methods}} &\n%   \\multicolumn{1}{c|}{OCSVM} \n%   & 44.34  & 76.72 & 56.19  & 59.78  & 86.87 & 70.82   & 53.85  & 59.07 & 56.34 \\\\ \n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{Isolation Forest} \n%  &42.31  & 73.29 & 53.64  & 53.94  & 86.54 & 66.45   & 52.39  & 59.07 & 55.53  \\\\ \\hline\n% \\multicolumn{1}{c|}{\\multirow{3}{*}{\\begin{tabular}[c]{@{}c@{}}Clustering-based\\\\ Methods\\end{tabular}}} &\n%   \\multicolumn{1}{c|}{Deep-SVDD} \n%   & 78.54  & 79.67 & 79.10  & 91.92  & 76.63 & 83.58   & 89.93  & 56.02 & 69.04 \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{ITAD}          \n% & 86.22  & 73.71 & 79.48  & 69.44  & 84.09 & 76.07   & 82.42  & 66.89 & 73.85  \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{THOC}        \n%  & 79.76  & 90.95 & 84.99  & 88.45  & 90.97 & 89.69   & 92.06  & 89.34 & 90.68  \\\\ \\hline\n% \\multicolumn{1}{c|}{\\multirow{3}{*}{\\begin{tabular}[c]{@{}c@{}}Density-estimation-based\\\\ Methods\\end{tabular}}} &\n%   \\multicolumn{1}{c|}{LOF} \n%   & 56.34  & 39.86 & 46.68  & 81.17  & 81.44 & 81.23   & 58.93  & 56.33 & 57.60 \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{DAGMM}          \n% & 67.30  & 49.89 & 57.30  & 89.60  & 63.93 & 74.62   & 86.45  & 56.73 & 68.51  \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{MMPCACD}        \n% & 71.20  & 79.29 & 75.02  & 81.42  & 61.31 & 69.95   & 88.61  & 75.84 & 81.73  \\\\ \\hline\n% \\multicolumn{1}{c|}{\\multirow{8}{*}{\\begin{tabular}[c]{@{}c@{}}Reconstruction-based\\\\ Methods\\end{tabular}}} &\n%   \\multicolumn{1}{c|}{VAR} \n% &78.35  & 70.26 & 74.08  & 74.68  & 81.42 & 77.90   & 81.38  & 53.88 & 64.83\\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{LSTM}            \n%  & 78.55  & 85.28 & 81.78  & 85.45  & 82.50 & 83.95   & 89.41  & 78.13 & 83.39  \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{CL-MPPCA}        \n% & 82.36  & 76.07 & 79.09  & 73.71  & 88.54 & 80.44   & 86.13  & 63.16 & 72.88  \\\\ \n%  \\multicolumn{1}{c|}{} &\\multicolumn{1}{c|}{LSTM-VAE} \n% & 75.76  & 90.08 & 82.30  & 85.49  & 79.94 & 82.62   & 92.20  & 67.75 & 78.10 \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{BeatGAN}            \n% & 72.90  & 84.09 & 78.10  & 89.75  & 85.42 & 87.53   & 92.38  & 55.85 & 69.61  \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{OmniAnomay}        \n% & 83.68  & 86.82 & 85.22  & 89.02  & 86.37 & 87.67   & 92.49  & 81.99 & 86.92  \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{USAD}            \n% & 93.14  & 96.17 & 93.82  & 88.10  & 97.86 & 91.09   & 76.97  & 98.31 & 81.86  \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{InterFusion}            \n% & 87.02  & 85.43 & 86.22  & 81.28  & 92.70 & 86.62   & 89.77  & 88.52 & 89.14  \\\\\n% \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{Anomaly Transformer}  \n% & 88.48  & 92.07 & 90.24  & 91.82  & 91.23 & 91.53   & 87.05  & 99.41 & 92.82  \\\\\\hline\n% \\multicolumn{1}{c|}{\\multirow{1}{*}{Ours}} &\n%   \\multicolumn{1}{c|}{\\textbf{PAD} (Anomaly)}\n%   & 93.43  & 94.76 &\\textbf{94.09}  & 94.96  & 95.44 & \\textbf{94.98}   & 95.83  & 96.60 & \\textbf{95.35}\\\\  \\hline\n% \\end{tabular}\n% \\end{table*}\n\n"
                },
                "subsection 4.2": {
                    "name": "Experimental Settings",
                    "content": "\n\n",
                    "subsubsection 4.2.1": {
                        "name": "Hyperparameters",
                        "content": "\nWe list all the detailed hyperparameter setting for baselines and our method in Appendix. \n\nFor reproducibility, we report the following best hyperparameters for our method: \n\\begin{enumerate}\n    \\item In MSL, we train for $300$ epochs, a learning rate of $1.0 \\times e^{-2}$, a weight decay of $1.0 \\times e^{-4}$, and the hidden size of $\\theta_f, \\theta_g$, and $\\theta_c$ is $256,512,256$, respectively. Among $256$ windows, we detect the window in which abnormal data points exist. The length of each window was set to $30$, and the length of the predicted window in precursor anomaly detection was set to $10$.\n    \\item In SWaT, we train for $300$ epochs, a learning rate of $1.0 \\times e^{-2}$, a weight decay of $1.0 \\times e^{-4}$, and the hidden size of $\\theta_f, \\theta_g$, and $\\theta_c$ is $128,64,64$, respectively. Among $256$ windows, we detect the window in which abnormal data points exist. The length of each window was set to $60$, and the length of the predicted window in precursor anomaly detection was set to $20$.\n    \\item In WADI, we train for $300$ epochs, a learning rate of $1.0\\times e^{-2}$, a weight decay of $1.0\\times e^{-5}$, and the hidden size of $\\theta_f, \\theta_g$, and $\\theta_c$ is $128,128,256$, respectively. Among $256$ windows, we detect the window in which abnormal data points exist. The length of each window was set to $100$, and the length of the predicted window in precursor anomaly detection was set to $30$.\n\\end{enumerate}\n"
                    },
                    "subsubsection 4.2.2": {
                        "name": "Baselines",
                        "content": "\nWe list all the detailed description about baselines in Appendix.\nWe compare our model with the following 16 baselines of 4 categories, including not only traditional methods but also state-of-the-art deep learning-based models as follows:\n\\begin{enumerate}\n    \\item The classical method category includes OCSVM~\\citep{tax2004support} and Isolation Forest~\\citep{liu2008isolation}.\n    \\item The clustering-based methods category includes Deep-SVDD \n    \\citep{ruff2019deep}, ITAD~\\citep{shin2020itad}, and THOC~\\citep{shen2020timeseries}.\n    \\item The density-estimation-based methods category has LOF~\\citep{breunig2000lof}, DAGMM~\\citep{zong2018deep}, and MMPCACD~\\citep{yairi2017data}.\n    \\item The reconstruction-based methods includes VAR~\\citep{Anderson1976TimeSeries2E}, LSTM \\citep{hundman2018detecting}, CL-MPPCA~\\citep{tariq2019detecting}, LSTM-VAE~\\citep{park2018multimodal}, BeatGAN \\citep{zhou2019beatgan}, OmniAnomaly~\\citep{su2019robust}, USAD~\\citep{audibert2020usad}, InterFusion~\\citep{li2021multivariate}, and Anomaly Transformer~\\citep{xu2021anomaly}.\n\\end{enumerate}\n\n% \\subsection{Baselines}\n% We list all the hyperparameter settings for baselines and our method in Appendix. We compare our model with the following 16 baselines of 5 categories, including not only traditional methods but also state-of-the-art deep learning-based models as follows:\n% \\begin{enumerate}\n% \\item The classic method category includes the following algorithms:\n% \\begin{enumerate}\n% \\item OCSVM ~\\citep{tax2004support} aims to find optimized support vectors which can accurately explain given data. \n% \\item Isolation Forest ~\\citep{liu2008isolation} is basically from a decision tree. It detects anomalies based on density. \n% \\end{enumerate}\n% \\item The clustering-based method category has the following methods:\n% \\begin{enumerate}\n% \\item Deep support vector data description (Deep-SVDD)~\\citep{ruff2019deep} is a model that applies deep learning to SVDD for the anomaly detection. This method detects anomalies that are far from the compressed representation of normal data.\n% \\item Integrative tensor-based anomaly detection (ITAD)~\\citep{shin2020itad} is a tensor-based model. This model uses not only tensor decomposition, but also k-means clustering to distinguish normal and abnormal. \n%  \\item Temporal hierarchical one-class(THOC)~\\citep{shen2020timeseries} \n% utilizes a dilated RNN with skip connections to capture dynamics of time series in multiple scales. multi-resolution temporal clusters are helpful for the anomaly detection.\n% \\end{enumerate}\n% \\item The density-estimation-based methods are as follows:\n% \\begin{enumerate}\n% \\item LOF ~\\citep{breunig2000lof} considers the relative density of the data and considers data with low density as anomaly.\n% \\item Deep auto-encoding gaussian mixture model (DAGMM)  \\citep{zong2018deep} consists of a compression network and an estimation network. Each network measures information necessary for the anomaly detection and the likelihood of the information.\n% \\item MPPCACD~\\citep{yairi2017data} is a kind of GMM and employs probabilistic dimensionality reduction and clustering to detect anomalies. \n% \\end{enumerate}\n% \\item The autogregressive methods are as follows:\n% \\begin{enumerate}\n% \\item VAR ~\\citep{Anderson1976TimeSeries2E} adapted ARIMA to anomaly detection. \n%  Detect anomalies as prediction errors for future observations.\n% \\item LSTM ~\\citep{hundman2018detecting} is a kind of RNN and is widely used for time series forecasting, because it is an algorithm for learning long-time dependencies.\n% \\item CL-MPPCA~\\citep{tariq2019detecting} exploits convolutional LSTM to forecast future observations and mixtures of probabilistic principal component analyzers (MPPCA) to complement the convolutional LSTM.\n% \\end{enumerate}\n% \\item The reconstruction-based method category has the following methods:\n% \\begin{enumerate}\n%     \\item LSTM-VAE~\\citep{park2018multimodal} is a model composed of an LSTM-based variational autoencoder(VAE). The decoder reconstructs the expected distribution of input. An anomaly score is measured with the estimated distribution.\n%     % the latent space representation input from the encoder. An abnormal score is defined according to the NLL.\n%     \\item BeatGAN~\\citep{zhou2019beatgan} trains an autoencoder with a discriminator and an adversarial loss like GANs~\\citep{ganian}. Reconstruction errors are used as anomaly scores.\n%     \\item OmniAnomaly~\\citep{su2019robust} model the temporal dependency between stochastic variables by combining GRU, VAE, and planar normalizing flows. Detect anomalies based on the reconstruction probability. %It is composed of an inference network and a generative network of VAE.\n%     \\item Unsupervised anomaly detection (USAD)~\\citep{audibert2020usad} is an auto-encoder architecture based on adversarial training. This method detects anomalies based on reconstruction errors.\n%     \\item InterFusion~\\citep{li2021multivariate} uses hierarchical VAE with two stochastic latent variables for inter-metric or temporal embeddings. Furthermore, MCMC-based method helps to obtain more reasonable reconstructions.\n% \\end{enumerate}\n% \\end{enumerate}\n%  Anomaly Detection - regular\n\n\n\n"
                    }
                },
                "subsection 4.3": {
                    "name": "Experimental Results on Anomaly Detection",
                    "content": "\nWe introduce our experimental results for the anomaly detection with the following 3 datasets: MSL, SWaT, and WADI. Evaluating the performance with these datasets proves the competence of our model in various fields. We use the Precision, Recall, and F1-score.\n\n%  Anomaly Detection - irregular\n\n\n\n\n% \\begin{table*}[t] \n% \\setlength{\\tabcolsep}{9pt}\n% \\caption{Experimental results for the precursor-of-anomaly detection on 3 regular time-series datasets.}\\label{tbl:result_p}\n% % \\renewcommand{\\arraystretch}{1.2}%#{1.4}\n% \\begin{tabular}{llll}\n% \\hline\n% Dataset                         & \\multicolumn{3}{l}{SWaT}       \\\\ \\hline\n\n% Methods                          & P      & R     & F1     \\\\ \\hline\n% GDN                            & 99.35  & 68.12 & 81.00                    \\\\\n%   \\hline\n% \\textbf{PAD} (PoA)          & 91.47  & 91.44 & \\textbf{91.46} \\\\ \n% \\hline\n% \\end{tabular} \n% \\end{table*}\n\n\n\n\n% \\begin{figure*}[!ht]\n%     \\centering\n%      \\subfigure[SMD]{\\includegraphics[width=0.56\\columnwidth]{images/SMD_2500_202_legend_ver1.pdf}} \\hfill\n%     \\subfigure[MSL]{\\includegraphics[width=0.56\\columnwidth]{images/MSL_1500_202_nolegend_ver1.pdf}} \\hfill\n%     \\subfigure[SMAP]{\\includegraphics[width=0.56\\columnwidth]{images/SMAP_1000_202_nolegend_ver1.pdf}} \\\\\n%      \\subfigure[SMD]{\\includegraphics[width=0.56\\columnwidth]{images/SMD_1000_203_legend_ver2.pdf}} \\hfill\n%     \\subfigure[MSL]{\\includegraphics[width=0.56\\columnwidth]{images/MSL_1500_203_nolegend_ver2.pdf}} \\hfill\n%     \\subfigure[SMAP]{\\includegraphics[width=0.56\\columnwidth]{images/SMAP_6000_203_nolegend_ver2.pdf}} \n%     \\caption{anomaly detection and precursor-of-anomaly detection results on 3 dataset.}\n%     \\label{fig:experimental_result_vis}\n% \\end{figure*}\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n",
                    "subsubsection 4.3.1": {
                        "name": "Experimental Results on Regular Time Series",
                        "content": "\nTable~\\ref{tbl:result} summarizes the results on the three datasets. The anomaly detection with MSL is one of the most widely used benchmark experiments. Our method, PAD, shows the best F1-score. For this dataset, all classical methods are inferior to other baselines. For SWaT, our experimental results are in Table~\\ref{tbl:result}. As summarized, the classical methods are inferior to other baselines. However, unlike in WADI, all baselines except them show similar results. Our method, PAD, shows the best F1-score.\nFor WADI, among the reconstruction-based methods, InterFusion shows the second-best performance. Since this dataset has the smallest anomaly ratio among the three datasets, classical methods and clustering-based methods are not suitable.\n\n"
                    },
                    "subsubsection 4.3.2": {
                        "name": "Experimental Results on Irregular Time Series",
                        "content": "\nTable~\\ref{tbl:result_irr} summarizes the results on irregular time series. In order to create challenging irregular environments, we randomly remove 30\\%, 50\\% and 70\\% of the observations in each sequence. Therefore, this is basically an irregular time series anomaly detection. We compare our method, PAD, with the 4 baselines, Isolation Forest, LOF, USAD, and Anomaly Transformer --- other baselines are not defined for irregular time series. In addition, it is expected that the presence of more than 30\\% of missing values in time series causes poor performance for many baselines because it is difficult to understand the highly missing input sequence. In MSL, USAD and Anomaly Transformer shows the reasonable results and also maintains an F1-score around 80\\% across all the dropping ratio settings. For WADI, all baselines show poor performance when the missing rate is 70\\%. Surprisingly, our method, PAD, performs not significantly differently from the regular anomaly detection experiments. Our method maintains good performance in the irregular time series setting as well because PAD uses a hidden representation controlled by the continuous path $X(t)$ at every time $t$. Additionally, our method maintains an F1 score larger than 90\\% for all the dropping ratios.\n\n\n"
                    }
                },
                "subsection 4.4": {
                    "name": "Experimental Results on the precursor-of-Anomaly Detection",
                    "content": "\n\nIn Table.~\\ref{tbl:result_p}, we introduce our experimental results for the precursor-of-anomaly detection. In order to compare the performance of our method in the precursor-of-anomaly detection task newly proposed in this paper, among the baselines performed in regular time series anomaly detection (cf. Table~\\ref{tbl:result}), we selected reconstruction-based methods that allow PoA experimental setting. Therefore, we select the 3 baselines (LSTM, LSTM-VAE, and USAD) that showed good performance in reconstruction-based methods. \n\n",
                    "subsubsection 4.4.1": {
                        "name": "Experimental Results on Regular Time Series",
                        "content": "\nAs shown in Table~\\ref{tbl:result_p}, USAD shows reasonable performance among the 3 baselines. Especially, in MSL dataset, USAD shows a similar performance to Table~\\ref{tbl:result}. Our newly proposed the precursor-of-anomaly task requires predicting patterns or features of future data from input data. Therefore, the reconstruction-based method seems to have shown good performance. However, our method, PAD, shows the best performance in all the 3 datasets. Fig.~\\ref{fig:experimental_result_vis} shows the visualization of experimental results on the anomaly detection and the precursor-of-anomaly detection on all the 3 datasets. In Fig.~\\ref{fig:experimental_result_vis}, the part highlighted in purple is the ground truth of the anomalies, the part highlighted in red is the result of PoA detected by PAD. As shown in Fig.~\\ref{fig:experimental_result_vis}, our method correctly predicts the precursor-of-anomalies (highlighted in red) before the abnormal parts (highlighted in purple) occur.\n\n"
                    },
                    "subsubsection 4.4.2": {
                        "name": "Experimental Results on Irregular Time Series",
                        "content": "\nTable~\\ref{tbl:result_irrp} shows the experimental result on the irregular datasets. Among the baselines, USAD has many differences in experimental results depending on the experimental environment. For example, in the WADI dataset, which has a small anomaly ratio(5.99\\%) among the other datasets, it shows poor performance, and in the MSL data set, USAD shows the second-best performance, but the performance deteriorates as the dropping ratio increases. However, our method, PAD, clearly shows the best F1-score for all dropping ratios and all 3 datasets. One outstanding point in our model is that the F1-score is not greatly influenced by the dropping ratio.\nConsequently, all these results prove that our model shows state-of-the-art performance in both the anomaly and the precursor-of-anomaly detection.\n\n\n"
                    }
                }
            },
            "section 5": {
                "name": "Ablation and Sensitivity Studies",
                "content": "\n",
                "subsection 5.1": {
                    "name": "Ablation Study on Multi-task Learning",
                    "content": "\\label{abl:mtl}\nTo prove the efficacy of our multi-task learning on the anomaly and the precursor-of-anomaly detection, we conduct ablation studies. There are 2 tasks in our multi-task learning: the anomaly detection, and the precursor-of-anomaly detection tasks. We remove one task to build an ablation model. For the ablation study on anomaly detection, there are 2 ablation models in terms of the multi-task learning setting: i) without the precursor-of-anomaly detection, and ii) with anomaly detection only. For the ablation study on the precursor-of-anomaly detection, 2 ablation models are defined in the exactly same way. Table~\\ref{tbl:abl} and Table~\\ref{tbl:abl_p} show the results of the ablation studies in the regular time series setting for `PAD (anomaly)' and `PAD (PoA),' respectively. When we remove task(anomaly detection or PoA detection) from the multi-task learning, there is notable degradation in performance. Therefore, our multi-task learning design is required for good performance in both the anomaly and the precursor-of-anomaly detection.\n\n"
                },
                "subsection 5.2": {
                    "name": "Sensitivity to Output Sequence Length",
                    "content": "\nWe also compare our method with USAD, OmniAnomaly, and THOC by varying the length of output of the precursor-of-anomaly detection, during the multi-task learning process. After fixing the input length of MSL, SWaT, and WADI to $30$, we vary the output length in $\\{1,5,10,15,20\\}$. As shown in Fig.~\\ref{fig:experimental_output}, our proposed method consistently outperforms others. As the output length increases, it becomes more difficult to predict in general, but PAD shows excellent performance regardless of the output length. In the MSL and WADI datasets, most baselines show similar performances regardless of the output length. However, in SWaT, there is a performance difference according to the output length, and this phenomenon appears similarly for the baselines.\n\n"
                }
            },
            "section 6": {
                "name": "Conclusion",
                "content": "\nRecently, many studies have been conducted on time series anomaly detection. However, most of the methods have been conducted only for existing anomaly detection methods. In this paper, we first propose a task called the precursor-of-anomaly (PoA) detection. We define PoA detection as the task of predicting future anomaly detection. This study is necessary in that many risks can be minimized by detecting risks in advance in the real world. In addition, we combine multi-task-learning and NCDE architecture to perform both anomaly detection, and PoA detection and achieve the best performance through task-specific-parameter sharing. Additionally, we propose a novel dual co-evolving NCDE structure. Two NCDEs perform anomaly detection and PoA detection tasks. Our experiments with the 3 real-world datasets and 17 baseline methods successfully prove the efficacy of the proposed concept. In addition, our visualization of anomaly detection results delivers how our proposed method works. In the future work, we plan to conduct unsupervised precursor-of-anomaly detection research since the time series data augmentation method requires a pre-processing step.\n\n"
            },
            "section 7": {
                "name": "Acknowledgements",
                "content": "\n% AI 대학원 \nNoseong Park is the corresponding author. \nThis work was supported by the Yonsei University Research Fund of 2021, and the Institute of Information \\& Communications Technology Planning \\& Evaluation (IITP) grant funded by the Korean government (MSIT) (No. 2020-0-01361, Artificial Intelligence Graduate School Program (Yonsei University), and (No.2022-0-00857, Development of AI/data-based financial/economic digital twin platform,10\\%) and (No.2022-0-00113, Developing a Sustainable Collaborative Multi-modal Lifelong Learning Framework, 45\\%),(2022-0-01032, Development of Collective Collaboration Intelligence Framework for Internet of Autonomous Things, 45\\%).\n%%\n%% The next two lines define the bibliography style to be used, and\n%% the bibliography file.\n% \\clearpage\n\\bibliographystyle{ACM-Reference-Format}\n\\bibliography{sample-base}\n\n%%\n%% If your work has an appendix, this is the place to put it.\n\\clearpage\n\\appendix\n"
            },
            "section 8": {
                "name": "Baselines",
                "content": "\nWe list all the hyperparameter settings for baselines and our method in Appendix. We compare our model with the following 16 baselines of 5 categories, including not only traditional methods but also state-of-the-art deep learning-based models as follows:\n\\begin{enumerate}\n\\item The classical method category includes the following algorithms:\n\\begin{enumerate}\n\\item OCSVM ~\\citep{tax2004support} aims to find optimized support vectors that can accurately explain given data. \n\\item Isolation Forest ~\\citep{liu2008isolation} is basically from a decision tree. It detects anomalies based on density. \n\\end{enumerate}\n\\item The clustering-based method category has the following methods:\n\\begin{enumerate}\n\\item Deep support vector data description (Deep-SVDD)~\\citep{ruff2019deep} is a model that applies deep learning to SVDD for the anomaly detection. This method detects anomalies that are far from the compressed representation of normal data.\n\\item Integrative tensor-based anomaly detection (ITAD)~\\citep{shin2020itad} is a tensor-based model. This model uses not only tensor decomposition but also k-means clustering to distinguish normal and abnormal. \n \\item Temporal hierarchical one-class (THOC)~\\citep{shen2020timeseries} \nutilizes a dilated RNN with skip connections to capture dynamics of time series in multiple scales. Multi-resolution temporal clusters are helpful for the anomaly detection.\n\\end{enumerate}\n\\item The density-estimation-based methods are as follows:\n\\begin{enumerate}\n\\item LOF ~\\citep{breunig2000lof} considers the relative density of the data and considers data with low density as abnormal data points.\n\\item Deep auto-encoding gaussian mixture model (DAGMM)  \\citep{zong2018deep} consists of a compression network and an estimation network. Each network measures information necessary for the anomaly detection and the likelihood of the information.\n\n\\item MPPCACD~\\citep{yairi2017data} is a kind of GMM and employs probabilistic dimensionality reduction and clustering to detect anomalies. \n\\end{enumerate}\n\\item The reconstruction-based method category has the following methods:\n\\begin{enumerate}\n    \\item VAR ~\\citep{Anderson1976TimeSeries2E} adapted ARIMA to anomaly detection. \n     Detect anomalies as prediction errors for future observations.\n    \\item LSTM ~\\citep{hundman2018detecting} is a kind of RNN and is widely used for time series forecasting, because it is an algorithm for learning long-time dependencies.\n    \\item CL-MPPCA~\\citep{tariq2019detecting} exploits convolutional LSTM to forecast future observations and mixtures of probabilistic principal component analyzers (MPPCA) to complement the convolutional LSTM.\n    \\item LSTM-VAE~\\citep{park2018multimodal} is a model composed of an LSTM-based variational autoencoder(VAE). The decoder reconstructs the expected distribution of input. An anomaly score is measured with the estimated distribution.\n    % the latent space representation input from the encoder. An abnormal score is defined according to the NLL.\n    \\item BeatGAN~\\citep{zhou2019beatgan} trains an autoencoder with a discriminator and an adversarial loss like GANs~\\citep{ganian}. Reconstruction errors are used as anomaly scores.\n    \\item OmniAnomaly~\\citep{su2019robust} model the temporal dependency between stochastic variables by combining GRU, VAE, and planar normalizing flows. Detect anomalies based on the reconstruction probability. %It is composed of an inference network and a generative network of VAE.\n    \\item Unsupervised anomaly detection (USAD)~\\citep{audibert2020usad} is an auto-encoder architecture based on adversarial training. This method detects anomalies based on reconstruction errors.\n    \\item InterFusion~\\citep{li2021multivariate} uses hierarchical VAE with two stochastic latent variables for inter-metric or temporal embeddings. Furthermore, MCMC-based method helps to obtain more reasonable reconstructions.\n    \\item Anomaly Transformer~\\citep{xu2021anomaly} incorporates the innovative \"Anomaly-Attention\" mechanism to enhance the distinguishability, which computes the association discrepancy, and employs a minimax strategy.\n    \n\\end{enumerate}\n\\end{enumerate}\n\n"
            },
            "section 9": {
                "name": "Hyperparameters for Our Model",
                "content": "\nWe test the following common hyperparameters for our method:\n\\begin{enumerate}\n    \\item In MSL, we train for 100 epochs, a learning rate of $\\{1.0\\times e^{-2},1.0\\times e^{-3},1.0\\times e^{-4}\\}$, a weight decay of $\\{1.0 \\times e^{-3},1.0 \\times e^{-4},1.0 \\times e^{-5}\\}$, and a size of hidden vector size is $\\{19,29,39,49\\}$. \n    \\item In SWaT, we train for 100 epochs, a learning rate of $\\{1.0\\times e^{-2}, 1.0\\times e^{-3},1.0\\times e^{-4}\\}$, a weight decay of $\\{1.0\\times e^{-3},1 \\times e^{-4},1\\times e^{-5}\\}$, and a size of hidden vector size is $\\{39,49,59\\}$. \n    \\item In WADI, we train for 100 epochs, a learning rate of $\\{1.0\\times e^{-2},1.0\\times e^{-3},1.0\\times e^{-4}\\}$, a weight decay of $\\{1.0 \\times e^{-3},1.0 \\times e^{-4},1.0 \\times e^{-5}\\}$, and a size of hidden vector size is $\\{29,39,49,59\\}$.\n\\end{enumerate}\nIn Table~\\ref{tbl:msl_archi1} to ~\\ref{tbl:wadi_archi3}, we clarify the network architecture of the CDE functions, $f$,$g$, and $c$. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
            },
            "section 10": {
                "name": "Hyperparameters for baselines",
                "content": "\nFor the best outcome of baselines, we conduct hyperparmeter search for them based on the recommended hyperparameter set from each papers. \n\\begin{enumerate}\n    \\item Classical methods: For OCSVM, we use the RBF kernel. For Isolation Forest, we use the base estimator of $100$ in the ensemble, and choose the number of trees in $\\{25,100\\}$.\n    \\item Clustering-based methods: For Deep SVDD and ITAD, we use a learning rate of $\\{1.0 \\times e^{-3},1.0 \\times e^{-4}\\}$ and a hidden vector dimension of $\\{32,64,128\\}$ and For THOC, we use a number of hidden units in $\\{32,64,84\\}$, and we use its default hyperparameters. \n    \n    \\item Density-estimation methods: For LOF, we use the number of neighbors in $\\{1,3,5,7,12\\}$. For DAGMM and MMPCACD, we follow those default hyperparameters.\n    \n    \\item Reconstruction-based methods: For LSTM, we use a learning rate of $\\{1.0 \\times e^{-3},1.0 \\times e^{-4}\\}$ and a hidden vector dimension of $\\{80,100,120\\}$. For LSTM-VAE, BeatGAN, and OmniAnomaly, we use a learning rate of $\\{1.0 \\times e^{-4},1.0 \\times e^{-5}\\}$ and a hidden vector dimension of $\\{32,64,128\\}$. For USAD, we use a learning rate of $\\{1.0 \\times e^{-3},1.0 \\times e^{-4}\\}$ and a hidden vector dimension of $\\{32,64,128\\}$, and follow other default hyperparameters in USAD. For InterFusion, a hidden vector dimension of $\\{128,256,512\\}$, and follow other default hyperparameters in InterFusion. For Anomaly Transformer, we follow all hyperparameters in Anomaly Transformer.\n    \n\\end{enumerate}\n\n"
            },
            "section 11": {
                "name": "Data preprocessing details",
                "content": "\nWe use the following datasets to compare PAD with other methods: \n\\begin{enumerate}\n    \\item Mars Science Laboratory: MSL is a public dataset from NASA. MSL is licensed under the following license:  \\url{https://github.com/khundman/telemanom/blob/master/LICENSE.txt}\n    \\item Secure Water Treatment: SWaT is licensed under the following license: \\url{https://itrust.sutd.edu.sg/testbeds/secure-water-treatment-swat/}\n    \\item Water Distribution: WADI is a public dataset from NASA. WADI is licensed under the following license:  \\url{https://itrust.sutd.edu.sg/testbeds/water-distribution-wadi/}\n\\end{enumerate}\n\nSince our method resorts to a self-supervised multi-task learning approach, we augmented training samples with abnormal patterns and its detailed process is in Alg.~\\ref{alg:dataaug}. The augmentation method is similar to other popular augmentation methods for images, e.g., CutMix~\\cite{yun2019cutmix}. There is a long training sequence $\\mathbf{x}_{0:T}=\\{\\mathbf{x}_0,\\mathbf{x}_1,...,\\mathbf{x}_T\\}$. We apply the augmentation method to the raw sequence $\\mathbf{x}_{0:T}$ before segmenting it into windows. We randomly copy existing $l$ observations from a random location $r$ to a target location $s$. In general, the ground-truth anomaly pattern is unknown in each dataset. Although our copy-and-paste augmentation method is simple, our experimental results prove its effectiveness. At the same time, we also believe that there will be better augmentation methods.\n\n\\begin{algorithm}[t]\n\\SetAlgoLined\n\\caption{How to apply our augmentation method to training samples}\\label{alg:dataaug}\n\\KwIn{Training sequence $\\mathbf{x}_{0:T}=\\{\\mathbf{x}_0,\\mathbf{x}_1,...,\\mathbf{x}_T\\}$, Anomaly ratio $\\gamma$}\n% \\KwOut{$\\mathbf{\\theta}$, $(d,t) \\in H$, and $\\alpha_{i,j}$ for all $i,j$}\n\n% Get max length($\\mathbf{T}$) of training data $D_{train}$ ;\\\\\n% Randomly select starting points, $S =\\{s_i\\}_{i=0}^M$;\\\\\n% Randomly select resampling points, $R =\\{r_i\\}_{i=0}^M$;\\\\\n% Randomly select lengths between $100$ and $500$, $L = \\{l_i\\}_{i=0}^M$;\\\\\n% $i \\gets 0 $;\\\\\n\\tcc{Init. the length after the augmentation}\n$L \\gets T$\\;\n\\While {$\\frac{L-T}{T} \\leq \\gamma$}{\n    Randomly select a starting point $s$;\\\\\n    Randomly select a resampling point $r$;\\\\\n    Randomly select a length $l$ between $100$ and $500$\\\\\n    \\tcc{Implant abnormal observations}\n    Concatenate $\\mathbf{x}_{0:s}$, $\\mathbf{x}_{r:r+l}$, and $\\mathbf{x}_{s_i+1:N}$;\\\\\n    \\tcc{Increase the length}\n    $L \\gets L + l$\n    }\n% \\Return $D_{train}^*$;\n\\end{algorithm}\n\n"
            }
        },
        "tables": {
            "tbl:result": "\\begin{table*}[t]\n\\caption{Experimental results for the anomaly detection on 3 regular time-series datasets. P, R, and F1 denote Precision, recall and F1 score as \\%, respectively. The best scores are in bold face.}\\label{tbl:result}\n\\renewcommand{\\arraystretch}{1.05}%#{1.4}\n\\begin{tabular}{cclllllllll}\n\\hline\n\\multicolumn{2}{c}{Datasets}                                 & \\multicolumn{3}{c}{MSL} & \\multicolumn{3}{c}{SWaT} & \\multicolumn{3}{c}{WADI} \\\\ \\hline\n\\multicolumn{2}{c}{Methods}                                   & P      & R      & F1    & P      & R      & F1    & P      & R      & F1     \\\\ \\hline\n\\multicolumn{1}{c|}{\\multirow{2}{*}{Classical Methods}} &\n  \\multicolumn{1}{c|}{OCSVM} \n  & 59.78  & 86.87 & 70.82  & 45.39  & 49.22 & 47.23   & 83.93  & 46.42 & 58.64 \\\\ \n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{Isolation Forest} \n & 53.94  & 86.54 & 66.45  & 95.12  & 58.84 & 72.71   & 95.12  & 58.84 & 72.71  \\\\ \\hline\n\\multicolumn{1}{c|}{\\multirow{3}{*}{\\begin{tabular}[c]{@{}c@{}}Clustering-based\\\\ Methods\\end{tabular}}} &\n  \\multicolumn{1}{c|}{Deep-SVDD} \n  & 91.92  & 76.63 & 83.58  & 80.42  & 84.45 & 82.39   & 83.70  & 47.88 & 60.03 \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{ITAD}          \n& 69.44  & 84.09 & 76.07  & 63.13  & 52.08 & 57.08   & 92.11  & 58.79 & 70.25  \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{THOC}        \n& 88.45  & 90.97 & 89.69  & 98.08  & 79.94 & 88.09   & 86.71  & 92.02 & 89.29  \\\\ \\hline\n\\multicolumn{1}{c|}{\\multirow{3}{*}{\\begin{tabular}[c]{@{}c@{}}Density-estimation-based\\\\ Methods\\end{tabular}}} &\n\\multicolumn{1}{c|}{LOF} \n  & 81.17  & 81.44 & 81.23  & 72.15  & 65.43 & 68.62  & 87.61  & 17.92 & 25.23 \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{DAGMM}          \n &89.60  & 63.93 & 74.62  & 89.92  & 57.84 & 70.40   & 46.95  & 66.59 & 55.07  \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{MMPCACD}        \n& 81.42  & 61.31 & 69.95  & 82.52  & 68.29 & 74.73   & 88.61  & 75.84 & 81.73  \\\\ \\hline\n\\multicolumn{1}{c|}{\\multirow{8}{*}{\\begin{tabular}[c]{@{}c@{}}Reconstruction-based\\\\ Methods\\end{tabular}}} &\n  \\multicolumn{1}{c|}{VAR} \n& 74.68  & 81.42 & 77.90  & 81.59  & 60.29 & 69.34   & 83.97 & 49.35 & 61.31\\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{LSTM}            \n& 85.45  & 82.50 & 83.95  & 86.15  & 83.27 & 84.69   & 81.43  & 84.82 & 83.06  \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{CL-MPPCA}        \n& 73.71  & 88.54 & 80.44  & 76.78  & 81.50 & 79.07   & 70.96  & 75.21 & 72.86  \\\\ \n \\multicolumn{1}{c|}{} &\\multicolumn{1}{c|}{LSTM-VAE} \n& 85.49  & 79.94 & 82.62  & 76.00  & 89.50 & 82.20   & 98.97  & 63.77 & 77.56 \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{BeatGAN}            \n& 89.75  & 85.42 & 87.53  & 64.01  & 87.46 & 73.92   & 70.48  & 72.26 & 71.34  \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{OmniAnomay}        \n& 89.02  & 86.37 & 87.67  & 81.42  & 84.30 & 82.83   & 98.25  & 64.97 & 78.22  \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{USAD}   \n& 89.36  & 92.92 & 91.05  & 98.51  & 66.18 & 79.17   & 99.47  & 13.18 & 23.28  \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{InterFusion}            \n& 81.28  & 92.70 & 86.62  & 80.59  & 85.58 & 83.01   & 90.30  & 92.67 & 91.02  \\\\\n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{Anomaly Transformer}  \n& 91.82  & 91.23 & 91.53  & 87.32  & 85.50 & 86.40   & 60.86  & 77.86 & 68.32  \\\\\\hline\n\\multicolumn{1}{c|}{\\multirow{1}{*}{Ours}} &\n  \\multicolumn{1}{c|}{\\textbf{PAD} (Anomaly)}\n  & 94.13  & 94.71 &\\textbf{92.56}  & 94.02  & 93.53 & \\textbf{93.04}   & 90.84  & 95.31 & \\textbf{93.02}\\\\  \\hline\n\\end{tabular}\n\\end{table*}",
            "tbl:result_irr": "\\begin{table*}[t]\n\\caption{Experimental results for the anomaly detection on 3 irregular time-series datasets.}\\label{tbl:result_irr}\n\\setlength{\\tabcolsep}{7pt}\n% \\renewcommand{\\arraystretch}{1.2}%#{1.4}\n\\begin{tabular}{cclllllllll}\n\\hline\n\\multicolumn{2}{c}{Dropping ratio}                                 & \\multicolumn{3}{c}{30\\% dropped} & \\multicolumn{3}{c}{50\\% dropped} & \\multicolumn{3}{c}{70\\% dropped} \\\\ \\hline\nDatasets &    Methods            & P      & R      & F1    & P      & R      & F1    & P      & R      & F1     \\\\ \\hline\n\\multicolumn{1}{c|}{\\multirow{5}{*}{MSL}} &\n\\multicolumn{1}{c|}{Isolation Forest} \n   & 89.81  & 41.59 & 52.53  &  86.97  & 39.38 & 50.74   & 88.03  & 29.27 & 38.33 \\\\ \n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{LOF} \n & 78.26  & 78.71 & 78.39  & 74.86  & 75.39 & 74.95   & 73.53  & 72.59 & 72.99 \\\\ \n \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{USAD} \n & 88.07  & 84.04 & 85.92   & 87.49  & 68.73 & 76.26   & 87.49  & 74.92 & 80.33 \\\\ \n  \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{Anomaly Transformer} \n  & 90.49  & 85.42 & 87.89  & 91.26  & 86.40 & 88.76 & 91.75  & 90.47 & 91.10 \\\\  \n  \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{\\textbf{PAD} (Anomaly)} \n & 89.09  & 94.39 & \\textbf{91.66}  & 94.92  & 94.63 & \\textbf{92.24} & 91.09  & 94.22 & \\textbf{91.87} \\\\\\hline\n\\multicolumn{1}{c|}{\\multirow{5}{*}{\\begin{tabular}[c]{@{}c@{}}SWaT\\end{tabular}}} &\n\\multicolumn{1}{c|}{Isolation Forest} \n  & 69.55  & 49.79 & 55.06   & 69.94  & 35.00 & 37.16    & 67.89  & 24.37 & 18.83 \\\\ \n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{LOF} \n & 70.85  & 21.87 & 12.77   & 71.20  & 25.30 & 20.32    & 69.34  & 23.24 & 16.39 \\\\ \n \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{USAD} \n & 87.36  & 52.64 & 64.87   & 84.58  & 38.44 & 50.42    & 87.96  & 47.19 & 59.91  \\\\ \n \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{Anomaly Transformer} \n  & 94.48  & 77.61 & 85.22    & 93.33  & 84.14 & 88.50     & 93.23  & 82.81 & 87.71  \\\\  \n  \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{\\textbf{PAD} (Anomaly)}\n & 93.65  & 93.27 & \\textbf{92.76}   & 93.89  & 93.53 & \\textbf{93.07}    & 92.36  & 92.47 & \\textbf{92.08}  \\\\\\hline\n\\multicolumn{1}{c|}{\\multirow{5}{*}{\\begin{tabular}[c]{@{}c@{}}WADI\\end{tabular}}} &\n\\multicolumn{1}{c|}{Isolation Forest} \n  & 92.19  & 48.48 & 62.33   & 91.77  & 26.35 & 38.03    & 92.89  & 12.15 & 16.23  \\\\ \n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{LOF} \n& 86.42  & 16.35 & 21.42   & 85.78  & 12.70 & 15.88    & 91.12  & 10.26 & 13.33  \\\\ \n \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{USAD} \n & 84.98 & 15.70 & 20.60   & 83.78  & 15.95 & 21.30    & 75.89  & 13.19 & 20.09  \\\\ \n \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{Anomaly Transformer} \n & 65.73  & 100.0 & 79.32   & 62.93  & 84.67 & 72.20    & 61.17  & 77.86 & 68.52  \\\\ \n  \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{\\textbf{PAD} (Anomaly)}\n & 95.69  & 95.49 & \\textbf{93.44}   & 91.21  & 93.06 & \\textbf{92.10}   & 90.85  & 89.41 & \\textbf{90.12}  \\\\\\hline\n\\end{tabular}\n\\end{table*}",
            "tbl:result_p": "\\begin{table}[t] \n\\setlength{\\tabcolsep}{1.3pt}\n\\caption{Experimental results for the precursor-of-anomaly detection on 3 regular time-series datasets.}\\label{tbl:result_p}\n% \\renewcommand{\\arraystretch}{1.2}%#{1.4}\n\\begin{tabular}{llllllllll}\n\\hline\nDataset                         & \\multicolumn{3}{l}{MSL} & \\multicolumn{3}{l}{SWaT} & \\multicolumn{3}{l}{WADI}        \\\\ \\hline\n\nMethods                          & P      & R     & F1     & P      & R     & F1      & P      & R     & F1 \\\\ \\hline\nLSTM                            & 90.42  & 59.53 & 70.49  & 64.96  & 80.64 & 71.94   & 92.87  & 55.38 & 68.02                         \\\\ \nLSTM-VAE                        & 69.54  & 83.05 & 75.65   & 75.64  & 55.10  & 61.11   & 84.32  & 91.83 & 87.91   \\\\ \n\nUSAD                            & 90.78  & 95.27 & 92.97  & 84.08  & 75.07 & 77.42   & 94.63  & 44.10 & 57.40                      \\\\ \\hline\n\\textbf{PAD} (PoA)          & 91.41  & 95.61 & \\textbf{93.46}  & 93.31  & 93.47 & \\textbf{93.32}   & 92.71  & 92.71 & \\textbf{92.71}\\\\ \n\\hline\n\\end{tabular} \n\\end{table}",
            "tbl:result_irrp": "\\begin{table*}[t]\n\\caption{Experimental results for the precursor-of-anomaly detection on the 3 irregular time-series datasets.}\\label{tbl:result_irrp}\n\\setlength{\\tabcolsep}{7pt}\n% \\renewcommand{\\arraystretch}{1.2}%#{1.4}\n\\begin{tabular}{cclllllllll}\n\\hline\n\\multicolumn{2}{c}{Dropping ratio}                                 & \\multicolumn{3}{c}{30\\% dropped} & \\multicolumn{3}{c}{50\\% dropped} & \\multicolumn{3}{c}{70\\% dropped} \\\\ \\hline\nDatasets &    Methods            & P      & R      & F1    & P      & R      & F1    & P      & R      & F1     \\\\ \\hline\n\\multicolumn{1}{c|}{\\multirow{5}{*}{MSL}} &\n\\multicolumn{1}{c|}{LSTM} \n  & 66.88  & 81.16 & 73.29  & 90.06  & 50.90 & 63.28   & 90.09  & 48.85 & 61.41  \\\\ \n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{LSTM-VAE} \n & 66.96  & 81.75 & 73.58  & 90.22  & 51.29 & 63.60   & 90.12  & 48.78 & 61.34 \\\\ \n \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{USAD} \n & 92.09  & 88.27 & 90.03  & 91.54  & 78.33 & 84.04  & 91.17  & 69.54 & 78.27 \\\\\n   \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{\\textbf{PAD} (PoA)}\n & 91.38  & 95.04 & \\textbf{93.17}   & 91.40  & 95.52 & \\textbf{93.42}    & 93.50  & 95.52 & \\textbf{93.84}\\\\\\hline\n\\multicolumn{1}{c|}{\\multirow{5}{*}{\\begin{tabular}[c]{@{}c@{}}SWaT\\end{tabular}}} &\n\\multicolumn{1}{c|}{LSTM} \n  & 83.57  & 68.87 & 72.11   & 80.15  & 54.13 & 58.21    & 74.56  & 30.27 & 27.99 \\\\ \n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{LSTM-VAE} \n & 81.98  & 56.27 & 60.22   & 71.34  & 35.80 & 37.61    & 74.94  & 30.80 & 28.80 \\\\ \n \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{USAD} \n & 84.12  & 75.20 & 77.54   & 83.58  & 71.80 & 74.65    & 83.15  & 66.60 & 70.09 \\\\ \n   \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{\\textbf{PAD} (PoA)}\n & 85.50  & 77.40 & \\textbf{79.47}   & 84.15  & 77.67 & \\textbf{79.53}   & 90.85  & 91.07 & \\textbf{90.93}  \\\\\\hline\n\\multicolumn{1}{c|}{\\multirow{5}{*}{\\begin{tabular}[c]{@{}c@{}}WADI\\end{tabular}}} &\n\\multicolumn{1}{c|}{LSTM} \n  & 91.15  & 46.01 & 59.95   & 91.28  & 25.52 & 36.68    & 92.97  & 18.58 & 26.29 \\\\ \n\\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{LSTM-VAE} \n & 89.46  & 45.66 & 59.17   & 91.55  & 26.91 & 38.47    & 93.11  & 19.27 & 27.32 \\\\ \n \\multicolumn{1}{c|}{} & \n \\multicolumn{1}{c|}{USAD} \n & 94.87  & 39.93 & 53.05   & 94.62  &34.38 & 46.95    & 94.87  & 28.30 & 39.49 \\\\ \n   \\multicolumn{1}{c|}{} & \\multicolumn{1}{c|}{\\textbf{PAD} (PoA)} \n& 92.15  & 95.49 & \\textbf{93.79}   & 92.17  & 96.01 & \\textbf{94.05}    & 92.15  & 95.31 & \\textbf{93.70}\\\\\\hline\n\\end{tabular}\n\\end{table*}",
            "tbl:abl": "\\begin{table}[] \n\\caption{Ablation study for PAD in a regular setting.}\\label{tbl:abl}\n\\setlength{\\tabcolsep}{1.3pt}\n\\renewcommand{\\arraystretch}{1.1}%#{1.4}\n\\begin{tabular}{llllllllll}\n\\hline\nDataset                         & \\multicolumn{3}{l}{MSL} & \\multicolumn{3}{l}{SWaT} & \\multicolumn{3}{l}{WADI}        \\\\ \\hline\nMetric                          & P      & R     & F1     & P      & R     & F1      & P      & R     & F1 \\\\ \\hline\nType (i)            & 94.92  & 94.63 & 92.24  & 94.13  & 93.67 & 93.19    & 90.45  & 87.15 & 88.77                   \\\\ \nType (ii)            & 89.74  & 76.65 & 82.30   & 74.94  & 80.07 & 72.11    & 94.57  & 86.98 & 89.97                   \\\\ \\hline\n\\textbf{PAD}                 & 94.13  & 94.71 &\\textbf{92.56}  & 94.02  & 93.53 & \\textbf{93.04}   & 90.84  & 95.31 & \\textbf{93.02}\\\\ \n\\hline\n\\end{tabular} \n\\end{table}",
            "tbl:abl_p": "\\begin{table}[] \n\\caption{Ablation study for the Precursor-of-Anomaly PAD in a regular setting.}\\label{tbl:abl_p}\n\\setlength{\\tabcolsep}{1.3pt}\n\\renewcommand{\\arraystretch}{1.1}%#{1.4}\n\\begin{tabular}{llllllllll}\n\\hline\nDataset                         & \\multicolumn{3}{l}{ MSL} & \\multicolumn{3}{l}{SWaT} & \\multicolumn{3}{l}{WADI}        \\\\ \\hline\nMetric                          & P      & R     & F1     & P      & R     & F1      & P      & R     & F1 \\\\ \\hline\nType (i)     & 91.84  & 88.93 & 90.33   & 90.82  & 90.67 & 90.74    & 91.57  & 82.47 & 86.78 \\\\\nType (ii)      & 91.37  & 89.18 & 90.26   & 64.96  & 80.60 & 71.94    & 93.12  & 89.06 & 90.95 \\\\   \\hline\n\\textbf{PAD} (PoA)   & 91.41  & 95.61 & \\textbf{93.46}  & 93.31  & 93.47 & \\textbf{93.32}   & 92.71  & 92.71 & \\textbf{92.71}\\\\  \n\\hline\n\\end{tabular} \n\\end{table}",
            "tbl:msl_archi1": "\\begin{table}[t]\n\\setlength{\\tabcolsep}{4pt}\n\\caption{The best architecture of the CDE function $f$ for MSL. $\\texttt{FC}$, $\\phi$,$\\rho$ stands for the fully-connected layer, the rectified linear unit (ReLU), and the hyperbolic tangent (tanh), respectively.}\\label{tbl:msl_archi1}\n\\begin{tabular}{cccc}\n\\hline\nDesign                  & Layer & Input                 & Output            \\\\ \\hline\n$\\phi$(\\texttt{FC})     & 1     & $256  \\times 64 $   & $256 \\times 256  $\\\\\n$\\phi$(\\texttt{FC})     & 2     & $256  \\times 256 $   & $256 \\times 256  $\\\\\n$\\phi$(\\texttt{FC})     & 3     & $256  \\times 256 $   & $256 \\times 256  $\\\\\n$\\phi$(\\texttt{FC})     & 4     & $256  \\times 256 $   & $256 \\times 256  $\\\\\n\\texttt{FC}     & 5     & $256  \\times 256$   & $256 \\times 3,520$  \\\\\\hline\n\\end{tabular}\n\\end{table}",
            "tbl:msl_archi2": "\\begin{table}[t]\n\\setlength{\\tabcolsep}{4pt}\n\\caption{The best architecture of the CDE function $g$ for MSL}\\label{tbl:msl_archi2}\n\\begin{tabular}{cccc}\n\\hline\nDesign                  & Layer & Input                 & Output            \\\\ \\hline\n$\\phi$(\\texttt{FC})            & 1     & $256  \\times 64 $   & $256 \\times 512   $\\\\\n$\\phi$(\\texttt{FC})     & 2     & $256  \\times 512 $   & $256 \\times 512  $\\\\\n$\\phi$(\\texttt{FC})     & 3     & $256  \\times 512 $   & $256 \\times 512  $\\\\\n$\\phi$(\\texttt{FC})     & 4     & $256  \\times 512 $   & $256 \\times 512  $\\\\\n\\texttt{FC}     & 5     & $256  \\times 512$   & $256 \\times 3,520$  \\\\\\hline\n\\end{tabular}\n\\end{table}",
            "tbl:msl_archi3": "\\begin{table}[t]\n\\setlength{\\tabcolsep}{4pt}\n\\caption{The best architecture of the shared CDE function $c$ for MSL}\\label{tbl:msl_archi3}\n\\begin{tabular}{cccc}\n\\hline\nDesign                  & Layer & Input                 & Output            \\\\ \\hline\n$\\phi$(\\texttt{FC})     & 1     & $256  \\times 64 $   & $256 \\times 64  $\\\\\n$\\rho$(\\texttt{FC})     & 2     & $256  \\times 256$   & $256 \\times 3,520$  \\\\\\hline\n\\end{tabular}\n\\end{table}",
            "tbl:swat_archi": "\\begin{table}[t]\n\\setlength{\\tabcolsep}{4pt}\n\\caption{The best architecture of the CDE function $f$ for SWaT.}\\label{tbl:swat_archi}\n\\begin{tabular}{cccc}\n\\hline\nDesign                  & Layer & Input                 & Output            \\\\ \\hline\n$\\phi$(\\texttt{FC})     & 2     & $256  \\times 64 $   & $256 \\times 128  $\\\\\n$\\phi$(\\texttt{FC})     & 3     & $256  \\times 128 $   & $256 \\times 128  $\\\\\n$\\phi$(\\texttt{FC})     & 4     & $256  \\times 128 $   & $256 \\times 128  $\\\\\n$\\phi$(\\texttt{FC})     & 5     & $256  \\times 128 $   & $256 \\times 128  $\\\\\n\\texttt{FC}     & 6     & $256  \\times 128$   & $256 \\times 3,264$  \\\\\\hline\n\\end{tabular}\n\\end{table}",
            "tbl:swat_archi2": "\\begin{table}[t]\n\\setlength{\\tabcolsep}{4pt}\n\\caption{The best architecture of the CDE function $g$ for SWaT.}\\label{tbl:swat_archi2}\n\\begin{tabular}{cccc}\n\\hline\nDesign                  & Layer & Input                 & Output            \\\\ \\hline\n$\\phi$(\\texttt{FC})     & 2     & $256  \\times 64 $   & $256 \\times 64  $\\\\\n$\\phi$(\\texttt{FC})     & 3     & $256  \\times 64 $   & $256 \\times 64  $\\\\\n$\\phi$(\\texttt{FC})     & 4     & $256  \\times 64 $   & $256 \\times 64  $\\\\\n$\\phi$(\\texttt{FC})     & 5     & $256  \\times 64 $   & $256 \\times 64  $\\\\\n\\texttt{FC}     & 6     & $256  \\times 64$   & $256 \\times 3,264$  \\\\\\hline\n\\end{tabular}\n\\end{table}",
            "tbl:swat_archi3": "\\begin{table}[t]\n\\setlength{\\tabcolsep}{4pt}\n\\caption{The best architecture of the shared CDE function $c$ for SWaT.}\\label{tbl:swat_archi3}\n\\begin{tabular}{cccc}\n\\hline\nDesign                  & Layer & Input                 & Output            \\\\ \\hline\n$\\phi$(\\texttt{FC})     & 1     & $256  \\times 64 $   & $256 \\times 64  $\\\\\n$\\rho$(\\texttt{FC})     & 2     & $256  \\times 64$   & $256 \\times 3,264$  \\\\\\hline\n\\end{tabular}\n\\end{table}",
            "tbl:wadi_archi": "\\begin{table}[t]\n\\setlength{\\tabcolsep}{4pt}\n\\caption{The best architecture of the CDE function $f$ for WADI.}\\label{tbl:wadi_archi}\n\\begin{tabular}{cccc}\n\\hline\nDesign                  & Layer & Input                 & Output            \\\\ \\hline\n$\\phi$(\\texttt{FC})     & 1     & $256  \\times 16 $   & $256 \\times 128  $\\\\\n$\\phi$(\\texttt{FC})     & 2     & $256  \\times 128 $   & $256 \\times 128  $\\\\\n$\\phi$(\\texttt{FC})     & 3     & $256  \\times 128 $   & $256 \\times 128  $\\\\\n$\\phi$(\\texttt{FC})     & 4     & $256  \\times 128 $   & $256 \\times 128  $\\\\\n\\texttt{FC}    & 5     & $256  \\times 128$   & $256 \\times 1,968 $  \\\\\\hline\n\\end{tabular}\n\\end{table}",
            "tbl:wadi_archi2": "\\begin{table}[t]\n\\setlength{\\tabcolsep}{4pt}\n\\caption{The best architecture of the CDE function $g$ for WADI.}\\label{tbl:wadi_archi2}\n\\begin{tabular}{cccc}\n\\hline\nDesign                  & Layer & Input                 & Output            \\\\ \\hline\n$\\phi$(\\texttt{FC})     & 1     & $256  \\times 16 $   & $256 \\times 128  $\\\\\n$\\phi$(\\texttt{FC})     & 2     & $256  \\times 128 $   & $256 \\times 128  $\\\\\n$\\phi$(\\texttt{FC})     & 3     & $256  \\times 128 $   & $256 \\times 128  $\\\\\n$\\phi$(\\texttt{FC})     & 4     & $256  \\times 128 $   & $256 \\times 128  $\\\\\n\\texttt{FC}     & 5     & $256  \\times 128 $   & $256 \\times 1,968$  \\\\\\hline\n\\end{tabular}\n\\end{table}",
            "tbl:wadi_archi3": "\\begin{table}[t]\n\\setlength{\\tabcolsep}{4pt}\n\\caption{The best architecture of the shared CDE function $c$ for WADI.}\\label{tbl:wadi_archi3}\n\\begin{tabular}{cccc}\n\\hline\nDesign                  & Layer & Input                 & Output            \\\\ \\hline\n$\\phi$(\\texttt{FC})     & 1     & $256  \\times 16 $   & $256 \\times 256  $\\\\\n$\\rho$(\\texttt{FC})     & 2     & $256  \\times 256$   & $256 \\times 1,968$  \\\\\\hline\n\\end{tabular}\n\\end{table}"
        },
        "figures": {
            "fig:comparison1": "\\begin{figure}\n    \\centering\n    \\subfigure[Anomaly detection]{\\includegraphics[width=0.35\\columnwidth]{images/concept_archi/CAD_0303.pdf}} \\hspace{2em}\n    \\subfigure[PoA detection]{\\includegraphics[width=0.35\\columnwidth]{images/concept_archi/POA_0302.pdf}}\n    % {\\includegraphics[width=0.45\\columnwidth]{images/google/0_google_25_new_new.pdf}}\n    \\caption{Comparison between the conventional anomaly detection and our proposed the precursor-of-anomaly (PoA) detection. In PoA, we predict whether the next window will contain any abnormal observation before it happens, which is much more challenging than the anomaly detection.}\n    \\label{fig:comparison1} \n\\end{figure}",
            "fig:ncde": "\\begin{figure}\n    \\centering\n    \\includegraphics[width=0.4\\columnwidth]{images/concept_archi/NCDE_archi.pdf}\n    \\caption{The architecture of NCDEs.}\n    \\label{fig:ncde}\n\\end{figure}",
            "fig:experimental_output": "\\begin{figure*}[!ht]\n    \\centering\n     \\subfigure[MSL]{\\includegraphics[width=0.54\\columnwidth]{images/output/MSL_output_513.pdf}} \\hfill\n    \\subfigure[SWaT]{\\includegraphics[width=0.54\\columnwidth]{images/output/SWaT_output_513.pdf}} \\hfill\n    \\subfigure[WADI]{\\includegraphics[width=0.54\\columnwidth]{images/output/WADI_output_513.pdf}} \n    \\caption{F1 score by varying the output length on 3 datasets.}\n    \\label{fig:experimental_output}\n\\end{figure*}",
            "fig:experimental_result_vis": "\\begin{figure}[t]\n    \\centering\n    \\subfigure[MSL]{\\includegraphics[width=0.45\\columnwidth]{images/vis/MSL_500_3000_3500.pdf}} \\hfill\n    \\subfigure[MSL]{\\includegraphics[width=0.45\\columnwidth]{images/vis/MSL_1000_36800_35800.pdf}} \\\\\n     \\subfigure[SWaT]{\\includegraphics[width=0.45\\columnwidth]{images/vis/SWAT_700_29370_29980.pdf}} \\hfill\n     \\subfigure[SWaT]{\\includegraphics[width=0.45\\columnwidth]{images/vis/SWAT_1000_42000_43000.pdf}} \\\\\n    \\subfigure[WADI]{\\includegraphics[width=0.45\\columnwidth]{images/vis/WADI_400_12500_12900.pdf}} \\hfill\n    \\subfigure[WADI]{\\includegraphics[width=0.45\\columnwidth]{images/vis/WADI_700_15300_16000.pdf}} \\\\\n    \\caption{The anomaly detection and the precursor-of-anomaly detection results on 3 datasets.}\n    \\label{fig:experimental_result_vis}\n\\end{figure}"
        },
        "equations": {
            "eq:1": "\\begin{align}\n    \\mathbf{z}(T) = \\mathbf{z}(0) + \\int_{0}^{T}f(\\mathbf{z}(t),t;\\mathbf{\\theta}_f)dt.\n\\end{align}",
            "eq:2": "\\begin{align}\n\\mathbf{z}(T) &= \\mathbf{z}(0) + \\int_{0}^{T} f(\\mathbf{z}(t);\\mathbf{\\theta}_f) dX(t),\\\\\n &=\\mathbf{z}(0) + \\int_{0}^{T} f(\\mathbf{z}(t);\\mathbf{\\theta}_f) \\frac{dX(t)}{dt} dt,\\label{eq:ncde}\n\\end{align}",
            "eq:3": "\\begin{align}\\begin{split}\n    &\\mathbf{h}(T) = \\mathbf{h}(0) + \\int_{0}^{T} f(\\mathbf{h}(t);\\mathbf{\\theta}_f,\\mathbf{\\theta}_c) \\frac{dX(t)}{dt} dt,\\\\\n    &\\mathbf{z}(T)=\\mathbf{z}(0) + \\int_{0}^{T} g(\\mathbf{z}(t);\\mathbf{\\theta}_g,\\mathbf{\\theta}_c) \\frac{dX(t)}{dt} dt,\n\\end{split}\\label{eq:co-evolving_ncde}\\end{align}",
            "eq:4": "\\begin{align}\n    f(\\mathbf{h}(t);\\theta_f,\\theta_c) &= \\underbrace{\\rho(\\texttt{FC}(\\phi(\\texttt{FC}(\\mathbf{h}(t)))))}_{\\theta_f}+ \\underbrace{\\rho(\\texttt{FC}(\\phi(\\texttt{FC}(\\mathbf{h}(t)))))}_{\\theta_c},\\\\\n    g(\\mathbf{z}(t);\\theta_g,\\theta_c) &= \\underbrace{\\rho(\\texttt{FC}(\\phi(\\texttt{FC}(\\mathbf{z}(t)))))}_{\\theta_g}+ \\underbrace{\\rho(\\texttt{FC}(\\phi(\\texttt{FC}(\\mathbf{z}(t)))))}_{\\theta_c}\n\\end{align}",
            "eq:5": "\\begin{align}\n\\hat{y}_{i}^a=&\\sigma(\\texttt{FC}_{\\theta_a}(\\mathbf{h}(T))),\\textrm{ for the anomaly detection},\\\\\n\\hat{y}_{i}^p=&\\sigma(\\texttt{FC}_{\\theta_p}(\\mathbf{z}(T))),\\textrm{ for the precursor-of-anomaly detection},\\label{eq:pd}\n\\end{align}",
            "eq:6": "\\begin{align} \\label{eq3}\n\\frac{d}{dt}{\\begin{bmatrix}\n  \\mathbf{h}(t) \\\\\n  \\mathbf{z}(t)\n  \\end{bmatrix}\\!} = {\\begin{bmatrix}\n  f(\\mathbf{h}(t);\\mathbf{\\theta}_f,\\mathbf{\\theta}_c) \\frac{dX(t)}{dt} \\\\\n  g(\\mathbf{z}(t);\\mathbf{\\theta}_g,\\mathbf{\\theta}_c) \\frac{dX(t)}{dt}\n  \\end{bmatrix},\\!}\n\\end{align}",
            "eq:7": "\\begin{align}\n{\\begin{bmatrix}\n  \\mathbf{h}(0) \\\\\n  \\mathbf{z}(0)\n  \\end{bmatrix}\\!} = {\\begin{bmatrix}\n  \\texttt{FC}_{\\theta_\\mathbf{h}}(X(0)) \\\\\n  \\texttt{FC}_{\\theta_\\mathbf{z}}(X(0))\n  \\end{bmatrix}.\\!}\n\\end{align}",
            "eq:8": "\\begin{align}\n    \\begin{split}\\label{eq:kd_loss_function}\n        L_{KD} &= CE(\\hat{y}^a_{i+1},\\hat{y}^p_{i+1}), \\\\\n    \\end{split}\n\\end{align}",
            "eq:9": "\\begin{align}\n\\begin{split}\\label{eq:anomaly_loss_function}\n        L_a &= CE(\\hat{y}^a_i,y_i),\\\\\n    \\end{split}\n\\end{align}",
            "eq:10": "\\begin{align}\n    \\begin{split}\n        \\nabla_{\\mathbf{\\theta}_f} L_a &= -\\int^{0}_{T}\\frac{\\partial L_a}{\\partial\\mathbf{h}(t)}^T\\frac{\\partial f(\\mathbf{h}(t),t;\\theta_f,\\theta_c)}{\\partial \\theta_f} \\frac{dX(t)}{dt} dt,\\\\\n        \\nabla_{\\mathbf{\\theta}_f} L_{KD} &= -\\int^{0}_{T}\\frac{\\partial L_{KD}}{\\partial\\mathbf{h}(t)}^T\\frac{\\partial f(\\mathbf{h}(t),t;\\theta_f,\\theta_c)}{\\partial \\theta_f}\\frac{dX(t)}{dt} dt,\\\\\n        \\nabla_{\\mathbf{\\theta}_g} L_{KD} &= -\\int^{0}_{T}\\frac{\\partial L_{KD}}{\\partial\\mathbf{z}(t)}^T\\frac{\\partial g(\\mathbf{z}(t),t;\\theta_g,\\theta_c)}{\\partial \\theta_g}\\frac{dX(t)}{dt} dt,\\\\\n         \\nabla_{\\mathbf{\\theta}_c} L_a + L_{KD}&= -\\int^{0}_{T}\\frac{\\partial L_a + L_{KD}}{\\partial\\mathbf{h}(t)}^T\\frac{\\partial f(\\mathbf{h}(t),t;\\theta_f,\\theta_c)}{\\partial \\theta_c} \\frac{dX(t)}{dt} dt \\\\\n        & -\\int^{0}_{T}\\frac{\\partial L_a + L_{KD}}{\\partial\\mathbf{z}(t)}^T\\frac{\\partial g(\\mathbf{z}(t),t;\\theta_g,\\theta_c)}{\\partial \\theta_c} \\frac{dX(t)}{dt} dt.\n    \\end{split}\n\\end{align}"
        },
        "git_link": "https://github.com/sheoyon-jhin/PAD"
    }
}