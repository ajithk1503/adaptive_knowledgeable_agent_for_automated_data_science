{
    "meta_info": {
        "title": "Heterformer: Transformer-based Deep Node Representation Learning on  Heterogeneous Text-Rich Networks",
        "abstract": "Representation learning on networks aims to derive a meaningful vector\nrepresentation for each node, thereby facilitating downstream tasks such as\nlink prediction, node classification, and node clustering. In heterogeneous\ntext-rich networks, this task is more challenging due to (1) presence or\nabsence of text: Some nodes are associated with rich textual information, while\nothers are not; (2) diversity of types: Nodes and edges of multiple types form\na heterogeneous network structure. As pretrained language models (PLMs) have\ndemonstrated their effectiveness in obtaining widely generalizable text\nrepresentations, a substantial amount of effort has been made to incorporate\nPLMs into representation learning on text-rich networks. However, few of them\ncan jointly consider heterogeneous structure (network) information as well as\nrich textual semantic information of each node effectively. In this paper, we\npropose Heterformer, a Heterogeneous Network-Empowered Transformer that\nperforms contextualized text encoding and heterogeneous structure encoding in a\nunified model. Specifically, we inject heterogeneous structure information into\neach Transformer layer when encoding node texts. Meanwhile, Heterformer is\ncapable of characterizing node/edge type heterogeneity and encoding nodes with\nor without texts. We conduct comprehensive experiments on three tasks (i.e.,\nlink prediction, node classification, and node clustering) on three large-scale\ndatasets from different domains, where Heterformer outperforms competitive\nbaselines significantly and consistently.",
        "author": "Bowen Jin, Yu Zhang, Qi Zhu, Jiawei Han",
        "link": "http://arxiv.org/abs/2205.10282v2",
        "category": [
            "cs.CL",
            "cs.LG"
        ],
        "additionl_info": "KDD 2023. (Code: https://github.com/PeterGriffinJin/Heterformer)"
    },
    "latex_extraction": {
        "content": {
            "section 1": {
                "name": "Introduction",
                "content": "\\label{sec::intro}\nHeterogeneous text-rich networks are ubiquitously utilized to model real-world data such as academic networks \\cite{tang2008arnetminer}, product networks \\cite{dong2020autoknow}, and social media \\cite{el2022twhin}.\nSuch networks often have two characteristics: \n(1) \\textit{Text-rich}: \\textbf{some} types of nodes are associated with textual information. For instance, papers in academic networks \\cite{tang2008arnetminer} have their titles and abstracts; tweets in social media networks \\cite{el2022twhin} have their tweet contents.\n(2) \\textit{Heterogeneous}: nodes and edges in the network are multi-typed. For example, academic networks \\cite{tang2008arnetminer} have paper, author, and venue nodes; product networks \\cite{dong2020autoknow} have edges between users and products reflecting ``purchase'' and ``view'' relations. \nIn such text-rich networks (Figure \\ref{fig:intro}(a)), to obtain satisfying node representations which can be generalized to various tasks such as link prediction \\cite{sun2011pathsim}, node classification \\cite{wang2019heterogeneous}, and recommendation \\cite{zhang2019heterogeneous}, the model needs to consider both \\textbf{text semantics} and \\textbf{heterogeneous} structure (network) information.\n\n% text-rich network example\n\n\nTo capture the rich text semantic signals, Transformer \\cite{vaswani2017attention} is a powerful architecture featured by its fully connected attention mechanism.\nTaking Transformer as the backbone, pretrained language models (PLMs) \\cite{devlin2018bert,liu2019roberta,clark2020electra} learned from web-scale corpora can obtain contextualized semantic representations of words and documents.\nThese representations are demonstrated to be of high quality in various text mining tasks \\cite{sia2020tired,chang2020taming,liu2019fine}. \nTo introduce the advanced capability of PLMs into node representation learning on text-rich networks, existing works mainly adopt a cascaded architecture \\cite{jin2021bite,li2021adsgnn,zhu2021textgnn,zhang2019shne}, where the textual information of each node is first encoded via PLMs and then aggregated via graph encoders \\cite{kipf2017semi, hamilton2017inductive, velivckovic2017graph}.\nIn such cases, the link connecting two nodes is not utilized when generating their text representations.\nIn fact, linked nodes can benefit each other regarding text semantics understanding. \nFor example, the term ``Transformer'' in a paper cited by many machine learning papers should refer to a deep learning model rather than an electrical engineering component.\nGraphFormers \\cite{yang2021graphformers} further introduce a nested Transformer architecture for deep information integration between text encoding modules and network encoding modules. \nPatton \\cite{jin2023patton} proposes two strategies to pretrain GraphFormers on text-rich networks.\nYet, they adopt a strict homogeneous network assumption (\\textit{i.e.}, all the nodes are associated with semantically rich text and are of the same type), which is hard to be satisfied in practice.\n\nAs a matter of fact, real-world text-rich networks are usually heterogeneous with the heterogeneity coming from two sources: the presence or absence of text and the diversity of types. \n\\vspace{3px}\n\\begin{itemize}[leftmargin=*,partopsep=0pt,topsep=0pt]\n\\setlength{\\itemsep}{0pt}\n\\setlength{\\parsep}{0pt}\n\\setlength{\\parskip}{0pt}\n\n\\item \\textbf{Presence or Absence of Text.}\nNot every node in text-rich networks exhibits rich textual information.\nInstead, some nodes are not guaranteed to contain textual information (\\textit{e.g.}, many users are not associated with text information in social media networks).\nBased on the presence or absence of text, nodes can be categorized into \\textbf{text-rich} nodes  (associated with semantically rich text, \\textit{e.g.}, tweets and papers) and \\textbf{\\tl} nodes (without semantically rich text, \\textit{e.g.}, users and authors).\nText-rich nodes can intuitively contribute to representation learning with the rich texts, while \\tl nodes can also be strong semantic indicators in the network. \nFor example, given a paper node about ``Byzantine'' which is linked to an author node (\\tl) with many paper neighbors related to ``distributed system'', \nwe can infer that ``Byzantine'' here refers to a computer network term rather than an empire in history.\nSince both text-rich nodes and \\tl nodes should be considered, how to leverage both kinds of nodes in representation learning with PLMs is an open question that needs to be answered.\n\n\\item \\textbf{Diversity of Types.} \nAs previously stated, a large number of real-world networks contain nodes and edges of different types. \nFor example, there are at least three types of nodes (``paper'', ``author'', and ``venue'' nodes) in academic networks \\cite{tang2008arnetminer}; there are at least four types of edges (``click'', ``view'', ``cart'', and ``purchase'' edges) between users and products in e-commerce networks \\cite{dong2020autoknow}.\nDifferent types of nodes/edges have different traits and their features may fall in different feature spaces.\nFor instance, the feature of a user may contain gender, age, and nationality while the feature of an item may contain price and quality. \nHow to handle such complex structural information while preserving the diverse type information simultaneously with PLMs is a crucial issue that needs to be solved.\n\\end{itemize}\n\n\n\\vspace{3px}\n\\noindent \\textbf{Present Work.}\nTo this end, we propose a network-empowered Transformer (Figure \\ref{fig:intro}(b)), \\textit{i.e.}, \\Ours, for node representation learning on heterogeneous text-rich networks, while capturing the two sources of heterogeneity mentioned above. \nSpecifically:\n(1) In \\textit{the whole model}, we introduce virtual neighbor tokens inside each Transformer layer (initialized by the corresponding layer in a PLM, \\textit{e.g.}, BERT \\cite{devlin2018bert}) for text encoding, to fuse representations of each nodeâ€™s text-rich neighbors, textless neighbors, and its own content via the fully connected attention mechanism. The virtual neighbor token hidden states are attention-based aggregations of neighbor node embeddings.\n(2) To deal with the \\textit{presence or absence of text}, two virtual neighbor tokens are utilized to capture the semantic signals from text-rich neighbors and \\tl neighbors, respectively. Furthermore, we propose an embedding warm-up stage for \\tl nodes to obtain better initial embeddings before the whole model training.\n(3) To capture the \\textit{diversity of types}, we use type-specific transformation matrices to project different types of nodes into the same latent space. When calculating virtual neighbor token hidden states, the aggregation module collects information from its neighbors by characterizing edge types in the attention mechanism.\nThe overall model is optimized via an unsupervised link prediction objective \\cite{perozzi2014deepwalk, hamilton2017inductive}.\n\n\\vspace{3px}\nThe main contributions of our paper are summarized as follows:\n\\begin{itemize}[leftmargin=*,partopsep=0pt,topsep=0pt]\n    \\setlength{\\itemsep}{0pt}\n    \\setlength{\\parsep}{0pt}\n    \\setlength{\\parskip}{0pt}\n    \\item We formalize the problem of node representation learning on heterogeneous text-rich networks, which involves joint encoding of heterogeneous network structures and textual semantics.\n    \\item We point out heterogeneity from two sources and propose a heterogeneous network-empowered Transformer architecture called \\Ours, which deeply couples text encoding and heterogeneous structure (network) encoding.\n    \\item  We conduct comprehensive experiments on three public text-rich networks from different domains, where \\Ours outperforms competitive baseline models (including GNN-cascaded Transformers and nested Transformers) significantly and consistently on various tasks, including link prediction, node classification, and node clustering.\n\\end{itemize}\n\\vspace{-0.2in}\n"
            },
            "section 2": {
                "name": "Preliminaries",
                "content": "\\label{sec::profdef}\n",
                "subsection 2.1": {
                    "name": "Heterogeneous Text-rich Networks",
                    "content": "\n\n% \\vspace{3px}\n\\noindent\\textbf{Definition 2.1. Heterogeneous Networks \\cite{sun2012mining}.} A heterogeneous network is defined as $\\mathcal{G}=(\\mathcal{V}, \\mathcal{E}, \\mathcal{A}, \\mathcal{R})$, where $\\mathcal{V}$, $\\mathcal{E}$, $\\mathcal{A}$, $\\mathcal{R}$ represent the sets of nodes, edges, node types, and edge types, respectively. $|\\mathcal{A}|+|\\mathcal{R}|>2$. A heterogeneous network is also associated with a node type mapping function $\\phi: \\mathcal{V}\\rightarrow\\mathcal{A}$ and an edge type mapping function $\\psi: \\mathcal{E}\\rightarrow\\mathcal{R}$.\n\n\\vspace{3px}\n\\noindent\\textbf{Definition 2.2. Text-Rich Nodes and \\Tl Nodes.} In a heterogeneous network $\\mathcal{G}=(\\mathcal{V}, \\mathcal{E}, \\mathcal{A}, \\mathcal{R})$, $v\\in\\mathcal{V}$ is \\textbf{text-rich} if it is associated with semantically rich text information $doc\\in\\mathcal{D}$. $\\mathcal{D}$ is the document set. Otherwise, it is \\textbf{\\tl}. We assume that nodes of the same type are either all text-rich or all \\tl. \n\n\\vspace{3px}\n\\noindent\\textbf{Definition 2.3. Heterogeneous Text-Rich Networks \\cite{zhang2019shne,shi2019discovering}.}\nA heterogeneous network $\\mathcal{G}=(\\mathcal{V}, \\mathcal{E}, \\mathcal{A}, \\mathcal{R}, \\mathcal{D})$ is a heterogeneous text-rich network if $\\mathcal{D}\\neq \\varnothing$, $\\mathcal{A}=\\mathcal{A}_\\text{TR}\\cup \\mathcal{A}_\\text{TL}$, $\\mathcal{A}_\\text{TR}\\cap \\mathcal{A}_\\text{TL}=\\varnothing$ and $\\mathcal{A}_\\text{TR} \\neq \\varnothing$, where $\\mathcal{A}_\\text{TR}$ and $\\mathcal{A}_\\text{TL}$ denote the sets of text-rich node types and \\tl node types, respectively.%\\qi{what about $\\mathcal{A}_\\text{TL}$ and $\\mathcal{A}_\\text{TR}$}.\n\n\n\n\n\\vspace{-0.2in}\n"
                },
                "subsection 2.2": {
                    "name": "Transformer",
                    "content": "\nA large number of PLMs (\\textit{e.g.}, BERT \\cite{devlin2018bert}) utilize the multi-layer Transformer architecture \\cite{vaswani2017attention} to encode texts. \nEach Transformer layer adopts a multi-head self-attention mechanism to gain a contextualized representation of each text token. Specifically, let $\\bmH^{(l)}=[\\bm{h}^{(l)}_1, \\bm{h}^{(l)}_2, ..., \\bm{h}^{(l)}_n]$ denote the output hidden states of the $l$-th Transformer layer, where $\\bm{h}^{(l)}_i\\in\\mathcal{R}^d$ is the representation of the text token at position $i$.\nThen, the multi-head self-attention (MHA) in the ($l$+1)-th Transformer layer is calculated as\n\\begin{gather}\n    {\\rm MHA}({\\bmH}^{(l)}) = \\mathop{\\Vert}_{t=1}^k {\\rm head}^t({\\bmH}^{(l)}_{t})\n\\end{gather}\n\\begin{gather}\n    {\\rm head}^t({\\bmH}^{(l)}_{t}) = \\bmV^{(l)}_{t}\\cdot{\\rm softmax}(\\frac{\\bmK^{(l)\\top}_{t}\\bmQ^{(l)}_{t}}{\\sqrt{d/k}})\n\\end{gather}\n\\begin{gather}\n    \\bmQ^{(l)}_{t} = \\bmW^{(l)}_{Q,t}{\\bmH}^{(l)}_{t},\\ \\ \\ \\  \\bmK^{(l)}_{t} = \\bmW^{(l)}_{K,t}{\\bmH}^{(l)}_{t},\\ \\ \\ \\ \\bmV^{(l)}_{t} = \\bmW^{(l)}_{V,t}{\\bmH}^{(l)}_{t},\n\\end{gather}\nwhere $\\bmW_{Q,t}, \\bmW_{K,t}, \\bmW_{V,t}$ are query, key, and value matrices to be learned by the model, $k$ is the number of attention head and $\\Vert$ is the concatenate operation.\n\n"
                },
                "subsection 2.3": {
                    "name": "Problem Formulation",
                    "content": "\n\\noindent\\textbf{Definition 2.4. Node Representation Learning on Heterogeneous Text-Rich Networks.} Given a heterogeneous text-rich network $\\mathcal{G}=(\\mathcal{V}, \\mathcal{E}, \\mathcal{A}, \\mathcal{R}, \\mathcal{D})$, the task is to build a model $f_\\Theta: \\mathcal{V} \\rightarrow \\mathbb{R}^d$ with parameters $\\Theta$ to learn meaningful node representation vectors for both text-rich and \\tl nodes, taking heterogeneous network structures and text semantics into consideration. \nThe learned node embeddings should be able to generalize to various downstream tasks, such as link prediction, node classification and node clustering.%, \\textit{etc}.\n\n\n"
                }
            },
            "section 3": {
                "name": "Methodology",
                "content": "\\label{sec::method}\nIn this section, we present the details of \\Ours, the architecture of which is shown in Figure \\ref{fig::whole-structure}. \nWe first introduce how to conduct text-rich node encoding by jointly considering text information and heterogeneous structure information via a Transformer-based architecture. Then, we illustrate how to perform effective \\tl node learning with heterogeneous node type projection and embedding warm-up. Finally, we discuss how to conduct unsupervised model training.\n\n\n% \\vspace{-0.4cm}\n",
                "subsection 3.1": {
                    "name": "Text-Rich Node Encoding",
                    "content": "\\label{sec::text-rich-encoder}\n\n",
                    "subsubsection 3.1.1": {
                        "name": "Network-aware Node Text Encoding with Virtual Neighbor Tokens",
                        "content": "\\label{sec::main-model}\nEncoding text $doc_{v_i}$ of node $v_i$ in a heterogeneous text-rich network differs from encoding plain text, mainly because node texts are associated with network structure information, which can provide auxiliary signals \\cite{hamilton2017inductive}. \nFor example, a paper cited by many deep learning papers in an academic network can be highly related to machine learning.\nGiven that text semantics can be well captured by a multi-layer Transformer architecture \\cite{devlin2018bert}, we propose a simple but effective way to inject network signals into the Transformer encoding process. The key idea is to introduce \\textit{virtual neighbor tokens}.\nGiven a node $v_i$ and its associated texts $doc_{v_i}$, let $\\bmH^{(l)}_{v_i}\\in \\mathcal{R}^{d\\times n}$ denote the output hidden states of all text tokens in $doc_{v_i}$ after the $l$-th model layer ($l\\geq1$). In each layer, we introduce two virtual neighbor tokens to represent $v_i$'s text-rich neighbors $\\widehat{N}_{v_i}$ and \\tl neighbors $\\widecheck{N}_{v_i}$ in the network respectively. Their embeddings are denoted as $\\widehat{\\bmz}^{(l)}_{v_i}$ and $\\widecheck{\\bmz}^{(l)}_{v_i} \\in \\mathcal{R}^d$, which are concatenated to the original text token sequence hidden states as follows (We will discuss how to obtain $\\widehat{\\bmz}^{(l)}_{v_i}$ and $\\widecheck{\\bmz}^{(l)}_{v_i}$ in Section \\ref{sec::aggregation}.):\n\\begin{equation}\\label{eq::concate}\n    \\widetilde{\\bmH}^{(l)}_{v_i} = \\widehat{\\bmz}^{(l)}_{v_i} \\mathop{\\Vert} \\bmH^{(l)}_{v_i} \\mathop{\\Vert} \\widecheck{\\bmz}^{(l)}_{v_i}.\n\\end{equation}\nAfter the concatenation, $\\widetilde{\\bmH}^{(l)}_{v_i}$ contains information from both $v_i$'s accompanied text $doc_{v_i}$ and its neighbors in the network, \\textit{i.e.}, $\\widehat{N}_{v_i}$ and $\\widecheck{N}_{v_i}$. \n(It is worth noting that we insert two virtual neighbor tokens to take the \\textit{presence or absence of text heterogeneity} of nodes into consideration.)\nTo let the text token representations carry network signals, we adopt a multi-head attention mechanism (MHA):\n\\begin{gather*}\n    {\\rm MHA}(\\bmH^{(l)}_{v_{i}},\\widetilde{\\bmH}^{(l)}_{v_{i}}) = \\mathop{\\Vert}_{t=1}^k {\\rm head}^t(\\bmH^{(l)}_{v_{i},t},\\widetilde{\\bmH}^{(l)}_{v_{i},t}), \\label{mha_asy} \\\\\n    \\bmQ^{(l)}_{t} = \\bmW^{(l)}_{Q,t}\\bmH^{(l)}_{v_{i},t},\\ \\ \\ \\  \\bmK^{(l)}_{t} = \\bmW^{(l)}_{K,t}\\widetilde{\\bmH}^{(l)}_{v_{i},t},\\ \\ \\ \\ \\bmV^{(l)}_{t} = \\bmW^{(l)}_{V,t}\\widetilde{\\bmH}^{(l)}_{v_{i},t}.\n\\end{gather*}\nIn the equation above, the multi-head attention is asymmetric (\\textit{i.e.,} the keys $\\bmK$ and values $\\bmV$ are augmented with virtual neighbor embeddings but queries $\\bmQ$ are not) to avoid network information being overwritten by text signals and utilize refreshed neighbor representations from each Transformer layer. The output of MHA includes updated network-aware representations of text tokens. Then, following the Transformer architecture \\cite{vaswani2017attention}, the updated representations will go through a feed-forward network (FFN) to finish our ($l$+1)-th model layer encoding. Formally,\n\\begin{equation}\\label{eq::transformers}\n    \\begin{gathered}\n        \\widetilde{\\bmH}^{(l)'}_{v_{i}} = {\\rm LN}(\\bmH^{(l)}_{v_{i}} + {\\rm MHA}(\\bmH^{(l)}_{v_{i}},\\widetilde{\\bmH}^{(l)}_{v_{i}})), \\\\\n        \\bmH^{(l+1)}_{v_{i}} = {\\rm LN}(\\widetilde{\\bmH}^{(l)'}_{v_{i}} + {\\rm MLP}(\\widetilde{\\bmH}^{(l)'}_{v_{i}})).\n    \\end{gathered}\n\\end{equation}\nwhere ${\\rm LN}(\\cdot)$ denotes the layer normalization function. After $L$ model layers, the final representation of the \\cls token will be used as the node representation of $v_i$, \\textit{i.e.}, $h_{v_i}=\\bmH^{(L+1)}_{v_{i}}\\cls$.\n\n% \\vspace{-0.8cm}\n"
                    },
                    "subsubsection 3.1.2": {
                        "name": "MHA-based Heterogeneous Neighbor Aggregation",
                        "content": "\\label{sec::aggregation}\nThe virtual neighbor token embeddings $\\widehat{\\bmz}^{(l)}_{v_i}, \\widecheck{\\bmz}^{(l)}_{v_i}$ in Eq.(\\ref{eq::concate}) should be the information concentration of $v_i$'s text-rich neighbors and \\tl neighbors respectively.\nInspired by the MHA mechanism in Transformer architectures \\cite{vaswani2017attention}, we design a multi-head attention module to aggregate the information from neighbors and capture the \\textit{type heterogeneity} associated with the \\textit{edges}. The neighbor aggregation vector $\\bar{\\bmz}^{(l)}_{v_i}$ ($\\in \\{\\widehat{\\bmz}^{(l)}_{v_i}, \\widecheck{\\bmz}^{(l)}_{v_i}$\\}) of the $l$-th layer for $v_i$ is calculated as follows:\n\\begin{equation}\\label{eq::mha}\n    \\begin{aligned}\n        \\bar{\\bmz}^{(l)}_{v_i} &= \\mathop{\\Vert}_{t=1}^k {\\rm head}^t(\\bmh^{(l)}_{v_i,t}, \\{\\bmh^{(l)}_{v_j\\rightarrow v_i,t}|v_j\\in \\bar{N}_{v_i}\\}), \\\\\n        & = \\mathop{\\Vert}_{t=1}^k \\sum\\limits_{v_j \\in \\bar{N}_{v_i}\\cup\\{v_i\\}} \\bar{\\alpha}^{(l)}_{{v_i}{v_j},t}\\bar{\\bmW}^{(l)}_{V,t} \\bmh^{(l)}_{v_j\\rightarrow v_i,t}.\n    \\end{aligned}\n\\end{equation}\nIn the equation, $\\bar{x} \\in \\{\\widehat{x}, \\widecheck{x}\\}$ ($x$ can be $\\bmz_v$, $N_v$, $\\alpha$, $W$). $\\widehat{x}$ denotes text-rich instances and $\\widecheck{x}$ denotes \\tl instances. \n $\\bmh^{(l)}_{v_i,t}\\in \\mathbb{R}^{\\frac d k}$ represents the $t$-th chunk of $\\bmh^{(l)}_{v_i}$ (For a text-rich node $v_s$, $\\bmh^{(l)}_{v_s}=\\bmH^{(l)}_{v_{s}}\\cls$; For a \\tl node $v_p$, we will discuss how to obtain $\\bmh^{(l)}_{v_p}$ in Section \\ref{sec::textless}.).\n $d$ is the dimension of vectors $\\bmh^{(l)}_{v_i}$.\n $\\bar{\\bmW}_V$ is the value projection matrix.\n % $k$ is the number of chunks.\n$\\alpha_{v_iv_j}$ is the attention weight of $v_j$ to $v_i$ which is calculated as follows,\n\\begin{equation}\n    \\begin{aligned}\n        \\bar{\\alpha}^{(l)}_{{v_i}{v_j},t} &= {\\rm softmax}(\\bar{e}^{(l)}_{{v_i}{v_j},t}) \\\\    \n        &= {\\rm softmax}({\\rm Norm}((\\bar{\\bmW}^{(l)}_{Q,t} \\bmh^{(l)}_{x,t} )^\\top (\\bar{\\bmW}^{(l)}_{K,t} \\bmh^{(l)}_{{v_j}\\rightarrow {v_i},t} ))).\n    \\end{aligned}\n\\end{equation}\n$\\bar{\\bmW}_Q$, $\\bar{\\bmW}_K$ are query and key projection matrices, respectively. $\\text{Norm}(\\cdot)$ is the scale normalization function, \\textit{i.e.}, $\\text{Norm}(x)=x/\\sqrt{d/k}$. \n$\\bmh^{(l)}_{v_j\\rightarrow v_i}$ is the propagation vector from $v_j$ to $v_i$, which is calculated as follows depending on the edge type,\n\\begin{equation}\\label{eq::prop}\n    \\begin{aligned}  \n        \\bmh^{(l)}_{v_j\\rightarrow v_i} = \\bmW_r \\bmh^{(l)}_{v_j}, \\ \\text{where}\\ \\psi(e_{v_jv_i}) = r.\n    \\end{aligned}\n\\end{equation} % \n In the equation, $e_{v_jv_i}$ denotes the edge between $v_j$ and $v_i$;\n $\\bmW_r$ is the edge type-aware projection matrix, which is designed for capturing the \\textit{edge} semantic \\textit{heterogeneity}.\n\n\n% \\vspace{-0.15cm}\n"
                    }
                },
                "subsection 3.2": {
                    "name": "\\Tl Node Encoding",
                    "content": "\\label{sec::textless}\n",
                    "subsubsection 3.2.1": {
                        "name": "Node Type Heterogeneity-based Representation",
                        "content": "\nIn this section, we will discuss how to obtain $\\bmh_{v_p}$ for a \\tl node $v_p$.\nAlthough they lack semantically rich text, \\tl nodes can be quite important as they may contribute significant signals to their neighbors in real-world heterogeneous networks. For example, in an academic network, two papers published in the same venue (textless node) can be on similar topics. Moreover, \\tl nodes can also be target nodes for downstream tasks such as author classification.\n\nTo align with how we encode text-rich nodes using Transformer-based architectures \\cite{vaswani2017attention} (which is introduced in Section \\ref{sec::text-rich-encoder}), a straightforward idea of \\tl node encoding is to represent each \\tl node $v_p$ as a high-dimensional learnable embedding vector $\\bmh_{v_p}$ (\\textit{e.g.}, $\\bmh_{v_p} \\in \\mathbb{R}^{768}$ to be compatible with BERT-base \\cite{devlin2018bert} used in text-rich node encoding). \nNevertheless, the large population of textless nodes will then introduce a large number of parameters to our framework, which may finally lead to model underfitting.\nIn addition, due to \\textit{node type heterogeneity}, different types of nodes can naturally belong to different latent semantic spaces.\nIn summary, we design a simple function to calculate $\\bmh^{(l)}_{v_p}$ as follows,\n\\begin{equation}\\label{eq::node-proj}\n    \\bmh^{(l)}_{v_p} = \\bmW^{(l)}_{\\phi_i} \\bmh^{(0)}_{v_p},\\ \\ \\ \\text{where}\\ \\phi(v_p)=\\phi_i,\\ \\ \\phi_i\\in\\mathcal{A}_\\text{TL}.\n\\end{equation}\nWe set $\\bmh^{(0)}_{v_p}$ up as a low-dimensional embedding vector of $v_p$ (\\textit{e.g.}, $\\bmh^{(0)}_{v_p} \\in \\mathbb{R}^{64}$) and project it into a more flexible high-dimensional space with a projection matrix $\\bmW^{(l)}_{\\phi_i}$. \nFor different \\tl node type $\\phi_i\\in\\mathcal{A}_\\text{TL}$, we will have different type-specific projection matrix $\\bmW^{(l)}_{\\phi_i}$ for the transformation.\nBy this design, the \\textit{node type heterogeneity} is captured.\nIt is worth noting that the column vectors of $\\bmW^{(l)}_{\\phi_i}$ can be viewed as ``semantic topic embedding vectors'' \\cite{cui2020enhancing} for nodes in type $\\phi_i$, and each entry of $\\bmh^{(0)}_{v_p}$ represents $v_p$'s weight towards one particular topic. In our experiment, we adopt a shared $\\bmW^{(l)}_{\\phi_i}$ for each layer, since we find this design can contribute to the best performance.\n\n"
                    },
                    "subsubsection 3.2.2": {
                        "name": "\\Tl Node Embedding Warm Up",
                        "content": "\\label{sec::pretrain}\nIn real-world heterogeneous networks, \\tl nodes are of a large population. For example, in academic graphs (\\textit{e.g.}, DBLP \\cite{tang2008arnetminer}), there are millions of author nodes and thousands of venue nodes, which are not naturally associated with semantically rich texts; in social networks (\\textit{e.g.}, Twitter \\cite{yang2011patterns}), there are millions of user nodes and hashtag nodes which are \\tl.\nLearning \\tl node embeddings from scratch in Eq. (\\ref{eq::node-proj}) seems to be a solution to capture node semantics.\nHowever, the presence of a substantial amount of textless nodes in the framework would add a considerable amount of parameters and may result in the underfitting of the model.\nTherefore, the parameter initialization of $\\bmh^{(0)}_{v_p}$ and $\\bmW^{(l)}_{\\phi_i}$ will be crucial towards model optimization \\cite{glorot2010understanding}.\nTo this end, we design a warm-up step to distill information from semantic-rich PLMs into \\tl node embeddings, which gives \\tl node embeddings good initializations before \\Ours finetuning.\nThe philosophy is to align the initial \\tl node embeddings into the same latent space with representations generated by the PLM (which we utilize to initialize the Transformer layers).\nThe warm-up step is shown below:\n\\begin{equation}\n\\label{warm-up}\n\\small\n    \\min_{\\bmh^{(l)}_{v_p}}\\mathcal{L}_{w}=\\sum_{\\substack{v_p\\in\\mathcal{V} \\\\ \\phi(v_p)\\in \\mathcal{A}_\\text{TL}}}\\sum_{v_u\\in \\widehat{N}_{v_p}}-\\log\\frac{\\exp(\\widebar{\\bmh}_{v_u}^{\\ \\top} \\bmh^{(l)}_{v_p})}{\\exp(\\widebar{\\bmh}_{v_u}^{\\ \\top} \\bmh^{(l)}_{v_p})+\\sum_{v_u'}\\exp(\\widebar{\\bmh}_{v_u'}^{\\ \\top} \\bmh^{(l)}_{v_p})},\n\\end{equation}\nwhere $v_u'$ is a text-rich node as a negative sample; $\\widebar{\\bmh}_{v_u}$ is the output vector (corresponding to the \\cls token) from the PLM after encoding the text-rich node $v_u$. Note that parameters in the PLM are fixed here to make this warm-up process efficient. The PLM utilized here should be the same as that loaded for Transformer layers in \\Ours (Section \\ref{sec::plm}). \nAfter the warm-up, semantic information from the PLM will be transferred to \\tl node embeddings, which will benefit \\Ours training a lot.\nWe will demonstrate the effectiveness of this process in Section \\ref{initialization}.\n\n\n% \\vspace{-0.3cm}\n"
                    }
                },
                "subsection 3.3": {
                    "name": "Model Training",
                    "content": "\n",
                    "subsubsection 3.3.1": {
                        "name": "Training Objective",
                        "content": "\nTo train our model, we define the following likelihood objective with parameters $\\Theta$:\n\\begin{equation}\\label{likelihood}\n    \\max_{\\Theta} \\mathcal{O} = \\prod_{\\substack{v_i\\in \\mathcal{V} \\\\ \\phi(v_i)\\in\\mathcal{A}_\\text{TR}}}\\prod_{\\substack{v_j\\in N_{v_i} \\\\ \\phi(v_j)\\in\\mathcal{A}_\\text{TR}}} p(v_j|v_i;\\Theta),\n\\end{equation}\nHere, the conditional probability $p(v_j|v_i;\\Theta)$ is calculated as follows:\n\\begin{equation}\n    p(v_j|v_i;\\Theta) = \\frac{\\exp(\\bmh_{v_j}^\\top \\bmh_{v_i})}{\\sum_{v_u\\in \\mathcal{V}, \\phi(v_u)\\in\\mathcal{A}_\\text{TR}}\\exp(\\bmh_{v_u}^\\top \\bmh_{v_i})},\n\\end{equation}\nwhere $\\bmh_{v_i}=\\bmh^{(L+1)}_{v_i}$ is the output node embedding generated by \\Ours with parameters $\\Theta$; $L$ is the number of layers in \\Ours.\nHowever, calculating Eq. (\\ref{likelihood}) requires enumerating all $(v_j, v_i)$ pairs, which is costly on big graphs. To make the calculation more efficient, we leverage the negative sampling technique \\cite{mikolov2013distributed,jin2020multi} to simplify the objective and obtain our loss function below.\n\\begin{equation}\n\\label{loss}\n\\small\n    \\min_{\\Theta} \\mathcal{L}=\\sum_{\\substack{v_i\\in \\mathcal{V} \\\\ \\phi(v_i)\\in\\mathcal{A}_\\text{TR}}}\\sum_{\\substack{v_j\\in N_{v_i} \\\\ \\phi(v_j)\\in\\mathcal{A}_\\text{TR}}}-\\log\\frac{\\exp(\\bmh_{v_j}^\\top \\bmh_{v_i})}{\\exp(\\bmh_{v_j}^\\top \\bmh_{v_i})+\\sum_{v_u'}\\exp(\\bmh_{v_u'}^\\top \\bmh_{v_i})}.\n\\end{equation}\nIn the equation above, $v_u'$ stands for a random negative sample. \nIn our implementation, we use ``in-batch negative samples'' \\cite{karpukhin2020dense,yang2021graphformers} to reduce the encoding cost.\n\n"
                    },
                    "subsubsection 3.3.2": {
                        "name": "Parameter Initialization for Token Embeddings \\& Transformer Layers",
                        "content": "\\label{sec::plm}\nIt is shown in \\cite{erhan2009difficulty} that a good parameter initialization before downstream task fine-tuning is essential for deep learning models. Recently, significant improvements achieved by PLMs \\cite{devlin2018bert,liu2019roberta,clark2020electra} in various NLP tasks have also demonstrated this finding. \nIn \\Ours, a large proportion of parameters in \\Ours are token embeddings and parameters in transformer layers. Fortunately, these parameters are well pre-trained in many PLMs \\cite{devlin2018bert,liu2019roberta,yang2019xlnet,clark2020electra,brown2020language,radford2019language}. As a result, \\Ours can directly load this part of initial parameters from a PLM.\n\n\n"
                    }
                },
                "subsection 3.4": {
                    "name": "Discussions",
                    "content": "\n",
                    "subsubsection 3.4.1": {
                        "name": "Discussion on the connection between \\Ours and GNNs.",
                        "content": "\nAccording to Figure \\ref{fig::whole-structure}, \\Ours adopts a Transformer-based architecture. Meanwhile, it can also be viewed as a graph neural network (GNN) model.\nIn general, a GNN layer is consisted of neighbor propagation and aggregation to obtain node representations \\cite{kipf2017semi, hamilton2017inductive, velivckovic2017graph} as follows,\n\\begin{small}\n\\begin{gather}\n    \\bm{a}^{(l-1)}_{v_iv_j} = {\\rm PROP}^{(l)}\\left(\\bmh^{(l-1)}_{v_i},\\bmh^{(l-1)}_{v_j}\\right), \\big(\\forall v_j\\in {N}_{v_i}\\big); \\\\ \n    \\bmh^{(l)}_{v_i} = {\\rm AGG}^{(l)}\\left(\\bmh^{(l-1)}_{v_i},\\{\\bm{a}^{(l-1)}_{v_iv_j}|v_j\\in {N}_{v_i}\\}\\right).\n\\end{gather}\n\\end{small}\nAnalogously, in \\Ours, Eq. (\\ref{eq::prop}) can be treated as the propagation function ${\\rm PROP(\\cdot)}$, while the aggregation step ${\\rm AGG(\\cdot)}$ is the combination of Eqs. (\\ref{eq::mha}), (\\ref{eq::concate}) and (\\ref{eq::transformers}). Essentially, the propagation and aggregation function in \\Ours are both heterogeneity-aware mechanisms.\n\n% \\vspace{-0.2cm}\n"
                    },
                    "subsubsection 3.4.2": {
                        "name": "Discussion on Complexity",
                        "content": "\\label{sec::complexity}\n\\textbf{Time Complexity:}\nGiven a center node with $m$ text-rich neighbors (each of which has $p$ tokens) and $n$ \\tl neighbors, the time complexity of each \\Ours layer's encoding step is $\\mathcal{O}(p^2(m+1)+m+n)$, which is on par with the complexity $\\mathcal{O}(p^2(m+1))$ of per GNN-cascaded Transformers layer since $m, n\\ll p^2m$.\nAnother straightforward idea of fusing center node text information with its neighbor representations is to directly concatenate token embeddings of the center node, its text-rich neighbors, and its \\tl neighbors together and feed them into a PLM. However, in this way, the time complexity of one such layer becomes $\\mathcal{O}((p(m+1)+n)^2)$, which is significantly larger than that of our method.\n\\textbf{Memory Complexity:}\nGiven a network with $N$ \\tl nodes and $T$ parameters in the Transformer layers, the parameter complexity of \\Ours is $\\mathcal{O}(T+Nd)$, which is the same with heterogeneous GNN-cascaded Transformers \\cite{schlichtkrull2018modeling}.\n% \\clearpage\n\n"
                    }
                }
            },
            "section 4": {
                "name": "Experiment",
                "content": "\n\n",
                "subsection 4.1": {
                    "name": "Experimental Settings",
                    "content": "\n\n",
                    "subsubsection 4.1.1": {
                        "name": "Datasets",
                        "content": "\nWe conduct experiments on three datasets (\\textit{i.e.}, DBLP \\cite{tang2008arnetminer}, Twitter \\cite{zhang2016geoburst}, and Goodreads \\cite{wan2018item}) from three different domains (\\textit{i.e.}, academic papers, social media posts, and books). \nFor DBLP\\footnote{\\url{https://originalstatic.aminer.cn/misc/dblp.v12.7z}}, we extract papers published from 1990 to 2020 with their author and venue information.\nFor Twitter\\footnote{\\url{https://drive.google.com/file/d/0Byrzhr4bOatCRHdmRVZ1YVZqSzA/view?resourcekey=0-3_R5EWrLYjaVuysxPTqe5A}}, we merge the original LA and NY datasets to form a larger dataset. \nFor Goodreads\\footnote{https://sites.google.com/eng.ucsd.edu/ucsdbookgraph/home}, we remove books without any similar books, and the remaining books with their meta-data fields form the dataset.\nThe main statistics of the three datasets are summarized in Table \\ref{tab:dataset}.\n\n\n\n\n\n\n\n% \\vspace{-0.2cm}\n"
                    },
                    "subsubsection 4.1.2": {
                        "name": "Baselines",
                        "content": "\nWe compare \\Ours with two groups of baselines: \\textbf{GNN-cascaded Transformers} and \\textbf{Nested Transformers}. The former group can be further classified into \\textit{homogeneous GNN-cascaded Transformers}, including BERT+MeanSAGE \\cite{hamilton2017inductive}, BERT+Max\\\\SAGE \\cite{hamilton2017inductive} and BERT+GAT \\cite{velivckovic2017graph}, and \\textit{heterogeneous GNN-cascaded Transformers}, including BERT+RGCN \\cite{schlichtkrull2018modeling}, BERT+HAN \\cite{wang2019heterogeneous}, BERT+\\\\HGT \\cite{hu2020heterogeneous} and BERT+SHGN \\cite{lv2021we}. \nThe latter group includes the recent GraphFormers \\cite{yang2021graphformers} model. However, GraphFormers can only deal with homogeneous textual networks. To apply it to heterogeneous text-rich networks, we add heterogeneous graph propagation and aggregation in its final layer. This generalized model is named GraphFormers++.\nTo verify the importance of both text and network information in text-rich networks, we also include vanilla GraphSAGE \\cite{hamilton2017inductive} and vanilla BERT \\cite{devlin2018bert} in comparison.\nDetailed information about the baselines can be found in Appendix \\ref{apx:sec:baselines}.\n\n\n% \\vspace{-0.2cm}\n"
                    },
                    "subsubsection 4.1.3": {
                        "name": "Reproducibility.",
                        "content": "\nFor all compared models (baselines and \\Ours), we adopt the same training objective and the 12-layer BERT-base-uncased \\cite{devlin2018bert} as the backbone PLM for a fair comparison. The Adam optimizer \\cite{kingma2014adam} with a learning rate 1e-5 and in-batch negative samples with training batch size 30 are used to fine-tune the model. In-batch testing is used for efficiency and the test batch size is 100, 300, and 100 for DBLP, Twitter, and Goodreads, respectively. The maximum length of the PLM is set to be 32, 12, and 64 on the three datasets according to their average document length. For heterogeneous GNN approaches, the embedding size of \\tl nodes is 64.\nWe run experiments on one NVIDIA RTX A6000 GPU.\n\nFollowing previous studies on network representation learning, we consider three fundamental tasks for quantitative evaluation: link prediction, node classification, and node clustering.\n\n% \\vspace{-0.3cm}\n"
                    }
                },
                "subsection 4.2": {
                    "name": "Link Prediction",
                    "content": "\\label{sec::link-prediction}\n\\noindent\\textbf{Settings.}\nLink prediction aims to predict missing edges in a network. In order to evaluate the models' ability to encode both text semantics and network structure, we focus on link prediction between two text-rich nodes. Specifically, on DBLP, Twitter, and Goodreads, the prediction is between paper-paper, tweet-POI, and book-book, respectively. The model is trained and tested with in-batch negative sampling and we adopt a 7:1:2 train-dev-test split. Precision@1 (PREC), Mean Reciprocal Rank (MRR), and Normalized Discounted Cumulative Gain (NDCG) are used as evaluation metrics. Given a query node $u$, PREC measures whether the key node $v$ linked with $u$ is ranked the highest in the batch; MRR calculates the average of the reciprocal ranks of $v$; NDCG further takes the order and relative importance of $v$ into account and here we calculate on the full candidate list, the length of which equals to test batch size.\n\n\\vspace{3px}\n\\noindent\\textbf{Results.}\nTable \\ref{tab:link-prediction} shows the performance of all compared methods. \nFrom Table \\ref{tab:link-prediction}, we can observe that: (a) \\Ours outperforms all the baseline methods consistently; (b) Transformer+GNN models perform better than both vanilla GNN and vanilla BERT, which demonstrates the importance of encoding both text and network signals in text-rich networks; (c) Network-empowered Transformers including \\Ours, GraphFormers, and GraphFormers++ are more powerful than GNN-cascaded Transformers; (d) By considering network heterogeneity, \\Ours can have better performance than GraphFormers in heterogeneous text-rich networks.\n(e) \\Ours yields a larger performance improvement when the network is more dense and heterogeneous (\\textit{i.e.}, DBLP, Goodreads vs. Twitter).\n\n\n% \\vspace{-0.3cm}\n"
                },
                "subsection 4.3": {
                    "name": "Node Classification",
                    "content": "\\label{sec::classification}\n\\noindent\\textbf{Settings.}\nIn node classification, we train a 2-layer MLP classifier to classify nodes with the generated node embeddings from each model as input. \nThe node embeddings are fixed in order to test their representation quality. \nThe experiments are conducted on DBLP and Goodreads (because node labels are available in these two datasets) for both \\underline{\\textbf{text-rich}} and \\underline{\\textbf{\\tl}} nodes. \nFor \\underline{\\textbf{text-rich}} node classification, we focus on paper nodes and book nodes in DBLP and Goodreads, respectively. We select the most frequent 30 classes in DBLP and keep the original 10 classes in Goodreads. Also, we study both \\underline{\\textit{transductive}} and \\underline{\\textit{inductive}} node classification to understand the capability of our model comprehensively. For \\underline{\\textit{transductive}} node classification, the model has seen the classified nodes during representation learning (using the link prediction objective), while for \\underline{\\textit{inductive}} node classification, the model needs to predict the label of nodes not seen before. \nFor \\underline{\\textbf{\\tl}} node classification, we focus on author nodes in both DBLP and Goodreads. The label of each author is obtained by aggregating the labels of his/her publications. We separate the whole dataset into train set, validation set, and test set in 7:1:2 in all cases and each experiment is repeated 5 times in this section with the average performance reported.\nFurther information can be found in Appendix \\ref{apx:classification}.\n\n\\vspace{3px}\n\\noindent\\textbf{Results.}\nTables \\ref{fig::transductive_text_classification} and \\ref{fig::inductive_text_classification} demonstrate the results of different methods in \\underline{\\textit{transductive}} and \\underline{\\textit{inductive}} \\underline{\\textbf{text-rich}} node classification. We observe that: (a) our \\Ours outperforms all the baseline methods significantly on both tasks, showing that \\Ours can learn more effective node representations for these tasks; (b) Heterogeneous network-based Transformer methods generally achieve better results than homogeneous network-based Transformer methods, which demonstrates the necessity of encoding heterogeneity in heterogeneous text-rich networks; (c) \\Ours generalizes quite well on unseen nodes as its performance on inductive node classification is quite close to that on transductive node classification. Moreover, \\Ours even achieves higher performance in inductive settings than the baselines do in transductive settings.\nTable \\ref{fig::textless_classification} reports the result on \\underline{\\textbf{\\tl}} node classification, where we have the following findings: (a) \\Ours outperforms all heterogeneous network-based Transformer methods significantly. (b) Compared with text-rich node classification, the improvement of \\Ours on \\tl node classification over baselines is more significant, indicating that \\Ours better captures neighbors' text semantics in \\tl node representations.\n\n\n\n\n\n\n\n\n\n\n"
                },
                "subsection 4.4": {
                    "name": "Node Clustering",
                    "content": "\n\\noindent\\textbf{Settings.}\nFor node clustering, we utilize KMeans \\cite{kanungo2002efficient} to cluster the nodes based on their representations generated by the models. The data and categories used in Section \\ref{sec::classification} for text-rich node classification are used here again, but nodes with more than one ground-truth label are filtered. The number of clusters $K$ is set as the number of categories. For DBLP, since the dataset is quite large, we pick the 10 most frequent categories and randomly select 20,000 nodes for efficient evaluation. NMI and ARI \\cite{hubert1985comparing} are used as evaluation metrics. Since the performance of KMeans can be affected by the initial centroids, we run each experiment 10 times and report the average performance. In addition to quantitative evaluation, we conduct visualization to depict the distribution of \\Ours embeddings, where t-SNE \\cite{van2008visualizing} is utilized to project node embeddings into a 2-dimensional space and the nodes are colored based on their ground-truth label.\nFurther information can be found in Appendix \\ref{apx:clustering} and \\ref{apx:visualization}.\n\n\\vspace{3px}\n\\noindent\\textbf{Results.}\nThe quantitative result can be found in Table \\ref{fig::node_clustering}, where \\Ours is the best on DBLP and outperforms most baselines on Goodreads. \nThe embedding visualization of \\Ours is presented in Figure \\ref{fig::visualization}. \nIn both datasets, the clustering structure is quite evident, indicating that node representations learned by \\Ours are category-discriminative, even though the training process is based on link prediction only.\n\n% \\vspace{-0.4cm}\n\n\n% \\vspace{-0.4cm}\n% visualization\n\n\n\n% \\vspace{-0.2cm}\n"
                },
                "subsection 4.5": {
                    "name": "Ablation and Parameter Studies",
                    "content": "\n",
                    "subsubsection 4.5.1": {
                        "name": "Ablation Study on Virtual Neighbor Tokens",
                        "content": "\n\\label{sec:abl-agg}\nIn Section \\ref{sec::main-model}, signals from both text-rich and \\tl neighbors are incorporated and finally contribute to center node encoding serving as two virtual neighbor tokens. \nTo study the effectiveness of information from both text-rich and \\tl neighbors, we conduct a model study of several \\Ours variants: (a) \\textbf{No-VNT} adds no \\textbf{V}irtual \\textbf{N}eighbor \\textbf{T}okens and only encodes textual information for each node; \n(b) \\textbf{No-TR} (\\textbf{T}ext-\\textbf{R}ich) only adds one virtual neighbor token corresponding to \\tl neighbors in Eq. (\\ref{eq::concate}); \n(c) \\textbf{No-TL} (\\textbf{T}ext\\textbf{L}ess) only adds one virtual neighbor token corresponding to text-rich neighbors in Eq. (\\ref{eq::concate}); \n(d) \\textbf{\\Ours} is our full model. The results of link prediction for these variants are shown in Figure \\ref{fig::ablation}. \nWe can find that: (a) \\Ours outperforms all model variants, which demonstrates that signals from both text-rich and \\tl neighbors are essential for center node encoding; (b) No-TL performs better than No-TR, implying that text-rich neighbors are more important than \\tl neighbors since they contain rich text semantics.\n\n% ablation figure\n\n\n\n"
                    },
                    "subsubsection 4.5.2": {
                        "name": "Ablation Study on Type Heterogeneous Projection Matrices",
                        "content": "\nIn Eq. (\\ref{eq::prop}) and Eq. (\\ref{eq::node-proj}), we propose to utilize different projection matrices (so-called heterogeneous projection, \\textit{hp} for short) for different types of nodes and edges. In this section, we conduct an ablation study to verify the effectiveness of this design. \nThe model with the same projection matrices for different types of nodes and edges is denoted as \\textbf{\\Ours w/o hp}, while our full model is denoted as \\textbf{\\Ours}. The results are shown in Table \\ref{tab::hp}. From the result, \\Ours consistently outperforms \\Ours w/o hp on both DBLP and Goodreads, which demonstrates the importance of this design and the necessity of modeling node/edge type heterogeneity.\n\n\n% \\vspace{-0.2cm}\n\n% \\vspace{-0.4cm}\n\n\n% \\vspace{-0.2cm}\n"
                    },
                    "subsubsection 4.5.3": {
                        "name": "Dimension of \\Tl Node Embedding",
                        "content": "\nTo understand the effect of \\tl node embedding dimension, we test the performance of \\Ours in link prediction with the embedding dimension varying in 4, 8, 16, 32, and 64. The result is shown in Figure \\ref{fig::hyper}. It can be seen that the performance of \\Ours generally increases as the embedding dimension becomes larger. This is intuitive since the more parameters $z_u$ has (before overfitting), the more information it can represent.\n\n\n% hyperparameter figure\n\n\n\n% \\vspace{-0.2cm}\n% \\subsubsection{Parameter Initialization}\\label{initialization}\n"
                    }
                },
                "subsection 4.6": {
                    "name": "\\Tl Node Embedding Warm-Up",
                    "content": "\\label{initialization}\n\n",
                    "subsubsection 4.6.1": {
                        "name": "Training Curve Study",
                        "content": "\n% initialization figure\n\n\nIn Section \\ref{sec::pretrain}, we propose a method to warm up \\tl node embeddings. Now, we empirically demonstrate the effectiveness of such a warm-up process.\nThe training processes (Section \\ref{sec::link-prediction}) of \\Ours without \\tl node warm-up (\\textbf{w/o \\tl.warm-up}) and the full \\Ours model are shown in Figure \\ref{fig::initialization}. We also show \\Ours without the utilization of \\tl node neighbor information (\\textbf{w/o \\tl}) as reference. The $x$-axis denotes the number of training epochs, while the $y$-axis represents PREC on the validation set. Training is terminated if PREC on the validation set does not increase for three consecutive epochs.\nIt is shown that: (a) On both datasets, \\Ours with \\tl node embedding warm-up can have better performance than that without \\tl node warm-up; (b) On DBLP, \\Ours without \\tl node embedding warm-up cannot even outperform \\Ours without the utilization of \\tl neighbor information. \nThis finding implies the necessity of good initialization for \\tl node embeddings. Since modeling \\tl nodes can improve the representation capacity (see Section \\ref{sec:abl-agg}) in text-rich networks, our warm-up strategy is, therefore, verified to be effective towards model convergence.\n\n\n"
                    },
                    "subsubsection 4.6.2": {
                        "name": "Attention Map Study",
                        "content": "\n% initialization figure\n\n\nIn order to understand how the warm-up step proposed in Section \\ref{sec::pretrain} benefits \\Ours training, we further conduct a self-attention probability map study for a random sample from DBLP in Figure \\ref{fig::att-map}. We random pick up a token from this sample and plot the self-attention probability of how different tokens (x-axis), including virtual neighbor tokens ([tk\\_tr] and [tk\\_tl] are the text-rich and the \\tl neighbor virtual tokens respectively) and the first eight original text tokens ([tk\\_x], x$\\in\\{1..8\\}$), will contribute to the encoding of this random token in different layers (y-axis).\nFrom the figure, we can find that the virtual neighbor tokens (first two columns from left) are more deactivated for the model without warm-up, which means that the information from neighbors is not well utilized during encoding. However, the neighbor virtual tokens (first two columns from left) become more activated after warm-up, bringing more useful information from neighbors to enhance center node text encoding.\n\n\n"
                    }
                },
                "subsection 4.7": {
                    "name": "Scalability Study",
                    "content": "\nWe conduct theoretical analysis on time complexity and memory complexity for \\Ours in Section \\ref{sec::complexity}.\nIn this section, we perform an empirical time and memory efficiency comparison among BERT+MeanSAGE, GraphFormers, and \\Ours. The evaluation is performed on one NVIDIA RTX A6000 GPU. The result is shown in Table \\ref{apx:complexity}. For time complexity, we run each model for one mini-batch (each mini-batch contains 30 samples) and report the average running time. For memory complexity, we report the GPU memory needed to train the corresponding models.\nFrom the results, we can find that the time and memory cost of training \\Ours is quite close to that of BERT+MeanSAGE and GraphFormers.\n\n% \\vspace{-0.8cm}\n\n% \\vspace{-0.4cm}\n% \\clearpage\n"
                }
            },
            "section 5": {
                "name": "Related Work",
                "content": "\n\n% \\vspace{-0.2cm}\n",
                "subsection 5.1": {
                    "name": "Pretrained Language Models",
                    "content": "\nPretrained language models (PLMs) aim to learn general language representations from large-scale corpora, which can be generalized to various downstream tasks. Early studies on PLMs mainly focus on context-free text embeddings such as word2vec \\cite{mikolov2013distributed} and GloVe \\cite{pennington2014glove}. Recently, motivated by the fact that the same word can have different meanings conditioned on different contexts, deep language models such as ELMo \\cite{peters2018deep}, BERT \\cite{devlin2018bert}, RoBERTa \\cite{liu2019roberta}, XLNet \\cite{yang2019xlnet}, ELECTRA \\cite{clark2020electra}, and GPT \\cite{radford2019language,brown2020language} are proposed to capture the contextualized token representations. These models employ the Transformer architecture \\cite{vaswani2017attention} to capture long-range and high-order semantic dependency and achieve significant improvement on many downstream NLP tasks \\cite{meng2022topic, xun2020correlation, liu2019fine}. However, these models mainly focus on text encoding. In contrast, \\Ours leverages both text and heterogeneous structure (network) information when the latter is available.\n\n\n"
                },
                "subsection 5.2": {
                    "name": "Heterogeneous Graph Neural Networks",
                    "content": "\n\\vspace{-0.1cm}\nGraph neural networks (GNNs) such as GCN \\cite{kipf2017semi}, GraphSAGE \\cite{hamilton2017inductive}, and GAT \\cite{velivckovic2017graph} have been widely adopted in representation learning on graphs. Since real-world objects and interactions are often multi-typed, recent studies have considered extending GNNs to heterogeneous graphs \\cite{sun2012mining}. The basic idea of heterogeneous graph neural networks (HGNNs) \\cite{schlichtkrull2018modeling, wang2019heterogeneous, zhang2019heterogeneous, cen2019representation, yun2019graph, hu2020heterogeneous} is to leverage node types, edge types, and meta-path semantics \\cite{sun2011pathsim} in projection and aggregation. For example, HAN \\cite{wang2019heterogeneous} proposes a hierarchical attention mechanism to capture both node and meta-path importance; \nHGT \\cite{hu2020heterogeneous} proposes an architecture similar to Transformer \\cite{vaswani2017attention} to carry out attention on edge types. \nFor more HGNN models, one can refer to recent surveys \\cite{dong2020heterogeneous,yang2020heterogeneous}. Lv et al. \\cite{lv2021we} further perform a benchmark study of 12 HGNNs and propose a simple HGNN model based on GAT. Despite the success of these models, when some types of nodes carry text information, they lack the power of handling textual signals in a contextualized way. In contrast, \\Ours jointly models text semantics and heterogeneous structure (network) signal in each Transformer layer.\n\n% \\vspace{-0.6cm}\n"
                },
                "subsection 5.3": {
                    "name": "Text-Rich Networks",
                    "content": "\n\\vspace{-0.1cm}\nMost previous studies on \\textit{homogeneous} text-rich networks adopt a ``cascaded architecture'' \\cite{zhu2021textgnn,li2021adsgnn,liu2020fine,jin2021bite,zhou2019gear}.\nOne drawback of such models is that text and network signals are processed consecutively, so the network information cannot benefit text encoding. \nTo overcome this drawback, GraphFormers \\cite{yang2021graphformers} introduce nested Transformers so that text and node features can be encoded jointly. \nEdgeformers \\cite{jinedgeformers} introduce graph-empowered Transformers for representation learning on textual-edge networks.\nHowever, they assume that the network is homogeneous and all nodes have text information. These assumptions do not usually hold in real-world text-rich networks. Most previous studies on \\textit{heterogeneous} text-rich networks focus on specific text-related tasks. For example, HyperMine \\cite{shi2019discovering} and NetTaxo \\cite{shang2020nettaxo} study how network structures can benefit taxonomy construction from text corpora; LTRN \\cite{zhang2021minimally} and MATCH \\cite{zhang2021match} leverage document metadata as complementary signals for text classification. In comparison, \\Ours focuses on the generic representation learning task.\n% problem that can advance various text and graph related tasks such as classification, clustering, and link prediction. \nAs far as we know, SHNE \\cite{zhang2019shne} is the major previous work also studying representation learning on heterogeneous text-rich networks. However, it still adopts the ``cascaded architecture'' mentioned above and does not explore the power of Transformer encoders (as it was proposed before BERT \\cite{devlin2018bert}). In comparison, \\Ours proposes a heterogeneous network-empowered Transformer which can jointly capture textual signals and structure signals.\n\n"
                }
            },
            "section 6": {
                "name": "Conclusions",
                "content": "\\label{sec::conclusion}\n\\vspace{-0.1cm}\nIn this paper, we introduce the problem of node representation learning on heterogeneous text-rich networks and propose \\Ours, a heterogeneous network-empowered Transformer architecture to address the problem. \n\\Ours can jointly capture the heterogeneous structure (network) information and the rich contextualized textual information hidden inside the networks.\nExperimental results on various graph mining tasks, including link prediction, node classification, and node clustering, demonstrate the superiority of \\Ours. \nMoreover, the proposed framework can serve as a building block with different task-specific inductive biases. It would be interesting to see its future applications on real-world text-rich networks such as recommendation, abuse detection, tweet-based network analysis, and text-rich social network analysis.\n\n\\begin{acks}\nThis work was supported in part by US DARPA KAIROS Program No. FA8750-19-2-1004 and INCAS Program No. HR001121C0165, National Science Foundation IIS-19-56151, IIS-17-41317, and IIS 17-04532, and the Molecule Maker Lab Institute: An AI Research Institutes program supported by NSF under Award No. 2019897, and the Institute for Geospatial Understanding through an Integrative Discovery Environment (I-GUIDE) by NSF under Award No. 2118329. Any opinions, findings, and conclusions or recommendations expressed herein are those of the authors and do not necessarily represent the views, either expressed or implied, of DARPA or the U.S. Government.\n\\end{acks}\n\n\\bibliographystyle{ACM-Reference-Format}\n% \\setstretch{1.00}\n% \\balance\n\\bibliography{bib_full_name}\n\n\\newpage\n\\appendix\n\\clearpage\n"
            },
            "section 7": {
                "name": "Supplementary Material",
                "content": "\n\n",
                "subsection 7.1": {
                    "name": "Summary of \\Ours's Encoding Procedure",
                    "content": "\\label{apx::sec::alg}\n\n\\RestyleAlgo{ruled}\n\\SetKwComment{Comment}{/* }{ */}\n\\begin{algorithm}\n% \\small\n\\setstretch{0.6}\n\\SetKwInOut{Input}{Input}\\SetKwInOut{Output}{Output}\n\\caption{Encoding Procedure of \\Ours}\\label{apx:alg}\n\\Input{The center node $v_i$, its text-rich neighbors $\\widehat{N}_{v_i}$ and \\tl neighbors $\\widecheck{N}_{v_i}$. Initial token sequence embedding ${\\bmH}^{(0)}_{v_j}$ for $v_j\\in \\widehat{N}_{v_i}\\cup \\{v_i\\}$.}\n\\Output{The embedding $\\bmh_{v_i}$ for the center node $v_i$.}\n\\Begin{\n    \\tcp{\\textcolor{myblue}{obtain text-rich nodes' first layer encoded token embeddings}}\n    \\For{$v_j\\in\\widehat{N}_{v_i}\\cup\\{v_i\\}$}{\n        ${\\bmH}^{(0)'}_{v_j} \\gets {\\rm Normalize}(\\bmH^{(0)}_{v_j} + {\\rm MHA}^{(0)}(\\bmH^{(0)}_{v_j}))$ \\;\n        $\\bmH^{(1)}_{v_j} \\gets {\\rm Normalize}({\\bmH}^{(0)'}_{v_j} + {\\rm MLP}^{(0)}({\\bmH}^{(0)'}_{v_j}))$ \\;\n        }\n        \n    \\tcp{\\textcolor{myblue}{obtain \\tl nodes' initial embedding after warm-up}}\n    \\For{$v_s\\in\\widecheck{N}_{v_i}$}{\n        $\\bmh^{(0)}_{v_s} \\gets {\\rm Warm Up}(v_s)$ \\;\n        }\n    \\For{$l=1,...,L$}{\n        \\tcp{\\textcolor{myblue}{text-rich neighbor aggregation}} \n        \\For{$v_j\\in\\widehat{N}_{v_i}\\cup\\{v_i\\}$}{\n        ${\\bm h}^{(l)}_{v_j} \\gets \\bmH^{(l)}_{v_j}\\cls$ \\;\n        }\n        $\\widehat{\\bmz}^{(l)}_{v_i} \\gets {\\rm AGG}(\\{{\\bm h}^{(l)}_{v_j}|v_j\\in \\widehat{N}_{v_i}\\cup\\{v_i\\}\\})$ \\;\n        \n        \\tcp{\\textcolor{myblue}{\\tl neighbor aggregation}}\n        \\For{$v_s\\in\\widecheck{N}_{v_i}$}{\n            ${\\bm h}^{(l)}_{v_s} \\gets \\bmW^{(l)}_{\\phi_i} \\bmh^{(0)}_{v_s}, \\ \\text{where}\\  \\phi(v_s)=\\phi_i$ \\;\n            }\n        $\\widecheck{\\bm z}^{(l)}_{v_i} \\gets {\\rm AGG}(\\{{\\bm h}^{(l)}_{v_s}|v_s\\in \\widecheck{N}_{v_i}\\cup\\{v_i\\}\\})$ \\;\n        \n        \\tcp{\\textcolor{myblue}{obtain the center node's token embedding for next layer}}\n        $\\widetilde{\\bmH}^{(l)}_{v_i} \\gets \\widehat{\\bmz}^{(l)}_{v_i} \\mathop{\\Vert} \\bmH^{(l)}_{v_i} \\mathop{\\Vert} \\widecheck{\\bmz}^{(l)}_{v_i}$ \\;\n        $\\widetilde{\\bmH}^{(l)'}_{v_i} \\gets {\\rm Normalize}(\\bmH^{(l)}_{v_i} + {\\rm MHA}^{(l)}(\\bmH^{(l)}_{v_{i}},\\widetilde{\\bmH}^{(l)}_{v_{i}}))$ \\;\n        $\\bmH^{(l+1)}_{v_i} \\gets {\\rm Normalize}(\\widetilde{\\bmH}^{(l)'}_{v_i} + {\\rm MLP}^{(l)}(\\widetilde{\\bmH}^{(l)'}_{v_i}))$ \\;\n        \n        \\tcp{\\textcolor{myblue}{update text-rich neighbors' token embeddings}}\n        \\For{$v_j\\in\\widehat{N}_{v_i}$}{\n            ${\\bmH}^{(l)'}_{v_j} \\gets {\\rm Normalize}(\\bmH^{(l)}_{v_j} + {\\rm MHA}^{(l)}(\\bmH^{(l)}_{v_j}))$ \\;\n            $\\bmH^{(l+1)}_{v_j} \\gets {\\rm Normalize}({\\bmH}^{(l)'}_{v_j} + {\\rm MLP}^{(l)}({\\bmH}^{(l)'}_{v_j}))$ \\;\n            }\n        }\n    \\KwRet{$\\bmh_{v_i} \\gets \\bmH^{(L+1)}_{v_i}\\cls$} \\;\n}\n\\end{algorithm}\n\n\n"
                },
                "subsection 7.2": {
                    "name": "Details of Baselines",
                    "content": "\\label{apx:sec:baselines}\nWe have 11 baselines including vanilla text/graph encoding models, GNN-cascaded Transformers, and nested Transformers.\n\n\\vspace{3px}\n\\noindent\\textbf{Vanilla text/graph models:}\n\\begin{itemize}[leftmargin=*,partopsep=0pt,topsep=0pt]\n    \\setlength{\\itemsep}{0pt}\n    \\setlength{\\parsep}{0pt}\n    \\setlength{\\parskip}{0pt}\n    \\item \\textbf{MeanSAGE} \\cite{hamilton2017inductive}: This is a GNN method utilizing the mean function to aggregate information from neighbors for center node representation learning. \n    The initial node feature vector is bag-of-words weighted by TF-IDF. \n    The number of entries in each attribute vector is the vocabulary size of the corresponding dataset, where we keep the most representative 10000, 2000, and 5000 words for DBLP, Twitter, and Goodreads, respectively, according to the corpora size.\n    \\item \\textbf{BERT} \\cite{devlin2018bert}: This is a benchmark PLM pretrained on two tasks: next sentence prediction and mask token prediction. For each text-rich node, we use BERT to encode its text and take the output hidden state of the \\cls token as the node representation.\n\\end{itemize}\n\n\\vspace{3px}\n\\noindent\\textbf{Homogeneous GNN-cascaded Transformers:}\n\\begin{itemize}[leftmargin=*,partopsep=0pt,topsep=0pt]\n    \\setlength{\\itemsep}{0pt}\n    \\setlength{\\parsep}{0pt}\n    \\setlength{\\parskip}{0pt}\n    \\item \\textbf{BERT+MeanSAGE} \\cite{hamilton2017inductive}: We stack BERT with MeanSAGE (\\textit{i.e.}, using the output text representation of BERT as the input node attribute vector of MeanSAGE). The BERT+MeanSAGE model is trained in an end-to-end way. (Both parameters in BERT and GNN are finetuned.) Other BERT+GNN baselines below have the same cascaded architecture.\n    \n    \\item \\textbf{BERT+MaxSAGE} \\cite{hamilton2017inductive}: MaxSAGE is a GNN method utilizing the max function for neighbor aggregation to generate center node representation.\n    \n    \\item \\textbf{BERT+GAT} \\cite{velivckovic2017graph}: GAT is a GNN method with an attention-based neighbor importance calculation, and the importance scores are utilized as weights to aggregate neighbors.\n\\end{itemize}\n\n\\vspace{3px}\n\\noindent\\textbf{Homogeneous Nested Transformers:}\n\\begin{itemize}[leftmargin=*,partopsep=0pt,topsep=0pt]\n    \\setlength{\\itemsep}{0pt}\n    \\setlength{\\parsep}{0pt}\n    \\setlength{\\parskip}{0pt}\n    \\item \\textbf{GraphFormers} \\cite{yang2021graphformers}: This is the state-of-the-art nested Transformer model, which has graph-based propagation and aggregation in each Transformer layer. \n\\end{itemize}\nSince homogeneous baselines assume all nodes are associated with text information, when applying them to our datasets, we remove all \\tl nodes. Therefore, homogeneous baselines cannot be used for \\tl node classification (\\textit{i.e.}, Table \\ref{fig::textless_classification}).\n\n\\vspace{3px}\n\\noindent\\textbf{Heterogeneous GNN-cascaded Transformers:}\n\\begin{itemize}[leftmargin=*,partopsep=0pt,topsep=0pt]\n    \\setlength{\\itemsep}{0pt}\n    \\setlength{\\parsep}{0pt}\n    \\setlength{\\parskip}{0pt}\n    \\item \\textbf{BERT+RGCN} \\cite{schlichtkrull2018modeling}: RGCN is a heterogeneous GNN model. It projects neighbor representations into the same latent space according to the edge types. The initial embeddings for \\tl nodes are learnable vectors for baselines in this section which is the same to \\Ours.\n    \n    \\item \\textbf{BERT+HAN} \\cite{wang2019heterogeneous}: HAN is a heterogeneous GNN model. \n    It proposes a heterogeneous attention-based method to aggregate neighbor information.\n    \n    \\item \\textbf{BERT+HGT} \\cite{hu2020heterogeneous}: HGT is a heterogeneous GNN model. Inspired by the Transformer architecture, it utilizes multi-head attention to aggregate neighbor information obtained by heterogeneous message passing.\n    \n    \\item \\textbf{BERT+SHGN} \\cite{lv2021we}: SHGN is a heterogeneous GNN model. Motivated by the observation that GAT is more powerful than many heterogeneous GNNs \\cite{lv2021we}, it adopts GAT as the backbone with enhancements from learnable edge-type embeddings, residual connections, and normalization on the output embeddings.\n    \n\\end{itemize}\n\n\\vspace{3px}\n\\noindent\\textbf{Heterogeneous Nested Transformers:}\n\\begin{itemize}[leftmargin=*,partopsep=0pt,topsep=0pt]\n    \\setlength{\\itemsep}{0pt}\n    \\setlength{\\parsep}{0pt}\n    \\setlength{\\parskip}{0pt}\n    \\item \\textbf{GraphFormers++} \\cite{yang2021graphformers}: To apply GraphFormers to heterogeneous text-rich networks, we add heterogeneous graph propagation and aggregation in its final layer. The generalized model is named GraphFormers++.\n\\end{itemize}\n\n\n"
                },
                "subsection 7.3": {
                    "name": "Dataset Description",
                    "content": "\\label{apx:dataset}\n\n",
                    "subsubsection 7.3.1": {
                        "name": "Training",
                        "content": "\\label{apx:training}\nWe train our model in an unsupervised way via link prediction. For each paper in DBLP, we select one neighbor paper for it and construct a positive node pair. For each POI in Twitter, we select one neighbor tweet for it to make up a positive node pair. For each book in Goodreads, one neighbor book is selected to build a positive node pair. All these node pairs are used as positive training samples. The model is then trained via in-batch negative sampling. \n\n"
                    },
                    "subsubsection 7.3.2": {
                        "name": "Link Prediction",
                        "content": "\nThe training, validation, and testing sets in this section are the same as those in Section \\ref{apx:training}. \n\n\n"
                    },
                    "subsubsection 7.3.3": {
                        "name": "Node classification",
                        "content": "\\label{apx:classification}\n\nThe 30 categories for DBLP papers are: ``Artificial intelligence'', ``Mathematics'', ``Machine learning'', ``Computer vision'', ``Computer network'', ``Mathematical optimization'', ``Pattern recognition'', ``Distributed computing'', ``Data mining'', ``Real-time computing'', ``Algorithm'', ``Control theory'', ``Discrete mathematics'', ``Engineering'', ``Electronic engineering'', ``Theoretical computer science'', ``Combinatorics'', ``Knowledge management'', ``Multimedia'', ``Computer security'', ``World Wide Web'', ``Human-computer interaction'', ``Control engineering'', ``Parallel computing'', ``Information retrieval'', ``Software'', ``Artificial neural network'', ``Communication channel'', ``Simulation'', and ``Natural language processing''. \n\nThe 10 categories for Goodreads books are: ``children'', ``fiction'', ``poetry'', ``young-adult'', ``history, historical fiction, biography'', ``fantasy, paranormal'', ``non-fiction'', ``mystery, thriller, crime'', ``comics, graphic'', and ``romance''.\n\n\n"
                    },
                    "subsubsection 7.3.4": {
                        "name": "Node Clustering",
                        "content": "\\label{apx:clustering}\nFor DBLP, since the dataset is quite large, we pick the most frequent 10 categories and randomly select 20,000 nodes for efficient evaluation. The 10 selected categories are: ``Artificial intelligence'', ``Mathematics'', ``Machine learning'', ``Computer vision'', ``Computer network'', ``Mathematical optimization'', ``Pattern recognition'', ``Distributed computing'', ``Data mining'', and ``Real-time computing''.\nFor Goodreads, we use all 10 categories in the original dataset for clustering.\n\n\n"
                    },
                    "subsubsection 7.3.5": {
                        "name": "Embedding Visualization",
                        "content": "\\label{apx:visualization}\nIn this section, we use t-SNE \\cite{van2008visualizing} to project node embeddings into low-dimensional spaces. Nodes are colored based on their ground-truth labels. To make the visualization clearer, we select 4 naturally separated categories for DBLP and 5 for Goodreads. The 4 selected categories for DBLP are ``Mathematics'', ``Computer networks'', ``Information retrieval'', and ``Electronic engineering''. The 5 selected categories for Goodreads are ``fiction'', ``romance'', ``mystery, thriller, crime'', ``non-fiction'', and ``children''. \n\n\n"
                    }
                },
                "subsection 7.4": {
                    "name": "Reproducibility Settings",
                    "content": "\\label{apx:rep}\n\n",
                    "subsubsection 7.4.1": {
                        "name": "Hyper-parameters",
                        "content": "\nFor a fair comparison, the training objective for all compared methods including \\Ours and baselines are the same. The hyper-parameter configuration for the node representation learning process can be found in Table \\ref{apx:hyper}, where ``neighbor sampling'' means the number of each type of neighbor sampled for the center node during learning.\n\nIn Section \\ref{sec::classification}, we adopt a multi-layer perceptron (MLP) with 3 layers and hidden dimension 200 to be our classifier. We employ Adam optimizer \\cite{kingma2014adam} and early stop 10 to train the classifier. For text-rich node classification, the learning rate is set as 0.001. While for \\tl node classification, the learning rate is 0.01. \n\n\n\n\n\n"
                    }
                },
                "subsection 7.5": {
                    "name": "Case Study: Paper Retrieval",
                    "content": "\nTo further demonstrate the capability of \\Ours in encoding text semantics, we present a case study of query-based paper retrieval on DBLP. \n\n\n\n\n\\noindent\\textbf{Settings.}\nThe models are asked to retrieve relevant papers for a user-given query based on the inner product of the encoded query embedding and the paper embedding, where the query embedding is obtained by encoding query text only with each model.\n\n\\vspace{3px}\n\\noindent\\textbf{Results.}\n% % analysis for 'news recommendation with personalization'\nTable \\ref{tab::retrieve} lists the top-7 papers for the query ``\\textit{news recommendation with personalization}'' retrieved by BERT, GraphFormers, and \\Ours. \nIt is shown that our model can have more accurate retrieved results than both baselines. \nIn fact, according to network homophily \\cite{mcpherson2001birds}, papers on the same topics (\\textit{e.g.}, \\textit{personalization/news recommendation}) are likely to have connections (\\textit{i.e.}, become text-rich neighbors) or share similar meta-data (\\textit{i.e.}, share similar \\tl neighbors). \nWhile BERT can consider text information only and GraphFormers enriches text information with text-rich neighbors only, our \\Ours is capable of utilizing both text-rich neighbors and \\tl neighbors to complement text signals via network-empowered Transformer encoding (Section \\ref{sec::text-rich-encoder}), which finally contributes to higher retrieval accuracy.\n\n"
                }
            }
        },
        "tables": {
            "tab:dataset": "\\begin{table}[ht]\n\\caption{Dataset statistics. *: text-rich node types.}\n\\vspace{-0.2cm}\n\\scalebox{0.85}{\n\\begin{tabular}{c|l|l}\n\\toprule\nDataset & \\multicolumn{1}{c|}{Node} & \\multicolumn{1}{c}{Edge} \\\\\n\\midrule\n\\multirow{3}{*}{DBLP} & \\# paper*: 3,597,191 & \\# paper-paper: 36,787,329 \\\\\n & \\# venue: 28,638 & \\# venue-paper: 3,633,613 \\\\\n & \\# author: 2,717,797 & \\# author-paper: 10,212,497 \\\\\n\\midrule\n\\multirow{5}{*}{Twitter} & \\# tweet*: 279,694 & \\multirow{5}{*}{\\begin{tabular}[l]{@{}l@{}} \\# tweet-POI: 279,694 \\\\ \\# user-tweet: 195,785 \\\\ \\# hashtag-tweet: 194,939 \\\\ \\# mention-tweet: 50,901 \\end{tabular}} \\\\\n & \\# POI*: 36,895 & \\\\\n & \\# hashtag: 72,297 & \\\\\n & \\# user: 76,398 & \\\\\n & \\# mention: 24,089 & \\\\\n \\midrule\n\\multirow{6}{*}{Goodreads} & \\# book*:1,097,438 & \\# book-book: 11,745,415\\\\\n & \\# shelves: 6,632 & \\# shelves-book: 27,599,160 \\\\\n & \\# author: 205,891 & \\# author-book: 1,089,145\\\\\n & \\# format: 768  & \\# format-book:  588,677\\\\\n & \\# publisher: 62,934 & \\# publisher-book: 591,456\\\\\n & \\# language code: 139 & \\# language code-book: 485,733\\\\\n\\bottomrule            \n\\end{tabular}\n\\vspace{-0.2cm}\n}\n\\label{tab:dataset}\n\\end{table}",
            "tab:link-prediction": "\\begin{table*}[ht]\n\\caption{Experiment results on link prediction. *: \\Ours significantly outperforms the best baseline with p-value $< 0.05$.}\n% \\vspace{-0.4cm}\n\\setlength{\\tabcolsep}{2.5mm}\n\\scalebox{0.85}{\n\\begin{tabular}{ll|c|c|c|c|c|c|c|c|c}\n\\toprule\n\\multicolumn{2}{c|}{\\multirow{2}{*}{Method}} & \\multicolumn{3}{c|}{\\textbf{DBLP}} & \\multicolumn{3}{c|}{\\textbf{Twitter}} & \\multicolumn{3}{c}{\\textbf{Goodreads}} \\\\\n\\multicolumn{2}{c|}{} & \\textbf{PREC} & \\textbf{MRR} & \\textbf{NDCG} & \\textbf{PREC} & \\textbf{MRR} & \\textbf{NDCG} & \\textbf{PREC} & \\textbf{MRR} & \\textbf{NDCG} \\\\ \\midrule\n\\multicolumn{1}{c}{} &MeanSAGE        & 0.7019 &  0.7964 &  0.8437 & 0.6489 & 0.7450 & 0.7991 & 0.6302 & 0.7409 & 0.8001                   \\\\\n\\multicolumn{1}{c}{} &BERT        & 0.7569 &  0.8340 &  0.8726 & 0.7179 & 0.7833 & 0.8265 & 0.5571 & \t0.6668 & 0.7395                   \\\\\n\\midrule\n\\multicolumn{1}{c}{\\multirow{4}{*}{\\rotatebox[origin=c]{90}{Homo GNN} }} & BERT+MeanSAGE   & 0.8131 &  0.8779 &  0.9070 & 0.7201 & 0.7845 & 0.8275 & 0.7301 & 0.8167 & 0.8594                   \\\\\n\\multicolumn{1}{c}{} &BERT+MAXSAGE   & 0.8193 &  0.8825\t &  0.9105 & 0.7198 & 0.7845 & 0.8276 & 0.7280 & 0.8164 & 0.8593                   \\\\\n\\multicolumn{1}{c}{} &BERT+GAT  &  0.8119  & 0.8771 &  0.9063 &  0.7231 & 0.7873 & 0.8300 & 0.7333 & 0.8170 & 0.8593                 \\\\\n\\multicolumn{1}{c}{} &GraphFormers  & 0.8324 &  0.8916 &  0.9175 & 0.7258 & 0.7891 & 0.8312 & 0.7444 & 0.8260 & 0.8665                   \\\\\n\\midrule\n\\multicolumn{1}{c}{\\multirow{5}{*}{\\rotatebox[origin=c]{90}{Hetero GNN} }} & BERT+RGCN  & 0.7979 &  0.8633 &  0.8945 & 0.7111 & 0.7764 & 0.8209 & 0.7488 & 0.8303 & 0.8699                   \\\\\n\\multicolumn{1}{c}{} & BERT+HAN  & 0.8136 &  0.8782 &  0.9072 & 0.7237 & 0.7880 & 0.8306 & 0.7329 & 0.8174 & 0.8597                   \\\\\n\\multicolumn{1}{c}{} & BERT+HGT  & 0.8170 &  0.8814 &  0.9098 & 0.7153 & 0.7800 & 0.8237 & 0.7224 & 0.8112 & 0.8552                   \\\\\n\\multicolumn{1}{c}{} & BERT+SHGN  & 0.8149 &  0.8785 &  0.9074 & 0.7218 & 0.7866 & 0.8295 & 0.7362 & 0.8195 & 0.8613                   \\\\\n\\multicolumn{1}{c}{} & GraphFormers++  & 0.8233 &  0.8856 &  0.9130 & 0.7159 & 0.7799 & 0.8236 & 0.7536 & 0.8328 & 0.8717                   \\\\\n\\midrule\n\\multicolumn{1}{c}{} & \\Ours  & \\textbf{0.8474*} &  \\textbf{0.9019*} &  \\textbf{0.9255*} & \\textbf{0.7272*} & \\textbf{0.7908*} & \\textbf{0.8328*} & \\textbf{0.7633*} & \\textbf{0.8400*} & \\textbf{0.8773*}                   \\\\\n\\bottomrule\n\\end{tabular}\n}\n\\label{tab:link-prediction}\n% \\vspace{-0.2cm}\n\\end{table*}",
            "fig::transductive_text_classification": "\\begin{table}[t]\n\\caption{Transductive text-rich node classification.}\n\\scalebox{0.85}{\n\\begin{tabular}{c|c|c|c|c}\n\\toprule\n\\multirow{2}{*}{Method} & \\multicolumn{2}{c|}{\\textbf{DBLP}} & \\multicolumn{2}{c}{\\textbf{Goodreads}} \\\\\n\\multicolumn{0}{c|}{} & \\textbf{Micro-F1}   & \\textbf{Macro-F1}     & \\textbf{Micro-F1}   & \\textbf{Macro-F1} \\\\\n\\midrule\nBERT   & 0.6119 &\t0.5476 &\t0.8364 &\t0.7713\\\\\n\\midrule\nBERT+MaxSAGE   & 0.6179 &\t0.5511 &\t0.8447 &\t0.7866\\\\\nBERT+MeanSAGE     &  0.6198 &\t0.5522 &\t0.8420 &\t0.7826 \\\\\nBERT+GAT    & 0.5943 &\t0.5175 &\t0.8328 &\t0.7713  \\\\\nGraphFormers   & 0.6256 &\t0.5616 &\t0.8388 &\t0.7786\\\\\n\\midrule\nBERT+HAN     &  0.5965 &\t0.5211 &\t0.8351 &\t0.7747\\\\\nBERT+HGT      &  0.6575 &\t0.5951 &\t0.8474 &\t0.7928  \\\\\nBERT+SHGN     &   0.5982 &\t0.5214 &\t0.8345 &\t0.7737  \\\\\nGraphFormers++     &   0.6474 &\t0.5790 &\t0.8516 &\t0.7993  \\\\\n\\midrule\n\\Ours &  \t\\textbf{0.6695*} &\t\\textbf{0.6062*} & \\textbf{0.8578*} &\t\\textbf{0.8076*} \\\\\n\\bottomrule\n\\end{tabular}\n}\n\\label{fig::transductive_text_classification}\n\\end{table}",
            "fig::inductive_text_classification": "\\begin{table}[t]\n\\caption{Inductive text-rich node classification.}\n\\scalebox{0.85}{\n\\begin{tabular}{c|c|c|c|c}\n\\toprule\n\\multirow{2}{*}{Method} & \\multicolumn{2}{c|}{\\textbf{DBLP}} & \\multicolumn{2}{c}{\\textbf{Goodreads}} \\\\\n\\multicolumn{0}{c|}{} & \\textbf{Micro-F1}   & \\textbf{Macro-F1}     & \\textbf{Micro-F1}   & \\textbf{Macro-F1} \\\\\n\\midrule\nBERT   & 0.5996 &\t0.5318 &\t0.8122 &\t0.7371\\\\\n\\midrule\nBERT+MaxSAGE   & 0.6117 &\t0.5435 &\t0.8368 &\t0.7749 \\\\\nBERT+MeanSAGE     &  0.6129 &\t0.5431 &\t0.8350 &\t0.7721 \\\\\nBERT+GAT    & 0.5879 &\t0.5150 &\t0.8249 &\t0.7590  \\\\\nGraphFormers   & 0.6197 &\t0.5548 &\t0.8330 &\t0.7683 \\\\\n\\midrule\nBERT+HAN     &  0.5948 &\t0.5165 &\t0.8279 &\t0.7626 \\\\\nBERT+HGT      &  0.6467 &\t0.5835 &\t0.8390 &\t0.7798 \\\\\nBERT+SHGN     &   0.5955 &\t0.5202 &\t0.8280 &\t0.7626  \\\\\nGraphFormers++     &   0.6386 &\t0.5696 &\t0.8427 &\t0.7848  \\\\\n\\midrule\n\\Ours &  \t\\textbf{0.6600*} &\t\\textbf{0.5976*} &\t\\textbf{0.8507*} &\t\\textbf{0.7977*} \\\\\n\\bottomrule            \n\\end{tabular}\n}\n\\label{fig::inductive_text_classification}\n\\end{table}",
            "fig::textless_classification": "\\begin{table}[t]\n\\caption{\\Tl node classification.}\n\\scalebox{0.85}{\n\\begin{tabular}{c|c|c|c|c}\n\\toprule\n\\multirow{2}{*}{Method} & \\multicolumn{2}{c|}{\\textbf{DBLP}} & \\multicolumn{2}{c}{\\textbf{Goodreads}} \\\\\n\\multicolumn{0}{c|}{} & \\textbf{Micro-F1}   & \\textbf{Macro-F1}     & \\textbf{Micro-F1}   & \\textbf{Macro-F1} \\\\\n\\midrule\nBERT+HAN     &  0.0604 &\t0.0270 &\t0.4726 &\t0.2464 \\\\\nBERT+HGT      &  0.0883 &\t0.0539 &\t0.4758 &\t0.1963 \\\\\nBERT+SHGN     &   0.0619 &\t0.0286 &\t0.4733 &\t0.2457  \\\\\nBERT+RGCN      &  0.2201 &\t0.1687 &\t0.5768 &\t0.3948 \\\\\nGraphFormers++     &   0.1072 &\t0.0698 &\t0.5007 &\t0.2772  \\\\\n\\midrule\n\\Ours & \\textbf{0.3817*} &\t\\textbf{0.3305*} &\t\\textbf{0.6292*} &\t\\textbf{0.4835*} \\\\\n\\bottomrule            \n\\end{tabular}\n}\n\\label{fig::textless_classification}\n\\end{table}",
            "fig::node_clustering": "\\begin{table}[t]\n% \\vspace{-0.3cm}\n\\caption{Node clustering.}\n% \\vspace{-0.2cm}\n\\scalebox{0.85}{\n\\begin{tabular}{c|c|c|c|c}\n\\toprule\n\\multirow{2}{*}{Method} & \\multicolumn{2}{c|}{\\textbf{DBLP}} & \\multicolumn{2}{c}{\\textbf{Goodreads}} \\\\\n\\multicolumn{0}{c|}{} & \\textbf{NMI}   & \\textbf{ARI}     & \\textbf{NMI}   & \\textbf{ARI} \\\\\n\\midrule\nBERT   & 0.2570 & 0.3349 & 0.2325 & 0.4013\\\\\n\\midrule\nBERT+MaxSAGE   & 0.2615 & 0.3490 & 0.2205 & 0.4173\\\\\nBERT+MeanSAGE     &  0.2628 & 0.3488 & \\textbf{0.2449} & \\textbf{0.4329}\\\\\nBERT+GAT    & 0.2598 & 0.3419 & 0.2408 & 0.4185 \\\\\nGraphFormers   & 0.2633 & 0.3455 & 0.2362 & 0.4139\\\\\n\\midrule\nBERT+HAN     &  0.2568 & 0.3401 & 0.2391 & 0.4266\\\\\nBERT+HGT      &  0.2469 & 0.3392 & 0.2427 & 0.4296 \\\\\nBERT+SHGN     &   0.2589 & 0.3431 & 0.2373 & 0.4171 \\\\\nGraphFormers++     &   0.2566 & 0.3432 & 0.2372 & 0.4211 \\\\\n\\midrule\n\\Ours &   \\textbf{0.2707*} & \\textbf{0.3639*} & 0.2429 & 0.4199 \\\\\n\\bottomrule            \n\\end{tabular}\n}\n\\label{fig::node_clustering}\n% \\vspace{-0.4cm}\n\\end{table}",
            "tab::hp": "\\begin{table}[t]\n\\caption{Ablation study on heterogeneous projection.}\n\\vspace{-0.2cm}\n\\scalebox{0.85}{\n\\begin{tabular}{c|c|c|c|c}\n\\toprule\n\\multicolumn{1}{c|}{\\multirow{2}{*}{Method}} & \\multicolumn{2}{c|}{\\textbf{DBLP}} & \\multicolumn{2}{c}{\\textbf{Goodreads}} \\\\\n\\multicolumn{1}{c|}{} & \\textbf{PREC} & \\textbf{MRR} & \\textbf{PREC} & \\textbf{MRR}  \\\\\n% Model  & DBLP & Goodreads \\\\\n\\midrule\n\\Ours & 0.8474  & 0.9019 & 0.7633 & 0.8400 \\\\\n\\midrule\n\\Ours w/o hp & 0.8415 & 0.8983 & 0.7493 & 0.8325 \\\\\n\\bottomrule            \n\\end{tabular}\n}\\label{tab::hp}\n\\end{table}",
            "apx:complexity": "\\begin{table}[t]\n% \\vspace{-0.4cm}\n\\caption{Scalability Study for BERT+MeanSAGE, Graphformers and \\Ours on Goodreads.}\n\\vspace{-0.2cm}\n\\scalebox{0.85}{\n\\begin{tabular}{c|c|c}\n\\toprule\nModel  & Time & Memory \\\\\n\\midrule\nBERT+MeanSAGE & 440.18ms & 19,637MB \\\\\n\\midrule\nGraphFormers & 490.27ms  & 20,385MB \\\\\n \\midrule\n\\Ours & 508.27ms  & 20,803MB \\\\\n\\bottomrule            \n\\end{tabular}\n}\\label{apx:complexity}\n\\end{table}",
            "apx:hyper": "\\begin{table}[t]\n\\caption{Hyper-parameter configuration.}\n\\vspace{-0.4cm}\n\\scalebox{0.8}{\n\\begin{tabular}{c|c|c|c}\n\\toprule\nParameter & DBLP & Twitter & Goodreads \\\\\n\\midrule\nlearning rate & \\multicolumn{3}{c}{1e-5} \\\\\n\\midrule\nweight decay & \\multicolumn{3}{c}{1e-3} \\\\\n\\midrule\nadam epsilon & \\multicolumn{3}{c}{1e-8} \\\\\n\\midrule\nearly stop & \\multicolumn{3}{c}{3} \\\\\n\\midrule\n\\tl embedding & \\multicolumn{3}{c}{64} \\\\\n\\midrule\nchunk $k$ & \\multicolumn{3}{c}{12} \\\\\n\\midrule\ntrain batch size & \\multicolumn{3}{c}{30} \\\\\n\\midrule\ntest batch size & 100 & 300 & 100 \\\\\n\\midrule\nPLM backbone & \\multicolumn{3}{c}{BERT-base-uncased} \\\\\n\\midrule\ntoken sequence length & 32 & 12 & 64 \\\\\n\\midrule\n\\multirow{3}{*}{neighbor sampling} & paper:5 & tweet:6 & book:5, shelves:5 \\\\\n& authors:3 & mention:2 & author:2, language code:1  \\\\\n& venue:1 & tag:3,user:1 & publisher:1, format:1 \\\\\n\n\\bottomrule            \n\\end{tabular}\n% \\vspace{-0.2cm}\n}\\label{apx:hyper}\n\\end{table}",
            "tab::retrieve": "\\begin{table}[t]\n\\vspace{-0.3cm}\n\\caption{Case study of query-based retrieval on DBLP. Top-7 retrieved papers are shown for each method.}\n\\vspace{-0.4cm}\n\\scalebox{0.67}{\n\\begin{tabular}{c|l}\n\\toprule\n\\multicolumn{2}{c}{\\textbf{Query:} \\sethlcolor{yellow}\\hl{news recommendation} with \\sethlcolor{pink}\\hl{personalization}}\\\\\n\\midrule\n% \\textbf{Model} \n& \\multicolumn{1}{c}{\\textbf{Retrieved Paper Title}} \\\\\n\\midrule\n\\multirow{7}{*}{\\rotatebox[origin=c]{90}{BERT}} & (\\ding{55}) \\sethlcolor{yellow}\\hl{News Recommenders}: Real-Time, Real-Life Experiences \\\\\n\\multicolumn{0}{c|}{} & (\\ding{55}) \\sethlcolor{yellow}\\hl{News recommender systems} â€“ Survey and roads ahead \\\\\n\\multicolumn{0}{c|}{} & (\\ding{55}) A Survey on Challenges and Methods in \\sethlcolor{yellow}\\hl{News Recommendation} \\\\\n\\multicolumn{0}{c|}{} & (\\ding{51}) \\sethlcolor{pink}\\hl{Personalized} \\sethlcolor{yellow}\\hl{news recommendation}: a review and an experimental investigation \\\\\n\\multicolumn{0}{c|}{} & (\\ding{51}) Interweaving Trend and User Modeling for \\sethlcolor{pink}\\hl{Personalized} \\sethlcolor{yellow}\\hl{News Recommendation} \\\\\n\\multicolumn{0}{c|}{} & (\\ding{55}) A multi-perspective transparent approach to \\sethlcolor{yellow}\\hl{news recommendation} \\\\\n\\multicolumn{0}{c|}{} & (\\ding{55}) Workshop and challenge on \\sethlcolor{yellow}\\hl{news recommender systems} \\\\\n\\midrule\n\\multirow{7}{*}{\\rotatebox[origin=c]{90}{GraphFormers}} & (\\ding{51}) \\sethlcolor{pink}\\hl{Personalized} \\sethlcolor{yellow}\\hl{news recommendation} based on links of web \\\\\n\\multicolumn{0}{c|}{} & (\\ding{55}) Interpreting \\sethlcolor{yellow}\\hl{News Recommendation} Models \\\\\n\\multicolumn{0}{c|}{} & (\\ding{55}) Do recommendations matter?: \\sethlcolor{yellow}\\hl{news recommendation} in real life \\\\\n\\multicolumn{0}{c|}{} & (\\ding{51}) \\sethlcolor{pink}\\hl{Personalized} \\sethlcolor{yellow}\\hl{News Recommendation} Based on Collaborative Filtering \\\\\n\\multicolumn{0}{c|}{} & (\\ding{51}) LOGO: a long-short user interest integration in \\sethlcolor{pink}\\hl{personalized} \\sethlcolor{yellow}\\hl{news recommendation} \\\\\n\\multicolumn{0}{c|}{} & (\\ding{55}) The Intricacies of Time in \\sethlcolor{yellow}\\hl{News Recommendation} \\\\\n\\multicolumn{0}{c|}{} & (\\ding{55}) Workshop and challenge on \\sethlcolor{yellow}\\hl{news recommender systems} \\\\\n\\midrule\n\\multirow{7}{*}{\\rotatebox[origin=c]{90}{\\Ours}} & (\\ding{51}) User attitudes towards \\sethlcolor{yellow}\\hl{news content} \\sethlcolor{pink}\\hl{personalization} \\\\\n\\multicolumn{0}{c|}{} & (\\ding{51}) A system for generating \\sethlcolor{pink}\\hl{personalized} virtual \\sethlcolor{yellow}\\hl{news} \\\\\n\\multicolumn{0}{c|}{} & (\\ding{51}) \\sethlcolor{pink}\\hl{Personalized} \\sethlcolor{yellow}\\hl{News Recommendation} Based on Collaborative Filtering \\\\\n\\multicolumn{0}{c|}{} & (\\ding{55}) Automatic \\sethlcolor{yellow}\\hl{news recommendations} via aggregated profiling \\\\\n\\multicolumn{0}{c|}{} & (\\ding{51}) Design and Deployment of a \\sethlcolor{pink}\\hl{Personalized} \\sethlcolor{yellow}\\hl{News Service} \\\\\n\\multicolumn{0}{c|}{} & (\\ding{51}) The design and implementation of \\sethlcolor{pink}\\hl{personalized} \\sethlcolor{yellow}\\hl{news recommendation system} \\\\\n\\multicolumn{0}{c|}{} & (\\ding{51}) \\sethlcolor{pink}\\hl{Personalizing} \\sethlcolor{yellow}\\hl{news content}: An experimental study \\\\\n\\bottomrule\n\\end{tabular}\n}\n% \\vspace{-0.4cm}\n\\label{tab::retrieve}\n\\end{table}"
        },
        "figures": {
            "fig:intro": "\\begin{figure}\n\\centering\n\\includegraphics[width=0.45\\textwidth]{fig/intro_new.eps}\n\\vspace{-0.3cm}\n\\caption{(a) Examples of heterogeneous text-rich networks: an academic network and a social media network. (b) An illustration of our heterogeneous network-empowered Transformer, \\Ours. One \\Ours layer is zoomed out. AGG denotes neighbor aggregation on the network.}\n\\label{fig:intro}\n\\end{figure}",
            "fig::whole-structure": "\\begin{figure*}\n\\centering\n\\includegraphics[width=16cm]{fig/main_new.eps}\n% \\vspace{-0.2cm}\n\\caption{The overall architecture of \\Ours. There are two layers in the figure, while in experiments we have 11 layers. Different color denotes different types of nodes. The whole encoding procedure of \\Ours can be found in Appendix \\ref{apx::sec::alg}.}\\label{fig::whole-structure}\n% \\vspace{-0.4cm}\n\\end{figure*}",
            "fig::visualization": "\\begin{figure}[t]\n% \\vspace{-0.3cm}\n\\centering\n\\subfigure[DBLP]{               \n\\includegraphics[width=4cm]{fig/DBLP2d.eps}}\n\\hspace{0in}\n\\subfigure[Goodreads]{\n\\includegraphics[width=4cm]{fig/book2d.eps}}\n% \\vspace{-0.5cm}\n\\caption{Embedding visualization.}\\label{fig::visualization}\n\\end{figure}",
            "fig::ablation": "\\begin{figure}[t]\n\\centering\n\\subfigure[DBLP]{               \n\\includegraphics[width=4cm]{fig/DBLP-ablation2.eps}}\n\\hspace{0in}\n\\subfigure[Goodreads]{\n\\includegraphics[width=4cm]{fig/book-ablation2.eps}}\n\\vspace{-0.4cm}\n\\caption{Ablation study on neighbor aggregation.}\\label{fig::ablation}\n\\vspace{-0.4cm}\n\\end{figure}",
            "fig::hyper": "\\begin{figure}[t]\n\\vspace{-0.3cm}\n\\centering\n\\subfigure[DBLP]{               \n\\includegraphics[width=4cm]{fig/DBLP-hyper.eps}}\n\\hspace{0in}\n\\subfigure[Goodreads]{\n\\includegraphics[width=4cm]{fig/book-hyper.eps}}\n\\vspace{-0.5cm}\n\\caption{Effect of \\tl node embedding dimension.}\\label{fig::hyper} %$z_v, \\phi(v)\\in\\mathcal{A}_p$\n% \\vspace{-0.2cm}\n\\end{figure}",
            "fig::initialization": "\\begin{figure}[t]\n% \\vspace{-0.3cm}\n\\centering\n\\subfigure[DBLP, Validation PREC]{               \n\\includegraphics[width=4cm]{fig/DBLP-learning4.eps}}\n\\hspace{0in}\n\\subfigure[Goodreads, Validation PREC]{\n\\includegraphics[width=4cm]{fig/book-learning4.eps}}\n\\vspace{-0.2cm}\n\\caption{Performance of \\Ours during the training process with and without \\tl node warm-up.}\\label{fig::initialization}\n\\vspace{-0.3cm}\n\\end{figure}",
            "fig::att-map": "\\begin{figure}[t]\n% \\vspace{-0.3cm}\n\\centering\n\\subfigure[w/o warm-up]{               \n\\includegraphics[width=4cm]{fig/no_pretrain_attention_map.eps}}\n\\hspace{0in}\n\\subfigure[w/ warm-up]{\n\\includegraphics[width=4cm]{fig/pretrain_attention_map.eps}}\n\\vspace{-0.5cm}\n\\caption{Self-attention probability map study of \\Ours with and without \\tl node warm-up for a random sample. The x-axis corresponds to different key/value tokens and the y-axis corresponds to different \\Ours layers.}\\label{fig::att-map}\n% \\vspace{-0.3cm}\n\\end{figure}"
        },
        "equations": {
            "eq:eq::concate": "\\begin{equation}\\label{eq::concate}\n    \\widetilde{\\bmH}^{(l)}_{v_i} = \\widehat{\\bmz}^{(l)}_{v_i} \\mathop{\\Vert} \\bmH^{(l)}_{v_i} \\mathop{\\Vert} \\widecheck{\\bmz}^{(l)}_{v_i}.\n\\end{equation}",
            "eq:eq::transformers": "\\begin{equation}\\label{eq::transformers}\n    \\begin{gathered}\n        \\widetilde{\\bmH}^{(l)'}_{v_{i}} = {\\rm LN}(\\bmH^{(l)}_{v_{i}} + {\\rm MHA}(\\bmH^{(l)}_{v_{i}},\\widetilde{\\bmH}^{(l)}_{v_{i}})), \\\\\n        \\bmH^{(l+1)}_{v_{i}} = {\\rm LN}(\\widetilde{\\bmH}^{(l)'}_{v_{i}} + {\\rm MLP}(\\widetilde{\\bmH}^{(l)'}_{v_{i}})).\n    \\end{gathered}\n\\end{equation}",
            "eq:eq::mha": "\\begin{equation}\\label{eq::mha}\n    \\begin{aligned}\n        \\bar{\\bmz}^{(l)}_{v_i} &= \\mathop{\\Vert}_{t=1}^k {\\rm head}^t(\\bmh^{(l)}_{v_i,t}, \\{\\bmh^{(l)}_{v_j\\rightarrow v_i,t}|v_j\\in \\bar{N}_{v_i}\\}), \\\\\n        & = \\mathop{\\Vert}_{t=1}^k \\sum\\limits_{v_j \\in \\bar{N}_{v_i}\\cup\\{v_i\\}} \\bar{\\alpha}^{(l)}_{{v_i}{v_j},t}\\bar{\\bmW}^{(l)}_{V,t} \\bmh^{(l)}_{v_j\\rightarrow v_i,t}.\n    \\end{aligned}\n\\end{equation}",
            "eq:1": "\\begin{equation}\n    \\begin{aligned}\n        \\bar{\\alpha}^{(l)}_{{v_i}{v_j},t} &= {\\rm softmax}(\\bar{e}^{(l)}_{{v_i}{v_j},t}) \\\\    \n        &= {\\rm softmax}({\\rm Norm}((\\bar{\\bmW}^{(l)}_{Q,t} \\bmh^{(l)}_{x,t} )^\\top (\\bar{\\bmW}^{(l)}_{K,t} \\bmh^{(l)}_{{v_j}\\rightarrow {v_i},t} ))).\n    \\end{aligned}\n\\end{equation}",
            "eq:eq::prop": "\\begin{equation}\\label{eq::prop}\n    \\begin{aligned}  \n        \\bmh^{(l)}_{v_j\\rightarrow v_i} = \\bmW_r \\bmh^{(l)}_{v_j}, \\ \\text{where}\\ \\psi(e_{v_jv_i}) = r.\n    \\end{aligned}\n\\end{equation}",
            "eq:eq::node-proj": "\\begin{equation}\\label{eq::node-proj}\n    \\bmh^{(l)}_{v_p} = \\bmW^{(l)}_{\\phi_i} \\bmh^{(0)}_{v_p},\\ \\ \\ \\text{where}\\ \\phi(v_p)=\\phi_i,\\ \\ \\phi_i\\in\\mathcal{A}_\\text{TL}.\n\\end{equation}",
            "eq:2": "\\begin{equation}\n\\label{warm-up}\n\\small\n    \\min_{\\bmh^{(l)}_{v_p}}\\mathcal{L}_{w}=\\sum_{\\substack{v_p\\in\\mathcal{V} \\\\ \\phi(v_p)\\in \\mathcal{A}_\\text{TL}}}\\sum_{v_u\\in \\widehat{N}_{v_p}}-\\log\\frac{\\exp(\\widebar{\\bmh}_{v_u}^{\\ \\top} \\bmh^{(l)}_{v_p})}{\\exp(\\widebar{\\bmh}_{v_u}^{\\ \\top} \\bmh^{(l)}_{v_p})+\\sum_{v_u'}\\exp(\\widebar{\\bmh}_{v_u'}^{\\ \\top} \\bmh^{(l)}_{v_p})},\n\\end{equation}",
            "eq:likelihood": "\\begin{equation}\\label{likelihood}\n    \\max_{\\Theta} \\mathcal{O} = \\prod_{\\substack{v_i\\in \\mathcal{V} \\\\ \\phi(v_i)\\in\\mathcal{A}_\\text{TR}}}\\prod_{\\substack{v_j\\in N_{v_i} \\\\ \\phi(v_j)\\in\\mathcal{A}_\\text{TR}}} p(v_j|v_i;\\Theta),\n\\end{equation}",
            "eq:3": "\\begin{equation}\n    p(v_j|v_i;\\Theta) = \\frac{\\exp(\\bmh_{v_j}^\\top \\bmh_{v_i})}{\\sum_{v_u\\in \\mathcal{V}, \\phi(v_u)\\in\\mathcal{A}_\\text{TR}}\\exp(\\bmh_{v_u}^\\top \\bmh_{v_i})},\n\\end{equation}",
            "eq:4": "\\begin{equation}\n\\label{loss}\n\\small\n    \\min_{\\Theta} \\mathcal{L}=\\sum_{\\substack{v_i\\in \\mathcal{V} \\\\ \\phi(v_i)\\in\\mathcal{A}_\\text{TR}}}\\sum_{\\substack{v_j\\in N_{v_i} \\\\ \\phi(v_j)\\in\\mathcal{A}_\\text{TR}}}-\\log\\frac{\\exp(\\bmh_{v_j}^\\top \\bmh_{v_i})}{\\exp(\\bmh_{v_j}^\\top \\bmh_{v_i})+\\sum_{v_u'}\\exp(\\bmh_{v_u'}^\\top \\bmh_{v_i})}.\n\\end{equation}"
        }
    }
}