{
    "meta_info": {
        "title": "ClusterEA: Scalable Entity Alignment with Stochastic Training and  Normalized Mini-batch Similarities",
        "abstract": "Entity alignment (EA) aims at finding equivalent entities in different\nknowledge graphs (KGs). Embedding-based approaches have dominated the EA task\nin recent years. Those methods face problems that come from the geometric\nproperties of embedding vectors, including hubness and isolation. To solve\nthese geometric problems, many normalization approaches have been adopted for\nEA. However, the increasing scale of KGs renders it hard for EA models to adopt\nthe normalization processes, thus limiting their usage in real-world\napplications. To tackle this challenge, we present ClusterEA, a general\nframework that is capable of scaling up EA models and enhancing their results\nby leveraging normalization methods on mini-batches with a high entity\nequivalent rate. ClusterEA contains three components to align entities between\nlarge-scale KGs, including stochastic training, ClusterSampler, and\nSparseFusion. It first trains a large-scale Siamese GNN for EA in a stochastic\nfashion to produce entity embeddings. Based on the embeddings, a novel\nClusterSampler strategy is proposed for sampling highly overlapped\nmini-batches. Finally, ClusterEA incorporates SparseFusion, which normalizes\nlocal and global similarity and then fuses all similarity matrices to obtain\nthe final similarity matrix. Extensive experiments with real-life datasets on\nEA benchmarks offer insight into the proposed framework, and suggest that it is\ncapable of outperforming the state-of-the-art scalable EA framework by up to 8\ntimes in terms of Hits@1.",
        "author": "Yunjun Gao, Xiaoze Liu, Junyang Wu, Tianyi Li, Pengfei Wang, Lu Chen",
        "link": "http://arxiv.org/abs/2205.10312v2",
        "category": [
            "cs.DB",
            "cs.AI",
            "cs.CL",
            "cs.LG"
        ],
        "additionl_info": "KDD 2022"
    },
    "latex_extraction": {
        "content": {
            "section 1": {
                "name": "Introduction",
                "content": "\n\\label{sec:intro}\nKnowledge graphs (KGs) represent collections of relations between real-world objects, which facilitate many downstream applications, such as semantic search~\\cite{XiongPC17} and recommendation systems~\\cite{ZhangYLXM2016}.\nAlthough various KGs have been constructed in recent years, they are still highly incomplete. To be more specific, KGs built from different data sources hold unique information individually while having overlapped entities. This motivates us to integrate the knowledge of different KGs with the overlapped entities to complete KGs.\nEntity alignment (EA)~\\cite{MTransE17}, a fundamental strategy for knowledge integration, has been widely studied. EA aims to align entities from different KGs that refer to the same real-world objects, and thus, it facilitates the completion of KGs.\n\nEmbedding-based EA has been proposed~\\cite{MTransE17}, and has been witnessed rapid development in recent years~\\cite{KECG19, RREA20, AliNet20, HyperKA20, DualAMN21} thanks to the use of Graph Neural Networks (GNNs)~\\cite{GCN17, GAT18, GraphSAGE17}.\nThey assume that the neighbors of two equivalent entities in KGs are also equivalent~\\cite{AttrGNN20}. Based on this, they align entities by applying representation learning to KGs. We summarize the process of Embedding-based EA as the following three steps: (i) taking two input KGs and collecting \\emph{seed alignment} as training data; (ii) training an EA model with the isomorphic graph structure of two KGs to encode entities into embedding vectors; and (iii) aligning the equivalent entities between the two input KGs based on a specific similarity measurement (e.g., cosine similarity) of their corresponding embeddings.\n\n% The magnitude of real-world KGs is large.\nThe size of real-world KGs is much larger than that of conventional datasets used in evaluating EA tasks.\n% Compared with the size of the conventional datasets used in evaluating EA tasks, the scale of real-world KGs is much larger.\nFor instance, a real-world KG YAGO3 includes 17 million entities~\\cite{LargeEA22}. Thus, EA methods should be scaled up to massive data in order to adapt to real-world applications. However, a recent proposal~\\cite{LargeEA22}\nlost too much graph structure information, trading the quality of results for scalability.\n% resulting in poor EA performance.\nWorse still, as the input KGs become larger, using greedy search~\\cite{OpenEA2020VLDB} to find corresponding entities \\MARK{from one KG to another} with top-1-nearest neighbor becomes more challenging.\n%\n% One way to enhance the EA performance is to incorporate side information other than the graph structure of KGs. Recent methods \\cite{DegreeAware20, AttrGNN20, EPEA20, EASY21, LargeEA22, CEAFF20, SEU21, BERT-INT20} propose that introducing literal information of entity names could provide a multi-aspect view for alignment models. However, compared with the methods with side information, the structure-only methods are more general~\\cite{DualAMN21,RREA20, MRAEA20}. Moreover, the performances of models that incorporate machine translation on entity names are overestimated because of the name-bias issue~\\cite{JEANS20, AttrGNN20, EVA20, NoMatch21}. Therefore, we should focus our attention on structure-based methods.\nSpecifically, the geometric properties of high-dimensional embedding vector spaces lead to problems for embedding-based EA, namely, \\emph{geometric problems}, mainly including the hubness and isolation problems~\\cite{OpenEA2020VLDB}.\nThe hubness problem indicates that some points (known as hubs) frequently appear as the top-1 nearest neighbors of many other points in the vector space.\nThe isolation problem implies that some outliers would be isolated from any point clusters. As the scale of input KGs grows, these problems become even more severe due to the increasing number of candidates of nearest neighbor search.\n% Since most real-world entities are only represented by one entity in one KG,\nEA is generally assumed to follow 1-to-1 mapping~\\cite{MTransE17}.\n% This means when aligning two KGs, for each entity in one KG, there's one, and there's only one entity in the other KG that refers to the same real-world entity.\nMany existing methods have been proposed to solve the geometric problems by making the similarity matrix better satisfy this assumption, i.e., \\emph{normalization} methods.\n% by making the similarity matrix closer to a permutation matrix.\n% We call these approaches as the \\emph{normalization} process for the similarity matrix.\n% \\footnote{A similarity matrix may not be a square matrix. However, this kind of non-square matrix normalization could be solved easily.}.\nA list of widely used normalization methods for EA includes (i) \\emph{Cross-domain Similarity Local Scaling (CSLS)}~\\cite{CSLS} that is adopted from word translation~\\cite{TransEdge19,EVA20, RREA20, EASY21}; (ii) \\emph{Gale-Shapley algorithm}~\\cite{GaleShapley} that treats EA as stable matching~\\cite{CEAFF20,CEAFF21}; (iii) \\emph{Hungarian algorithm}~\\cite{Hungarian1955} and (iv) \\emph{Sinkhorn iteration}~\\cite{Sinkhorn13} that both transform EA as the assignment problem~\\cite{DGMC20, SEU21, EASY21}.\n% In recent years, it has been pointed out that the EA task can be transformed as the assignment problem~\\cite{OTEA19, DGMC20, EASY21, SEU21}.\n% The assignment problem is well-studied and can be solved using the Hungarian algorithm~\\cite{Hungarian1955} or normalizing the matrix with optimal transportation~\\cite{AssignProblemOT18} methods such as Sinkhorn iteration~\\cite{Sinkhorn13}.\nSpecifically, Sinkhorn iteration~\\cite{Sinkhorn13} could significantly improve the accuracy of matching entities with embeddings~\\cite{EASY21, SEU21}. Moreover, Sinkhorn iteration suits the normalization approach of EA best as it can be easily parallelized on the GPU. % which is more suitable for  Making it the most suitable normalization approach for the EA task.\nNonetheless, the existing normalization approaches~\\cite{CSLS,Sinkhorn13, GaleShapley, Hungarian1955} are at least of quadratic complexity. This prohibits them from being applied to large-scale data, thus limiting their real-world applications.\n\nIn this work, we aim to scale up the normalization process of the similarity matrix to achieve higher EA performance.\nWe adopt a standard machine learning technique, sampling mini-batches, to perform EA in linear time.\nSpecifically, we first train a GNN model to obtain the global embeddings of two KGs.\nThen, we generate mini-batches for two KGs by placing entities that could find their equivalent together.\n\\MARK{Next, we calculate and normalize a local similarity matrix between two sets of entities selected for each mini-batch by Sinkhorn iteration.}\nFinally, we merge the local similarities into a unified and sparse similarity matrix.\nWith this strategy, the final similarity matrix is normalized with Sinkhorn iteration, thus achieving higher accuracy, and the time and space complexities can also be significantly reduced.\nHowever, its materialization is non-trivial due to the two major challenges:\n% \\vspace{-5mm}\n\\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt,partopsep=0pt,leftmargin=*]\n  \\item \\textit{How to sample mini-batches with high entity equivalence rate to ensure 1-to-1 mapping?} Splitting mini-batches on two KGs is quite different from conventional tasks. To transfer EA within mini-bathes into the assignment problem, we should place possibly equivalent entities into the same batch to meet the 1-to-1 mapping assumption. Nevertheless, the mapping is only partially known (as the training set) for the EA task, making it hard for two entities to be aligned and hence to be placed in the same batch. Intuitively, randomly splitting two KGs will make most mini-batches fail to correspond. An existing study~\\cite{LargeEA22} proposes a rule-based method to split batches with a higher rate of entity equivalence. Nonetheless, its results are still not enough to satisfy the 1-to-1 mapping assumption.\n  \\item \\textit{How to fuse the mini-batch similarity matrices to ensure high accuracy?} The similarity matrix of each batch focuses only on its local information. Thus, the results generally deviate from those obtained without sampling, even if the batch sampler is good enough. This motivates us to study two problems. First, how to combine the similarities of the mini-batches to get a better global optimal match, after getting the mini-batch. Second, how to improve the accuracy of results obtained by batch samplers.\n\\end{itemize}\n\n\nTo tackle the aforementioned two challenges, we present a general EA framework, \\ClusterEA{}, that can be applied to arbitrary GNN-based EA models while can be able to achieve high accuracy and scalability.\nTo scale up GNN training over large-scale KGs, \\ClusterEA{} first utilizes neighborhood sampling~\\cite{GraphSAGE17} to train a large-scale GNN for EA in a stochastic fashion.\nThen, with the embedding obtained from the GNN model, \\ClusterEA{} proposes a novel \\emph{strategy} for generating high-quality mini-batches in EA, called \\Sampling{}. As depicted in Figure~\\ref{fig:example}, \\Sampling{} first labels the training pairs into different batches with a \\emph{clustering} method. Then, it performs supervised \\emph{classification} using previously labeled training pairs to generate mini-batches for all the entities. By changing the \\emph{clustering} and \\emph{classification} models, the strategy can sample mini-batches by capturing multiple aspects of the graph structure information. We propose two sampling methods within \\Sampling{}, including\n(i)  \\emph{\\MetisFullName{} (\\MetisGCN{})} that retains the intra-KG graph structure information such as the neighborhood of nodes; and\n(ii) \\emph{\\KMeansFullName{} (\\KMeans{})} which retains the inter-KG matching information provided by the learned embedding.\nThese methods sample two KGs into multiple mini-batches with a high entity equivalent rate to satisfy the 1-to-1 mapping assumption better.\nFinally, \\ClusterEA{} uses our proposed \\Merging{}, which fuses the similarity matrices calculated separately using Sinkhorn iteration with normalized global similarity. The \\Merging{} produces a matrix with high sparsity while keeping as much valuable information as possible.\n\nOur contributions are summarized as follows:\n\n\\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt,partopsep=0pt,leftmargin=*]\n    \\item{\\emph{Scalable EA framework.}}\n    We develop \\ClusterEA{}\\footnote{https://github.com/joker-xii/ClusterEA}, a scalable framework for EA, which reduces the complexity of normalizing similarity matrices with mini-batch. To the best of our knowledge, this is the first framework that utilizes stochastic GNN training for large-scale EA. Any GNN model can be easily integrated into \\ClusterEA{} to deal with large-scale EA (Section~\\ref{sec:framework}) with better scalability and higher accuracy.\n    \\item{\\emph{Fast and accurate batch samplers.}}\n    We present \\Sampling{}, a novel \\emph{strategy} that samples batches by learning the latent information from embeddings of the EA model. In the strategy, we implement two samplers to capture different aspects of KG information, including\n    (i) \\MetisGCN{} that aims at retaining the intra-KG graph structure information, and\n    (ii) \\KMeans{} that aims at retaining the inter-KG alignment information. Unlike the previous rule-based method, the two samplers are learning-based, and thus can be parallelized and produce high-quality mini-batches.\n    \\item{\\emph{Fused local and global similarity matrix.}} We propose \\Merging{} for normalizing and fusing not only local similarity matrices but also global similarity matrices into one unified sparse matrix, which enhances the expressive power of EA models.\n    \\item{\\emph{Extensive experiments.}} We conduct comprehensive experimental evaluation on EA tasks compared against state-of-the-art approaches over the existing EA benchmarks. Considerable experimental results demonstrate that  \\ClusterEA{} successfully achieves satisfactory accuracy on both conventional datasets and large-scale datasets (Section~\\ref{sec:exp}).\n\\end{itemize}\n\n\n\n\\vspace*{-2mm}\n"
            },
            "section 2": {
                "name": "Related Work",
                "content": "\n\\label{sec:related_work}\n\n% Entity alignment (EA) is a prerequisite for enlarging the coverage of a unified knowledge graph.\n% Early EA methods rely on hand-crafted features~\\cite{YAGO3}, crowdsourcing~\\cite{Wikidata14, Hike17}, and OWL semantics~\\cite{LogMap11}.\n% They are unrealistic for real-world EA scenarios with symbolic or linguistic heterogeneity.\nMost existing EA proposals find equivalent entities by measuring the similarity between the embeddings of entities. Structures of KGs are the basis for the embedding-based EA methods.\nRepresentative EA approaches that rely purely on KGs' structures can be divided into two categories, namely, \\emph{KGE}-\\emph{based EA}~\\cite{MTransE17, IPTransE17, BootEA18, TransEdge19} and \\emph{GNN-based EA}~\\cite{GCN-Align18, KECG19, MRAEA20, AliNet20, HyperKA20, MuGNN19}.\nThe former incorporates the KG embedding models (e.g., TransE~\\cite{TransE13}) to learn entity embeddings. The latter\n%GNN-based EA\nlearns the entity embeddings using GNNs~\\cite{GCN17}, which aggregates the neighbors' information of entities.\n% Though GNN-based models have demonstrated their outstanding performance, %compared to the translational-based ones,\n%Despite this benefit, GNN-based EA lacks\n\nIn recent years, GNN-based models have demonstrated their outstanding performance~\\cite{DualAMN21}. This is contributed by the strong modeling capability on the non-Euclidean structure of GNNs with anisotropic attention mechanism~\\cite{GAT18}. Nonetheless, they suffer from poor scalability~\\cite{LargeEA22} due to the difficulty in sampling mini-batches with neighborhood information on KGs. LargeEA~\\cite{LargeEA22}, the first study focusing on the scalability of EA, proposes to train GNN models on relatively small batches of two KGs independently.\nThe small batches are generated with a rule-based partition strategy called METIS-CPS.\nHowever, massive information of both graph structures and seed alignment is lost during the process, resulting in poor structure-based accuracy. In contrast, \\ClusterEA{} utilizes neighborhood sampling~\\cite{GraphSAGE17}. Specifically, it trains one unified GNN model on the two KGs, during which the loss of structure information is neglectable.\nMoreover, \\ClusterEA{} creates mini-batches using multiple aspects of graph information, resulting in better entity equivalent rate than METIS-CPS.\n\nIn addition to structure information, many existing proposals facilitate the EA performance by employing \\emph{side information} of KGs,  including\n%Such side information includes\n\\emph{entity names} \\cite{JAPE17,MultiKE19,DGMC20,DegreeAware20,BERT-INT20, AttrGNN20, EASY21, SEU21, LargeEA22, DSE1,DSE2}, \\emph{descriptions} \\cite{MultiKE19, BERT-INT20}, \\emph{images} \\cite{EVA20}, and \\emph{attributes} \\cite{JAPE17,GCN-Align18,MultiKE19,COTSAE20,BERT-INT20,AttrGNN20,EPEA20}. Such proposals are able to mitigate the geometric problems~\\cite{OpenEA2020VLDB}.\nNonetheless, the models using side information mainly have two main limitations. \\MARK{First, side information may not be available due to privacy concerns}, especially for\nindustrial applications~\\cite{DualAMN21,RREA20, MRAEA20}.\nSecond, \\MARK{models that incorporating machine translation or pre-aligned word embeddings may be overestimated due to the name bias issue}~\\cite{JEANS20, AttrGNN20, EVA20, NoMatch21}.\n\\MARK{Thus, compared with the models employing side information, the structure-only methods are more general and not affected by bias of benchmarks}.\nTo this end, we do not incorporate side information in \\ClusterEA{}.\n\n% Many studies have been based on this assumption by normalizing the overall similarity matrix between two set of embeddings. These methods\nIn order to solve the geometric problems of embedding-based EA approaches, CSLS~\\cite{CSLS} have been widely adopted, which normalizes the similarity matrix in recent studies~\\cite{TransEdge19,EVA20, RREA20, EASY21}.\nHowever, \\MARK{CSLS does not perform full normalization of the similarity matrix.\nAs a result, its improvement over greedy search of top-1-nearest neighbor is limited.}\nCEA~\\cite{CEAFF20, CEAFF21} adopts the Gale-Shapley algorithm~\\cite{GaleShapley} to find the stable matching between entities of two KGs, which produces higher-quality results than CSLS.\nNevertheless, the Gale-Shapley algorithm is hard to be parallelized, and hence, it is almost infeasible to perform large scale EA. Recent studies have transformed EA into the assignment problem~\\cite{EASY21, SEU21}. They adopt Hungarian algorithm~\\cite{Hungarian1955} or Sinkhorn iteration~\\cite{Sinkhorn13} to normalize the similarity matrix. However, the computational cost of such algorithms is high, prohibiting them from being applied to large scale EA.\n\\ClusterEA{} also utilizes Sinkhorn iteration~\\cite{Sinkhorn13} which performs full normalization on the similarity matrix with GPU acceleration. Moreover, \\ClusterEA{} develops novel batch-sampling methods for adopting the normalization to large-scale datasets with the loss of information being minimized.\n\n\n\n\n\n% \\vspace{-4mm}\n"
            },
            "section 3": {
                "name": "Preliminaries",
                "content": "\n\\label{sec:define}\nWe proceed to introduce preliminary definitions. Based on these, we formalize the problem of entity alignment.\n\n%\\noindent\n%\\textbf{Knowledge Graphs.}\n\\vspace{-2mm}\n\\begin{myDef}\nA \\textbf{knowledge graph} (KG) can be denoted as $G = (E,R,T)$, where $E$ is the set of entities, $R$ is the set of relations, and $T=\\{(h,r,t)~|~h,t \\in E, r \\in R\\}$ is the set of triples, each of which represents an edge from the head entity $h$ to the tail entity $t$ with the relation $r$.\n\\end{myDef}\n\n%\\noindent\n%\\textbf{Entity Alignment.}\n\\vspace{-5mm}\n\\begin{myDef}\n\\label{sec:problem_statement}\n\\textbf{Entity alignment} (EA) \\cite{OpenEA2020VLDB} aims to find the 1-to-1 mapping of entities $\\phi$ from a source KG $G_s = (E_s,R_s,T_s)$ to a target KG $G_t = (E_t,R_t,T_t)$.\nFormally, $\\phi = \\{(e_s, e_t) \\in E_s \\times E_t~|~e_s \\equiv e_t\\}$, where\n$e_s \\in E_s$, $e_t \\in E_t$, and $\\equiv$ is an equivalence relation between $e_s$ and $e_t$.\nIn most cases, a small set of equivalent entities $\\phi^{\\prime} \\subset \\phi$ \\MARK{is known beforehand and} used as seed alignment.\n\\end{myDef}\n %(training data, in other words).\n\n%\\noindent\n%\\textbf{Embedding-based Entity Alignment.}\n\\vspace{-5mm}\n\\begin{myDef}\n\\textbf{Embedding-based EA} aims to learn a set of embeddings for all entities $E_s$ and $E_t$, denoted as $\\mathbf{f}\\in \\mathcal{R}^{(|E_s|+|E_t|)\\times D}$, and then, it tries to maximize the similarity (e.g. cosine similarity) of entities that are equivalent in $\\phi$, where $D$ is the size of embedding vectors.\n\\end{myDef} \n\n"
            },
            "section 4": {
                "name": "Our Framework",
                "content": "\n\\label{sec:framework}\nIn this section, we present our proposed framework \\ClusterEA{}, a novel scalable EA framework. We start with the overall framework, followed by details on each component of our framework.\n\n",
                "subsection 4.1": {
                    "content": "\n\n\n\nAs shown in Figure~\\ref{fig:framewrok}, to scale up GNN training over large-scale KGs, \\ClusterEA{} first utilizes neighborhood sampling~\\cite{GraphSAGE17} to train a large-scale GNN for EA in a stochastic fashion.\nThereafter, \\ClusterEA{} proposes a novel learning-based batch sampling strategy \\Sampling{}. It uses the embedding vectors obtained from stochastic training. In the strategy, two batch samplers that learn multiple aspects of the input KGs are applied to the input KGs, including\n(i) \\MetisGCN{} that aims at retaining the intra-KG graph structure information such as the neighborhood of nodes, and\n(ii) \\KMeans{} that aims at retaining the inter-KG matching information provided by the learned embedding.\nThese methods sample two KGs into multiple mini-batches with a high entity equivalent rate that better satisfies the 1-to-1 mapping assumption.\nFinally, \\ClusterEA{} proposes \\Merging{}, which fuses the normalized local similarity matrices with partially normalized global similarity. The \\Merging{} produces the fused final matrix with high sparsity while keeping as much valuable information as possible.\n\n\\vspace{-3mm}\n"
                },
                "subsection 4.2": {
                    "name": "Stochastic Training of GNNs for EA",
                    "content": "\n\\label{sec:mini-batch-training}\n\nGNN-based methods \\cite{AttrGNN20,KECG19, EVA20, AliNet20, DualAMN21} have dominated the EA tasks with promising performances by propagating the information of seed alignments to their neighbors.\nInspired by this, we propose to incorporate GNN-based models into \\ClusterEA{}.\n\\ClusterEA{} provides a general framework for training a Siamese GNN on both $G_s$ and $G_t$ that all GNN-based EA models follow~\\cite{DualAMN21}. As a result, any existing GNN model can be used in \\ClusterEA{} to produce the structural feature embeddings of entities.\n\nTo scale up the existing GNN-based EA models, \\ClusterEA{} trains the models with neighborhood sampling. We sample mini-batches based on the seed alignment. Specifically, following the negative sampling process, we first randomly select a mini-batch of size $N_p$ containing source and target entities $\\phi_s'$ and $\\phi_t'$ in the seed alignment $\\phi^{\\prime}$ that are equivalent. Then, we randomly sample source and target entities size of $N_n$ with seed alignment in their whole entity sets that does not overlap with selected seed entities, denoted as $\\theta_s = \\{e_s |e_s \\in E_s \\cap e_s \\not\\in \\phi_s'\\}$ and $\\theta_t = \\{e_t |e_t \\in E_t \\cap e_t \\not\\in \\phi_t'\\}$. Finally, a mini-batch $B = \\{B_s, B_t\\} = \\{(\\phi_s' \\cup \\theta_s), (  \\phi_t' \\cup \\theta_t) \\}$ is generated waiting for the GNN model to produce its embeddings.\n\nGenerally, the GNN-based models train the entity's embedding by propagating the neighborhood information~\\cite{RREA20, GCN17, GAT18}.\nFormally, the embedding of an entity $v \\in B$ in the $k_{th}$ layer of GNN $h_v^k$ is obtained by aggregating localized information via\n\n\\vspace{-3mm}\n\\begin{equation}\n\\begin{array}{c}\na_{v}^{(k)}=\\operatorname{Aggregate}^{(k)}(\\left\\{h_{u}^{(k-1)} \\mid u \\in \\mathcal{N}(v)\\right\\}) \\\\\nh_{v}^{(k)}=\\operatorname{Update}^{(k)}(a_{v}^{(k)}, h_{v}^{(k-1)})\n\\end{array}\n\\label{eq:message_passing}\n\\vspace{-1mm}\n\\end{equation}\n% \\begin{gather}%RREA\n% \\bm{h}_{\\mathcal{N}_{e_{i}}^{e}}^{l} \\leftarrow f(\\{\\bm{h}_{e_{k}}^{l}, \\forall e_{k} \\in\\left\\{e_{i}\\right\\} \\cup \\mathcal{N}_{e_{i}}^{e}\\})\\\\\n% \\bm{h}_{e_{i}}^{l+1} \\leftarrow \\sigma(\\bm{W}^{l} \\cdot \\bm{h}_{\\mathcal{N}_{e_{i}}^{e}}^{l})\n% \\end{gather}\n% Here, $f(\\cdot)$ is;\nwhere $h_v^0 \\in \\mathcal{R}^D$ is a learnable embedding vector initialized with Glorot initialization, and \n$\\mathcal{N}(v)$ represents the set of neighboring entities around $v$. The model's final output on entity $e$ is denoted as $\\mathbf{f}_e$. By applying neighborhood sampling, the size of neighborhood in each GNN layer of each entity is limited that no more than a fan out hyperparameter $F$, formally $|\\mathcal{N}(v)|\\leq F$. We place the graph information on CPU memory. When computing one layer of GNN in each batch, the neighbor of entities in current batch is sampled to form a block of graph, the graph information of this block will be transferred to GPU memory, along with the computation graph, making the final loss backward propagated with GPU.\n\nTo maximize the similarities of equivalent entities in each mini-batch, GNN-based EA models often use triplet loss along with negative sampling~\\cite{GCN-Align18, KECG19, RREA20, MRAEA20}. In this paper, the \\emph{Normalized Hard Sample Mining (NHSM)} loss~\\cite{DualAMN21}, an extension for negative sampling that could significantly reduce training epochs, is adopted by us for training large-scale GNNs. We detail how we apply the NHSM loss in Appendix~\\ref{app:nhsm}.\n\n\n\\noindent\n\\textbf{Discussions.}\nDue to the neighborhood sampling process, our stochastic version of EA training will have a certain graph information loss, which is minimized with the randomness of sampling. Recent studies~\\cite{ClusterGCN} have proposed to limit the sampling in small fixed sub-graphs for better training speed, which will further decrease the accuracy.\nLargeEA~\\cite{LargeEA22}, on the other hand, trains multiple GNNs on small batches generated with a rule-based method. Such an approach could fasten the training process. Nonetheless, much of the structure information is lost during partitioning, incurring poor performance. Although LargeEA can scale up the EA models to deal with large-scale datasets, it has too much trade-off on the accuracy, which is unreasonable.\n% $\\mu(e_{i}, e_{j})=\\frac{1}{\\left|E_{2}\\right|} \\sum_{e_{j}^{\\prime} \\in E_{2}} l_{o}(e_{i}, e_{j}, e_{j}^{\\prime})$ and $\\sigma^{2}(e_{i}, e_{j})=\\frac{1}{\\left|E_{2}\\right|} \\sum_{e_{i}^{\\prime} \\in E_{2}}\\left[l_{o}(e_{i}, e_{j}, e_{j}^{\\prime})-\\mu(e_{i}, e_{j})\\right]^{2}$ are the mean and variance of the loss of current batch.\n\n\n% Formally, $\\mathcal{L}=\\sum\\nolimits_{(e_s^{i}, e_t^{i'}) \\in \\phi'} \\left[f_p(\\bm{h}_{e_s^{i}},\\bm{h}_{e_{t}^{i'}}) + \\gamma - f_n(\\bm{h}_{e_s^{i}},\\bm{h}_{e_{t}^{i'}}) \\right]_{+}$.\n% Here,\n% $\\bm{h}_{e_s^{i}}$ and $\\bm{h}_{e_{t}^{i'}}$ represent the embeddings of $e_s^{i}$ and $e_t^{i'}$ learned by a structure-based EA model, respectively;\n% $f_p(\\cdot,\\cdot)$ represents the distance between $\\bm{h}_{{e}_{s}^{i}}$ and $\\bm{h}_{{e}_{t}^{i'}}$;\n% $f_n(\\cdot,\\cdot)$ denotes the distance of a negative entity pair derived from $e_s^{i}$ and $e_t^{i'}$, generated by replacing either $\\bm{h}_{{e}_{s}^{i}}$ or $\\bm{h}_{{e}_{t}^{i'}}$ with a new embedding according to the nearest neighbor sampling~\\cite{RREA20}; $[x]_{+} = max\\{0,x\\}$; and\n% $\\gamma > 0$ is a margin hyper-parameter.\n\n\n% We denote $\\bm{M_s}$ the total structure-based entity similarity matrix, where each value is computed by the Manhattan distance.\n% %\n% %We would like to highlight that\n% $\\bm{M_s}$ is highly sparse.\n% With independent mini-batch training, all non-zero similarity values lie on the diagonal blocks of $\\bm{M_s}$.\n% It saves memory cost for coping with large-scale EA. The memory cost of storing $\\bm{M_s}$ is $\\mathcal{O}(|E_s|)$, i.e., the number of entities in the source KG.\n% The time and space complexities of the entire mini-batch training process are $O\\left (|\\phi'|\\times(|T_s|+|T_t|))$ and $O(|D_{str}|\\times(|E_s| + |E_t|) + |T_s| + |T_t|)$, respectively.\n% Here, $|D_{str}|$ denotes the dimension of every entity embedding learned by the mini-batch training.\n\n% \\vspace{-4mm}\n"
                },
                "subsection 4.3": {
                    "name": "Learning-based Mini-batch Samplers",
                    "content": "\n\n\n% \\begin{figure}[t]\n% % \\vspace*{-18mm}\n% \\centering\n% % \\includegraphics[width=6.2in]{METIS-CPS-example-eps-converted-to.pdf}\n% \\includegraphics[width=3.5in]{figs/cluster_sampler-eps-converted-to.pdf}\n% \\vspace*{-2mm}\n% \\caption{A toy example of \\Sampling{} workflow.}\n% \\label{fig:metis-cps}\n% % \\vspace*{-2mm}\n% \\end{figure}\nAfter obtaining the KG embeddings, we aim to build batch samplers that utilize the features learned by EA models for generating mini-batches with high entity equivalent rates. To this end, we present the \\Sampling{} strategy, which first \\emph{clusters} the training set for obtaining batch labels, and then fits a \\emph{classification} model with train labels to put all the entities into the right batch. The two models must satisfy two rules: (i) \\emph{scalability} that both the classification and clustering method should be able to apply on large-scale data; and (ii) \\emph{distinguishability} that the classifier must be able to distinguish entities into different labels the clustering method provides. If the \\emph{scalability} rule is not satisfied, the model will crash due to limited computing resources. If the \\emph{distinguishability} rule is not satisfied, the model cannot produce reasonable output. For example, if we randomly split the train set, there is no way for any model to classify the entities with such a label. Following the two rules, by changing different clustering and classification methods, we propose two batch samplers capturing different aspects of information in the two KGs. Each of them produces a set\ncontaining $K$ batches, where $K$ is a hyperparameter. Intuitively, larger $K$ would result in smaller batches, making the normalization process consumes less memory. However, it also makes the \\Sampling{} process more difficult. We detail the effect of different $K$ on the accuracy of \\Sampling{} in Section~\\ref{sec:exp_minibatchgeneration}.  To distinguish the batches from batches in Section~\\ref{sec:mini-batch-training}, the batches are denoted as $\\mathcal{B} = \\{(\\mathcal{B}_s, \\mathcal{B}_t)\\}$, where $\\mathcal{B}_s \\subset E_s$ and $\\mathcal{B}_t \\subset E_t$ are the sets of source and target entities respectively for each batch. \n\n\n\\noindent\n\\textbf{Mini-batch sampling with Intra-KG information.} In the \\Sampling{} strategy, we first present  \\MetisFullName{} (\\MetisGCN{}) for sampling batches based on learning neighborhood information of KGs. Following the  \\emph{distinguishability} rule, for retaining the neighborhood information, the clustering method should put nodes that are neighbors into the same batch. This brings us to minimize the edge cut. A previous study proposes METIS-CPS~\\cite{LargeEA22}, which clusters two KGs with METIS~\\cite{METIS98}, a classic algorithm to partition large graphs for minimizing the edge cut. METIS-CPS is designed to minimize both the edge cuts of two KGs and the decrease of entity equivalent rate. It first clusters source KG with METIS, and then clusters target KG with higher weights set for train nodes guiding the METIS algorithm. However, the METIS algorithm on the target KG is also a clustering algorithm, thus does not necessarily follow the guidance of train nodes. Following the \\Sampling{} strategy, \\MetisGCN{} also adopts METIS for \\emph{clustering} source KG, but trains a GNN~\\cite{GCN17} for \\emph{classifying} target KG. The labels provided by METIS will keep nodes that neighbor together as much as possible, and thus can be learned with neighborhood propagation of GNNs. The training and inference on target KG could follow standard node classification task settings. For scalability consideration, we adopt the classic GCN as the classification model. We use the learned embeddings $\\mathbf{f}$ of the EA model as the input feature and cross-entropy as the learning loss to train a two-layer GCN. Since GCN does not recognize different relation types in KGs, we adopt the computation of weights in the adjacency matrix from GCNAlign~\\cite{GCN-Align18} to convert triples with different relation types into different edge weights. We detail the adjacency matrix construction in Appendix~\\ref{app:adj-matrix}.\n\n\\noindent\n\\textbf{Mini-batch sampling with Inter-KG information.} Recall that the cross-KG mapping information is learned into two sets of embeddings $\\mathbf{f}_s$ and $\\mathbf{f}_t$, partitioning based on these embeddings could preserve the mapping information as much as possible. We propose \\KMeansFullName{} (\\KMeans{}) for partitioning directly based on the embedding vectors.\nFor obtaining labels of training sets, in \\emph{clustering} process of \\KMeans{}, we adopt the K-Means algorithm, a widely-used and scalable approach to cluster embeddings in high-dimensional vector spaces.\nK-Means may lead to the entities unevenly distributed in different batches. To reduce this effect and to obtain more balanced mini-batches, we normalize the entity features with the standard score normalization. We concatenate the normalized embeddings of the training set into one unified set of embeddings. Then, we cluster the embeddings to obtain the labeled batch number for the training set $C'$. Formally, \n$C'_{e_s} = C'_{e_t} = \\operatorname{k-Means}(\\mathbf{f}_{n}(e_s,e_t), K), \\; (e_s, e_t) \\in \\phi'$, $\\mathbf{f}_{n}(e_s,e_t)= [\\operatorname{z-score}(\\mathbf{f}_{e_s})||\\operatorname{z-score}(\\mathbf{f}_{e_t})]$, \n% \\vspace{-5mm}\n% \\begin{equation}\n% \\begin{array}{c}\n%     C'_{e_s} = C'_{e_t} = \\operatorname{k-Means}(\\mathbf{f}_{n}(e_s,e_t), K), \\; (e_s, e_t) \\in \\phi'\\\\\n%     \\mathbf{f}_{n}(e_s,e_t)= [\\operatorname{z-score}(\\mathbf{f}_{e_s})||\\operatorname{z-score}(\\mathbf{f}_{e_t})]\n% \\end{array}\n% % \\vspace{-2mm}\n% \\end{equation}\nwhere $\\operatorname{z-score}(X)=  \\frac{X - \\mu(X)}{\\sigma(X)}$ is the standard score normalization.\n\nNext, we use the label to train two classifiers for both $E_s$ and $E_t$, and predict on all the embeddings. We describe how to obtain the batch number of each entity as follows: $C_{E_s} = \\{ \\operatorname{clf}(\\mathbf{f}_{\\phi'_s}, C'_{\\phi'_s}, \\mathbf{f}_{e_s}) \\;|\\; e_s \\in E_s \\}$ and $\n    C_{E_t} = \\{ \\operatorname{clf}(\\mathbf{f}_{\\phi'_t}, C'_{\\phi'_t}, \\mathbf{f}_{e_t}) \\;|\\; e_t \\in E_t \\}$, \n% \\MARK{fix equation here}\n% !TODO fix eq\n% \\vspace{-2mm}\n% \\begin{equation}\n% \\begin{array}{c}\n%     C_{E_s} = \\{ \\operatorname{clf}(\\mathbf{f}_{\\phi'_s}, C'_{\\phi'_s}, \\mathbf{f}_{e_s}) \\;|\\; e_s \\in E_s \\}\\\\\n%     C_{E_t} = \\{ \\operatorname{clf}(\\mathbf{f}_{\\phi'_t}, C'_{\\phi'_t}, \\mathbf{f}_{e_t}) \\;|\\; e_t \\in E_t \\}\n% \\end{array}\n% \\end{equation}\nwhere $\\operatorname{clf}(\\mathbf{f}_{train}, C_{train}, \\mathbf{f})$ denotes the classification model. It trains based on the training set embedding $\\mathbf{f}_{train}$ and label $C_{train}$, and then, it predicts the class for embedding $\\mathbf{f}$. In this paper, we use XGBoost Classifier~\\cite{XGBoost16}, a scalable classifier that has been a golden standard for various data science tasks. After classification, we can easily obtain the batches with the label $C$.\n\n"
                },
                "subsection 4.4": {
                    "name": "Fusing Local and Global Similarities",
                    "content": "\n\nSince the \\Sampling{} strategy utilizes different aspects of information to learn the mini-batches, the mini-batch similarity matrices generated may be biased by the corresponding batch sampler. For example, \\KMeans{} only relies on the embeddings, tending to put entities with similar embeddings together. This information bias may have a negative effect on the final accuracy. To avoid such bias as much as possible, we propose \\Merging{}. It first applies Sinkhorn iteration on mini-batch similarity matrices generated by multiple batch samplers. Then, \\Merging{} sums all the similarity matrices of generated batches to obtain a fused local similarity matrix. Finally, it further fuses the local similarity matrix with a partially normalized global similarity based on a newly proposed sparse version of CSLS~\\cite{CSLS}, namely, \\SparseCSLS{}.\n\n\n\\noindent\n\\textbf{Local Similarity Matrix Normalization.}\n\\label{sec:normalize-local-sim}\nPrevious section describes how to sample the input KGs into multiple batches. For each batch generated from a batch-sampler $\\mathcal{B}^i \\in \\mathcal{B} = \\{\\mathcal{B}^i_s, \\mathcal{B}^i_t\\}, i \\in K$,  we assume that there exists 1-to-1 mapping between the source and target entities. We first obtain the local similarity matrix $\\mathcal{M}^i\\in \\mathcal{R}^{|E_s|\\times|E_t|}$ of current batch.\nFormally,\n\n% \\vspace{-3mm}\n\\begin{equation}\n   \\mathcal{M}^i_{e_s, e_t}  =\n    \\begin{cases}\n      \\operatorname{sim}(e_s, e_t) & \\text{if $e_s \\in \\mathcal{B}^i_s$ and $e_t \\in \\mathcal{B}^i_t$}\\\\\n      0 & \\text{otherwise}\n    \\end{cases}\n\\end{equation}\n% \\vspace{-2mm}\n% $\\mathcal{M}^i_{e_s, e_t} = \\operatorname{sim}(e_s, e_t)$, $e_s \\in \\mathcal{B}^i_s$ $e_t \\in \\mathcal{B}^i_t$.\nwhere $\\operatorname{sim}(e_{s}, e_{t})= \\mathbf{h}_{e_s} \\cdot \\mathbf{h}_{e_t}$ is the similarity of two entities obtained with the GNN output feature.\n\nThen, we follow~\\cite{Sinkhorn13} to implement the Sinkhorn iteration. We iteratively normalize the similarity matrix $K_s$ rounds in each batch, converting the similarity matrix into a doubly stochastic matrix.\nThe entities of mini-batches in one graph do not have overlap with each other, meaning that there will be no overlapped values in all the mini-batch similarities. Therefore, to obtain the locally normalized similarity for the whole dataset, we directly sum up all the mini-batch similarities, denoted as $\\mathcal{M} = \\sum_{i \\in K} \\operatorname{Sinkhorn} (\\mathcal{M}^i, K_s) \\in [0,1] ^{|E_s|\\times|E_t|}$.\n% \\begin{equation}\n%     \\hat{\\mathcal{M}}^i = \\operatorname{Sinkhorn} (\\mathcal{M}^i, K_i)\n% \\end{equation}\n\n\\noindent\n\\textbf{Fusing multi-aspect local similarities.}\nTo avoid the bias from one batch sampler, we calculate multiple similarity matrices as described above with different batch samplers. We obtain the cross-KG information-based similarity $\\mathcal{M}_C$ with \\KMeans{}, and intra-KG information-based similarity $\\mathcal{M}_I$ with \\MetisGCN{}.\nSince the \\MetisGCN{} process is unidirectional, indicating that this process on $G_s \\rightarrow G_t$ produces different result with $G_t \\rightarrow G_s$. According to this characteristic, we apply \\MetisGCN{} on both direction, resulting into two matrices $\\mathcal{M}_{I, G_s\\rightarrow G_t}$ and $\\mathcal{M}_{I, G_t\\rightarrow G_s}$. Following~\\cite{CEAFF20}, we sum up all the similarity matrices without setting any weight to obtain the final local similarity matrix. Formally, $ \\mathcal{M}_{L} = \\mathcal{M}_C + \\mathcal{M}_{I, G_s\\rightarrow G_t}+ \\mathcal{M}_{I, G_t\\rightarrow G_s}^T$.\nThis simple approach of fusing multi-view similarity matrices is proved to be useful in various previous studies~\\cite{CEAFF20, CEAFF21, EASY21, LargeEA22}.\n\n\\noindent\n\\textbf{Normalize global similarity with \\SparseCSLS{}.} To fuse the normalized local similarity matrix $\\mathcal{M}_{L}$ with the global similarity, we first obtain the global similarity, and normalize it partially.\nA widely-used normalization approach for solving geometric problems is to apply CSLS~\\cite{CSLS} on the similarity matrix.\nFormally, for two entities $e_s$ and $e_t$,\n$\\operatorname{CSLS}(e_s, e_t) = 2\\operatorname{sim}(e_s, e_t) - r_S(e_t) - r_T(e_s)$, where $r_S$ and $r_T$ are the nearest neighborhood similarity mean, which can be obtained by k-NN search with $K_n$ as the neighborhood size.\n\n% \\begin{align}\n%     \\operatorname{CSLS}(x_{s}, y_{t}) =2 \\operatorname{sim} (x_{s}, y_{t})-r_{T}( x_{s})-r_{S}(y_{t})\n% \\end{align}\n% where $r_{T}(x_{s}) =\\frac{1}{K} \\sum_{y \\in N_{T}( x_{s})} \\operatorname{sim} (x_{s}, y_{t})$ is used to denote the mean neighborhood similarity, the $r_T$.\n% on this bi-partite graph, associated with a mapped source word embedding Wxs. All K elements of NT(Wxs) are words from the target language.\n% \\begin{align}\n    %  r_{T}(x_{s}) =\\frac{1}{K} \\sum_{y \\in N_{T}( x_{s})} \\operatorname{sim} (x_{s}, y_{t})\n% \\end{align}\n\n% Similarly we denote by NS(yt) the neighborhood associated with a word t of the target language. Consider the mean similarity of a source embedding xs to its target neighborhood as\nHowever, CSLS also lack scalability, which motivates us to propose a sparse version of CSLS, i.e., \\SparseCSLS{}. Recent studies~\\cite{LargeEA22, NoMatch21} apply FAISS~\\cite{JDH17} to compute K-nearest neighbours of $E_s$ on the embedding space $\\mathbf{h}_t$. Similar to the dense version of CSLS, \\SparseCSLS{} normalizes a sparse similarity matrix, resulting in a partially normalized similarity matrix. It first uses FAISS to calculate mean neighborhood similarities  $r_{T}( x_{s})$ and $r_{S}(y_{t})$. Then, for a sparse matrix $\\mathcal{M}$, the \\SparseCSLS{} only subtracts nonzero values of $2 \\mathcal{M}$ with $r_{T}( x_{s})$ and $r_{S}(y_{t})$, the result is denoted as $\\mathcal{M}'$. To keep the nonzero values to be useful, the final output is normalized with min-max normalization. Formally, $\\operatorname{Sp-CSLS}(\\mathcal{M}) =\\frac{ \\mathcal{M}' - \\operatorname{min}(\\mathcal{M}')}{ \\operatorname{max}(\\mathcal{M}') - \\operatorname{min}(\\mathcal{M}')}$.\n\nTo obtain the normalized global similarity. We first utilize FAISS to obtain an initial global similarity matrix by fusing k-NN similarity matrices on both $\\mathbf{f}_s \\rightarrow \\mathbf{f}_t$ and $\\mathbf{f}_t \\rightarrow \\mathbf{f}_s$ directions. Next, we normalize it with \\SparseCSLS{}. Formally, $\\mathcal{M}_{G} = \\operatorname{Sp-CSLS}(\\operatorname{k-NN}(\\mathbf{h}_s, \\mathbf{h}_t,K_r) + \\operatorname{k-NN}(\\mathbf{h}_t, \\mathbf{h}_s,K_r)^T, K_n)$, where $\\operatorname{k-NN}(\\mathbf{X}, \\mathbf{Y},K_r)$ returns the similarity matrix of $\\mathbf{X} \\rightarrow \\mathbf{Y}$ remaining only top-$K_r$ values, and $K_n$ is the neighborhood size for CSLS. Note that the sparse similarity of two directions may have some values overlapped, this overlapped values will become twice the value before. However, it will hardly have negative impact on accuracy since entity pairs that both have high ranking on the another KG are more possible to be correctly aligned~\\cite{MRAEA20}.\n\n\\noindent\n\\textbf{Fusing normalized similarities.}\nTo obtain the fused final similarity matrix, we first fuse the global and local similarities, and then apply the \\SparseCSLS{} for further normalization on the final matrix. Formally, $\\mathcal{M}_{F}=\\operatorname{Sp-CSLS}( \\mathcal{M}_L +\\mathcal{M}_G, K_n)$.\n\n\n\n\n\n\n\n\n% \\vspace{-10mm}\n"
                }
            },
            "section 5": {
                "name": "Experiments",
                "content": "\n\\label{sec:exp}\n\nIn this section, we report on extensive experiments aimed at evaluating the performance of  \\ClusterEA{}.\n\n\\vspace{-2mm}\n",
                "subsection 5.1": {
                    "name": "Experimental Settings",
                    "content": "\\label{sec:exp_setting}\n\n\\noindent\n\\textbf{Datasets.}\nWe conduct experiments on datasets with different sizes from two cross-lingual EA benchmarks, i.e., IDS~\\cite{OpenEA2020VLDB} and DBP1M~\\cite{LargeEA22}.\n\\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt,partopsep=0pt,leftmargin=*]\n\\item\n\\emph{IDS} contains four cross-lingual datasets, i.e., English and French (IDS15K$_{EN-FR}$ and IDS100K$_{EN-FR}$), and English and German (IDS15K$_{EN-DE}$ and IDS100K$_{EN-DE}$). \\MARK{These benchmarks are sampled with consideration of keeping the properties (e.g., degree distribution) consistent with their source KGs.} We use the latest 2.0 version of IDS, where the URIs of entities are encoded to avoid possible name bias.\n\\item \\emph{DBP1M} is the largest cross-lingual EA benchmark. It contains two large-scale datasets extracted from DBpedia~\\cite{DBPedia}, i.e., English and French (DBP1M$_{EN-FR}$), and English and German (DBP1M$_{EN-DE}$).\nHowever, DBP1M is biased with name information. Specifically, part of the entities in inter-language links (ILLs) does not occur in the two KGs. Thus, we remove those ILLs to solve the name bias issue while retaining all the triples.\n\\end{itemize}\n\nFollowing previous studies, we use 30\\% of each dataset as seed alignment, and use 70\\% of it to test the EA performance. As can be seen, we consider both degree distribution issue~\\cite{RSN19, OpenEA2020VLDB} and the name bias issue~\\cite{AttrGNN20} when selecting benchmarks, which meets the requirements of real-world applications.\nTable \\ref{tb:dataset} in Appendix~\\ref{app:dataset-stat} lists the detailed information of the datasets used in our experiments.\n\n\\noindent\n\\textbf{Evaluation metrics.}\nWe use the widely-adopted \\HitNFull{} (\\HitN{}) and Mean Reciprocal Rank (\\MRR{}) to verify the accuracy of \\ClusterEA{}~\\cite{MTransE17,IPTransE17, GCN-Align18, KECG19, RREA20, DualAMN21, EASY21}. Here, for \\HitN{}, $N$=1, 10.\nHigher \\HitN{} and \\MRR{} indicate better performance.\nAlso, we use running time and maximum GPU Memory cost (\\emph{Mem.}) to evaluate the scalability of \\ClusterEA{}. Specifically, running time is measured in seconds, and \\emph{Mem.} is measured in Gigabytes.\n% following ~\\cite{LargeEA22}, running time (in seconds), and the maximum GPU Memory cost (\\emph{Mem.} for short, in Gigabytes) are included for evaluating the scalability of \\ClusterEA{}.\n% Here, the running time means the training time of every EA approach.\n% We do not consider the test time. Specifically, it is common for EA methods to use the same approach for evaluating the EA results in the test set, resulting in the similar test time of different approaches.\n\n\\noindent\n\\textbf{Baselines.}\n\\MARK{\nWe compare \\ClusterEA{} with structure-only based methods. If a baseline includes side information components, we remove them in order to guarantee a fair comparison\n~\\cite{DualAMN21, EVA20, RREA20, HyperKA20, OpenEA2020VLDB, LargeEA22}.  All the baselines are enhanced with CSLS (\\SparseCSLS{} for large-scale datasets) before evaluation if possible. The implementation details and parameter settings of \\ClusterEA{} and all baselines are presented in Appendix~\\ref{app:details}.\n% We divide the compared baselines into two major categories :\n% (i) \\emph{Non-scalable} ones including GCNAlign, RREA, and Dual-AMN; (ii) \\emph{Scalable} ones indicating other baselines mentioned above.\nConsidering the scalability of models, we divide the compared baselines into two major categories, as listed below:\n% We compare \\ClusterEA{} with the following representative EA models.\n% \\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt,partopsep=0pt,leftmargin=*]\n%     \\item  \\emph{GCNAlign}~\\cite{GCN-Align18}: it is the first GNN based EA model. We re-implement GCNAlign by removing attribute features (as the side information component) from it.\n%     \\item \\emph{LargeEA}~\\cite{LargeEA22}: it is the first EA framework that focuses on scalability by training multiple EA models on mini-batches generated by a rule-based strategy. We reproduce LargeEA by removing the name channel entirely, including the name-based data augmentation. Excepted for the two variants introduced in~\\cite{LargeEA22},\n%     we provide a new variant \\emph{LargeEA-D} that incorporates recently proposed EA model Dual-AMN.\n%     \\item \\emph{RREA}~\\cite{RREA20}: it is a GNN-based EA model that leverages relational reflection transformation to obtain relation-specific embeddings for each entity. It is used as the default of LargeEA~\\cite{LargeEA22}.\n%     \\item \\emph{Dual-AMN}~\\cite{DualAMN21}: it is a SOTA EA model that encomprasses  Simplified Relational Attention Layer and Proxy Matching Attention Layer for modeling both intra-graph and cross-graph relations.\n%     \\item \\emph{Stochastic training (Section~\\ref{sec:mini-batch-training}) variant of GNN models}, that incorporates EA models with Stochastic training, including \\emph{GCNAlign-S} for GCNAlign~\\cite{GCN-Align18}, \\emph{RREA-S} for RREA~\\cite{RREA20} and \\emph{Dual-AMN-S} for Dual-AMN~\\cite{DualAMN21}.\n% \\end{itemize}\n\\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt,partopsep=0pt,leftmargin=*]\n    \\item \\emph{Non-scalable baselines} that includes\n            (i) \\emph{GCNAlign}~\\cite{GCN-Align18}, the first GNN-based EA model;\n            (ii) \\emph{RREA}~\\cite{RREA20}, a GNN-based EA model that utilizes relational reflection transformation to obtain relation-specific embeddings for each entity, and is used as the default of LargeEA~\\cite{LargeEA22}; and\n            (iii) \\emph{Dual-AMN}~\\cite{DualAMN21}, a SOTA EA model that contains Simplified Relational Attention Layer and Proxy Matching Attention Layer for modeling both intra-graph and cross-graph relations.\n    \\item \\emph{Scalable baselines} that includes\n            (i) \\emph{LargeEA}~\\cite{LargeEA22}, the first EA framework that focuses on scalability by training multiple EA models on mini-batches generated by a rule-based strategy, and excepting for the two variants presented in~\\cite{LargeEA22},\n            we provide a new variant \\emph{LargeEA-D} that incorporates recently proposed EA model Dual-AMN; and\n            (ii) \\emph{Stochastic training (Section~\\ref{sec:mini-batch-training}) variant of GNN models}, which incorporates EA models with Stochastic training, including \\emph{GCNAlign-S} for GCNAlign~\\cite{GCN-Align18}, \\emph{RREA-S} for RREA~\\cite{RREA20}, and \\emph{Dual-AMN-S} for Dual-AMN~\\cite{DualAMN21}.\n\\end{itemize}\n}\n\n\n\\noindent\n\\textbf{Variants of \\ClusterEA{}.}\nSince \\ClusterEA{} is designed to be integrated with GNN-based EA models, we present three versions of \\ClusterEA{}, i.e.,  \\ClusterEA{-G} that includes GCNAlign, \\ClusterEA{-R} that incorporates RREA, and  \\ClusterEA{-D} that incorporates Dual-AMN. Specifically, we treat \\ClusterEA{-D} as the default setting.\n% \\MARK{Our current implementation includes three representative GNN-based EA models, including (i) GCN-Align~\\cite{GCN-Align18}, the first GNN-based EA model; (ii) RREA~\\cite{RREA20}, which is adopted by the first scalable EA framework LargeEA~\\cite{LargeEA22}; and (iii) Dual-AMN~\\cite{DualAMN21}, current state-of-the-art structure-only EA model.}\n\n\\vspace*{-3mm}\n"
                },
                "subsection 5.2": {
                    "name": "Overall Results",
                    "content": "\n\n\\noindent\n\\textbf{Performance on IDS.}\\label{sec:exp_ids}\nTable~\\ref{exp:overall_15K_100K} summarizes the EA performance on IDS15K and IDS100K.\n% \\noindent\n% \\textbf{Accuracy Evaluations.}\n% We first focus on the \\textbf{accuracy} for all the variants of \\ClusterEA{} and its competitors.\nFirst,  \\ClusterEA{} improves \\HitOne{} by   $3.3\\%-29.7\\%$ compared with the non-scalable methods (viz., GCNAlign, RREA, and Dual-AMN), and by $3.2\\%-42.3\\%$ compared against the scalable ones. They validate the accuracy of \\ClusterEA{}.\n% 3.3 29.7 4.7 37.9\n% 4.0 20.8 3.2 39.2\n% 4.9 24.3 6.0 34.7\n% 4.4 22.7 4.9 42.3\n%\nMoreover, all variants of \\ClusterEA{} perform better than the structure-only based models in terms of \\HitOne{}. It confirms the superiority of the way how we enhance the output, compared with CSLS that is the default setting for most recent EA models~\\cite{EVA20,EASY21, MRAEA20,RREA20, OpenEA2020VLDB, DualAMN21} to enhance the output similarity matrix.\nSecond, it is observed that the accuracy of LargeEA variants is significantly reduced compared with their corresponding original models. This is because LargeEA discards structure information during its mini-batch training process. Unlike the LargeEA variants, the accuracy of Stochastic Training variants only drops slightly compared to the original non-scalable models. This shows that the Stochastic training process can minimize the structure information loss (cf. Section~\\ref{sec:mini-batch-training}).\nThird, as observed,  \\HitTen{} of some non-scalable models (RREA, Dual-AMN) is higher than that of \\ClusterEA{}. This is mainly due to (i) the information loss during \\ClusterEA{}'s Stochastic training and (ii) the incompleteness of global similarity normalization (to be detailed in Section~\\ref{sec:ablation}). Nevertheless, \\HitOne{} is the most representative indicator for evaluating the accuracy of EA since higher \\HitOne{} directly indicates more correct proportion of aligned entities. Thus, achieving the highest \\HitOne{} among all the competitors is sufficiently to demonstrate the high performance of \\ClusterEA{}.\n%considering that \\HitOne{} represents the correct proportion of aligned entities, it is the most representative indicator for evaluating the accuracy. It would be an acceptable trade-off for better \\HitOne{}.\nFinally, the experimental results show that the training of all LargeEA variants is faster than that of other variants of the corresponding models. The reason is that LargeEA omits most information of graph structure, where less data is subjected to the training process. However, in this case, the running time of \\ClusterEA{} is still comparable.\n\n\n\\noindent\n\\textbf{Performance on DBP1M.}\nTable~\\ref{exp:overall_1M} reports the EA performance of \\ClusterEA{} and its competitors on DBP1M. Note that we do not report the results of the non-scalable models because it is infeasible to perform their training phases on DBP1M due to large GPU memory usage.\nWe observe that the accuracy of all the variants of \\ClusterEA{} on DBP1M  is higher than those of LargeEA. Specifically, \\HitOne{} is improved by $5.7\\%-23.0\\%$ and $6.8\\%-25.4\\%$ on DBP1M$_{EN-FR}$ and DBP1M$_{EN-DE}$, respectively.\n% G 4.0 2.4\n% R 4.9 4.5\n% D 5.7 6.8\nNext, \\MARK{compared with each Stochastic training variants of the corresponding incorporated model of \\ClusterEA{}, \\ClusterEA{} brings about $4.0\\%-5.7\\%$ and $2.4\\%-6.8\\%$ absolute improvement in \\HitOne{} on DBP1M$_{EN-FR}$ and DBP1M$_{EN-DE}$ datasets, respectively. As the expressiveness of the model improves, \\ClusterEA{} also offers more improvement.\n% Moreover, as observed, \\ClusterEA{} is able to outperform baselines without using GNN model.\n% This is because \\ClusterEA{} optimizes the similarity computation via proposing a novel similarity matrix.\n}\n%This validates the importance of enhancing the similarity matrix and the superiority of the way of \\ClusterEA{} enhancing the similarity matrix.\n% Since the Stochastic training variants are treated as a sub-module in \\ClusterEA{}.\nLast, all the scalable variants incorporating GCNAlign variants produce poor EA results. Specifically, GCNAlign's model cannot be directly applied to large-scale datasets due to its insufficient expressive ability. \\MARK{Note that \\ClusterEA{} not only outperforms baselines in terms of accuracy but also achieves comparable performance with them in terms of both Mem. and running time.}\n\\MARK{Overall, \\ClusterEA{} is able to scale-up the GNN-based EA models while enhancing \\HitOne{} by at most $8\\times$\n%the\n%not only successfully scale-up the GNN-based EA models but also enhance the performance with up to $8\\times$ improvement in terms of \\HitOne{}\ncompared with the state-of-the-arts. More experimental results of scalability are provided in  Appendix~\\ref{app:scalability}.}\n\n\n\\vspace*{-3mm}\n\n\n% \\vspace{-1mm}\n"
                },
                "subsection 5.3": {
                    "name": "Ablation Study",
                    "content": "\\label{sec:ablation}\nIn ablatoin study, we remove\neach component of \\ClusterEA{}, and report \\HitOne{}, \\HitTen{}, and \\MRR{} in Table~\\ref{exp:abl}.\n%conduct ablation studies on both DBP1M$_{EN-FR}$ and  DBP1M$_{EN-DE}$ and report the results in Table~\\ref{exp:abl}.\n%from IDS and DBP1M benchmarks respectively,\n%We report \\HitOne{}, \\HitTen{}, and $MRR$ after removing each component of \\ClusterEA{}.\nFirst, after removing the \\SparseCSLS{} component, the accuracy of \\ClusterEA{} drops. This shows that the \\SparseCSLS{} normalization indeed address the geometric problems of global similarity on large-scale EA.\nSecond, after removing the global similarity, \\HitOne{} of \\ClusterEA{} drops but \\HitTen{} grows on DBP1M$_{EN-FR}$. The fluctuation on \\HitTen{} may be due to the incompleteness of global similarity normalization\nthat disturbs the final similarity matrix.\nSpecifically,\nthe local similarity is normalized into nearly permutation matrices with Sinkhorn iteration, where most values of one row are close to zero.\nWhen fusing local and global similarity matrices, elements that are not top-1 in the local matrix will be biased towards the value of the global matrix, which is only partially normalized.\nThis causes the disturbance.\nHowever,\nthe incompleteness of normalization does not degrade \\HitOne{}. This is because the value of one row in $\\mathcal{M}_{L}$ that is correctly aligned will be normalized into a higher value, providing resistance to the global matrix disturbance.\nThird, after removing the Sinkhorn iteration,  the accuracy of \\ClusterEA{} drops significantly. This confirms the importance of normalizing the similarity matrices. Finally, after removing each sampler of \\Sampling{}, the accuracy of \\ClusterEA{} drops on all metrics. This validates the importance of fusing information from multi-aspects, including cross-KG information and intra-KG information.\nIn addition, we observe that \\KMeans{} has less influence compared with \\MetisGCN{}. This is mainly due to the following two reasons. First, \\KMeans{} generally clusters entities with similar embedding vectors, where each batch still suffers from geometric problems. On the contrary,  \\MetisGCN{} samples batches based on the graph neighborhood information, which is a strong constriction on the learning model. Second, we apply \\MetisGCN{} in both directions. In this case, it can capture more information than \\KMeans{}.\nBy replacing its Dual-AMN model with the GCNAlign model, the accuracy of \\ClusterEA{} drops significantly on all metrics. This demonstrates the importance of the ability of the incorporated EA model in \\ClusterEA{}.\n\n\\vspace{-4mm}\n"
                },
                "subsection 5.4": {
                    "content": "\n\\label{sec:exp_minibatchgeneration}\n\nThe \\Sampling{} is a vital component of \\ClusterEA{}. To ensure scalability, we set the batch number $K$ such that the space cost of the normalization process does not exceed the GPU memory. We also need to guarantee that our batch sampling method can produce acceptable mini-batches under different $K$ settings.\nThus, we provide a detailed analysis on varying the batch number $K$ for different batch samplers from \\Sampling{} (i.e., \\MetisGCN{} and \\KMeans{}). Specifically, we study how much are the mini-batches generated by one sampler acceptable as the percentage of equivalent entities that are placed into the same mini-batches (denoted as \\textit{Overlap}).\nNext, we report the Overlap metric and running time of the proposed sampler, where the mini-batch number $K$ of the proposed sampler is varied from 5 to 25 on IDS and is varied from 10 to 50 on DBP1M. We compare the proposed sampler with two rule-based baselines, VPS and METIS-CPS. \\emph{VPS} randomly partitions seed alignments and all other entities into different mini-batches. \\emph{METIS-CPS} sets the training entities with higher nodes to sample better mini-batches.\nNote that both METIS-CPS and \\MetisGCN{} are unidirectional. Thus, we apply these methods in both directions, and present their average performance of the two directions. We report the overlap of all sampling methods on all benchmarks in Fig~\\ref{fig:partition-exp}, where Figures~\\ref{fig:partition-k-small-fr},~\\ref{fig:partition-k-medium-fr},~\\ref{fig:partition-k-large-fr},~\\ref{fig:partition-k-small-de}, ~\\ref{fig:partition-k-medium-de}, and~\\ref{fig:partition-k-large-de} are the overlap of different datasets. The results show that \\KMeans{} generally outperforms two baselines on all the datasets, and its performance is stable when varying $K$. However, although it is better overlapped, it may incur hubness and isolation problems in mini-batches (cf. Section~\\ref{sec:ablation}). Thus, fusing multi-aspect is essential for \\ClusterEA{}. \\MetisGCN{} results in less overlapped mini-batches while still much better than METIS-CPS. This is because METIS does not necessarily follow the guidance provided by METIS-CPS. The GNN node classification model in \\MetisGCN{}, which considers the cross-entropy loss as a penalty, is forced to learn mini-batches more effectively. Since we set the training ratio to 30\\%, all samplers have an overlap over 30\\%, including VPS that splits mini-batches randomly.\nFinally, we report the running time on DBP1M in Figures~\\ref{fig:scalability-p-fr} and~\\ref{fig:scalability-p-de}. Since all samplers achieve sufficiently high efficiency on IDS datasets, we do not present the running time of all samplers on IDS due to space limitation. It is observed that, although the result is unacceptable, VPS is the fastest sampling method. Both the proposed \\MetisGCN{} and \\KMeans{} are always about $2\\times$ faster than the rule-based METIS-CPS when changing $K$. The reason is that both of them utilize machine learning models that can be easily accelerated with GPU.\n\n\n\n\n\n\n\\vspace{-2mm}\n"
                }
            },
            "section 6": {
                "name": "Conclusions",
                "content": "\n\\label{sec:conclusions}\n\nWe present \\ClusterEA{} to align entities between large-scale knowledge graphs with stochastic training and normalized similarities.\n\\ClusterEA{} contains three components, including stochastic training, \\Sampling{}, and \\Merging{}, to perform large-scale EA task based solely on structure information.\nWe first train a large-scale Siamese GNN for EA in a stochastic fashion to produce entity embeddings. Next, we propose a new \\Sampling{} strategy for sampling highly overlapped mini-batches taking advantage of the trained embeddings. Finally, we present a \\Merging{} process, which first normalizes local and global similarities and then fuses them to obtain the final similarity matrix. The whole process of \\ClusterEA{} guarantees both high accuracy and comparable scalability.\nConsiderable experimental results on EA benchmarks with different scales demonstrate that \\ClusterEA{} significantly outperforms previous large-scale EA study. In future, it is of interest to explore dangling settings~\\cite{NoMatch21} of EA on large scale datasets. \n\n\\vspace{-2mm}\n"
            },
            "section 7": {
                "name": "Acknowledgements",
                "content": "\nThis work was supported in part by the National Key Research and Development Program of China under Grant No. 2021YFC3300303, the NSFC under Grants No. (62025206, 61972338, and 62102351), and the Zhejiang Provincial Natural Science Foundation under Grant No. LR21F020005. Lu Chen is the corresponding author of the work.\n\n\\vspace{-2mm}% \\input{main.bbl}\n\\bibliographystyle{ACM-Reference-Format}\n\\bibliography{REFER}\n\\pagebreak\n\\begin{appendices}\n\n\n\\section{Normalized Hard Sample Mining Loss}\n\\label{app:nhsm}\nWe detail the NHSM loss used in our work here.\n Formally, for the current mini-batch, the training loss is defined as\n\\begin{equation}\n     L = LogSumExp(\\lambda z(e_s, e_t)) + LogSumExp(\\lambda z(e_t, e_s)) \n\\end{equation} \n, where $e_s \\in B_s$, $e_t \\in B_t$, $(e_s, e_t) \\in \\phi^{\\prime}$\n, and\n$LogSumExp(X) = log(\\sum_{x \\in X}e^x)$\nis an operator to smoothly generate hard negative samples,\n$\\lambda$ is the smooth factor of $LogSumExp$, and \n% This loss introduces a normalize function $l_n(e_{i}, e_{j}, e_{j}^{\\prime})$, defined as follows. Formally,\n% $l_{n}(e_{i}, e_{j}, e_{j}^{\\prime})=\\frac{l_{o}(e_{i}, e_{j}, e_{j}^{\\prime})-\\mu(e_{i}, e_{j})}{\\sqrt{\\sigma^{2}(e_{i}, e_{j})-\\epsilon}}$\n$z \\in\\mathcal{R}^{|B_t|}$ is the normalized triple loss, defined as\n\n\\vspace{-5mm}\n\\begin{equation}\n% \\begin{array}{c}\nz(e_{s}, e_{t}) =\\operatorname{z-score}(\\{\\gamma+\\operatorname{sim}(e_{s}, e_{t})-\\operatorname{sim}(e_{s}, e_{t}^{\\prime}) | e^{\\prime}_t \\in B_t\\}),\n% \\end{array}\n\\end{equation}\n% \\vspace{-2mm}\nwhere $\\operatorname{z-score}(X)=  \\frac{X - \\mu(X)}{\\sigma(X)}$ is the standard score normalization,\nand $\\operatorname{sim}(e_{s}, e_{t})= \\mathbf{h}_{e_s} \\cdot \\mathbf{h}_{e_t}$ is the similarity of two entities obtained with the GNN output feature.\n\n\n\n\\section{Adjacency Matrix Construction for \\MetisGCN{}}\n\\label{app:adj-matrix}\nFollowing~\\cite{GCN-Align18}, to construct the adjacency matrix $A \\in R^{|E|\\times|E|}$, we compute two metrics, which are called functionality and inverse functionality, for each relation:\n\\begin{equation}\n\\begin{aligned}\n&\\operatorname{fun}(r)=\\frac{\\#  Head\\_Entities\\_of\\_r }{\\# Triples\\_of\\_r } \\\\\n&\\operatorname{ ifun }(r)=\\frac{\\# Tail\\_Entities\\_of\\_r }{\\#  Triples\\_of\\_r }\n\\end{aligned}\n\\end{equation}\nwhere $\\#Triples\\_of\\_r$ is the number of triples of relation $r$, \\\\\n$\\#Head\\_Entities\\_of\\_r$ is the number of head entities of $r$, and \\\\\n$\\#Tail\\_Entities\\_of\\_r$ is the number of tail entities of $r$. To measure the influence of the $i$-th entity over the $j$-th entity, we set $a_{i j} \\in A$ as:\n\n\\begin{equation}\na_{i j}=\\sum_{\\left\\langle e_{i}, r, e_{j}\\right\\rangle \\in G} \\operatorname { ifun }(r)+\\sum_{\\left\\langle e_{j}, r, e_{i}\\right\\rangle \\in G}\\operatorname{fun}(r)\n\\end{equation}\n\n\\section{Statistics of datasets}\n\\label{app:dataset-stat}\n\n\n\n\n\n\\begin{figure}[t]\n\\centering\n% \\vspace*{-16mm}\n\\includegraphics[width=0.46\\textwidth]{figs/scalability-icon-eps-converted-to.pdf}\\vspace*{-4.5mm}\\\\\n\\subfigure[EN-FR]{\n \\includegraphics[width=1.55in]{figs/scalability-en-fr_1-eps-converted-to.pdf}\n}\n% \\hspace{-6mm}\n\\subfigure[EN-DE]{\n \\includegraphics[width=1.55in]{figs/scalability-en-de_1-eps-converted-to.pdf}\n}\n% \\vspace*{-5mm}\n\\caption{Scalability analysis vs. variants of \\ClusterEA{}}\n% \\vspace*{-3mm}\n\\label{fig:scalability}\n\\end{figure}\n\n\n\\section{Implementation Details}\n\\label{app:details}\nThe results of all the baselines are obtained by our re-implementation with their publicly available source codes.\nAll experiments were conducted on a personal computer with an Intel Core i9-10900K CPU, an NVIDIA GeForce RTX3090 GPU, and 128GB memory. The programs were all implemented in Python.\nSince the deep learning frameworks used vary on different implementations of EA models, we use the NVIDIA Nsight Systems\\footnote{https://developer.nvidia.com/nsight-systems} to record the GPU memory usage of all approaches uniformly.\nWe detail the hyper-parameters used in the experiment as follows. All the hyper-parameters are set without special instructions.\n\n\\subsection{Non-scalable methods} For non-scalable methods, including GCNAlign, RREA, and Dual-AMN, we follow the parameter settings reported in their original papers~\\cite{GCN-Align18,RREA20, DualAMN21}.\n\n\\subsubsection{GCNAlign}\nNote that GCNAlign contains an attribute encoder as the side information component.\nWe re-implement the GCNAlign model by removing attribute features from it.\n\n\\subsection{LargeEA} We reproduce LargeEA by removing entirely the name channel. It is worth noting that LargeEA incorporates a name-based data augmentation process for generating alignment seeds other than training data. For fair comparison, we also remove this augmentation process, making the LargeEA framework not use any alignment signals apart from the training data. To be more specific, we only compare the structure-channel of LargeEA. The running time and maximum GPU memory usage are also recorded only for the structure-channel of LargeEA, including METIS-CPS partitioning and mini-batch training. We use the default settings reported in~\\cite{LargeEA22} of the two versions, LargeEA-G and LargeEA-R. For the newly proposed variant LargeEA-D, we keep all the hyper-parameters unchanged except the structure-based EA model-related parameters switched to the default settings of Dual-AMN~\\cite{DualAMN21}.\n\n\\subsection{Stochastic training variant of non-scalable methods} Contributed by the NHSM loss~\\cite{DualAMN21}, the training epoch number could be greatly reduced. We replace the training epoch for GCNAlign-S and RREA-S from 2000 and 1200 to 50. We follow~\\cite{DualAMN21} to train 20 epochs for Dual-AMN-S on IDS datasets. We further notice that the training loss of Dual-AMN-S is stable after 10 epochs for the large-scale dataset  DBP1M, thus setting the training epoch of Dual-AMN-S to 10 for DBP1M.\nWe set the fan out number in neighborhood sampling $F=8$, the batch size $N_p = 2000$, $N_n = 4000$, and Adam as the training optimizer for all variants. We follow the setup of~\\cite{DualAMN21} for NHSM loss.\nFor other hyper-parameter settings of the model, including the embedding dimension $D$, we follow their original papers~\\cite{GCN-Align18,RREA20, DualAMN21}.\n\n\\subsection{\\ClusterEA{}}\nIn the \\emph{stochastic training process}, we adopt the aforementioned settings for each \\ClusterEA{} variant. In the \\emph{\\Sampling{} process}, we set the mini-batch number $K = 5$ for IDS15K, $K = 10$ for IDS100K, and $K = 30$ for DBP1M. Moreover, we utilize a cache in disk for pre-processed edge information to quickly load the constructed matrix of relation-aware GNN variants. For \\KMeans{}, we set the max iteration number to $300$, the tolerance to $10^{-4}$, and distance metric to euclidean distance for the KMeans algorithm. We adopt the default setting for the XGBoost Classifier~\\cite{XGBoost16}. We utilize GPU acceleration for those methods. For \\MetisGCN{}, we adopt the default setting of METIS~\\cite{METIS98}, and train a two layer GCN with Adam. The learning rate is set to $0.01$, and the training epoch of GCN set to $800$ for IDS15K, $1500$ for IDS100K, and $3000$ for DBP1M. In the \\emph{\\Merging{} process}, we set $K_s = 100$ for the iteration round of Sinkhorn, $K_r = 50$ for top-K similarity serach, and $K_n = 10$ for CSLS.\n\n\n\\section{Scalability Evaluation}\n\\label{app:scalability}\n% \\MARK{Scalability Evaluation?}\n\nTo further investigate the scalability of our proposed \\ClusterEA{} framework, we verify the running time of each components in different variants of \\ClusterEA{} on the DBP1M dataset, including (1) \\emph{Training time} of the EA model; (2) \\emph{\\KMeans{}} batch sampling time; (3) \\emph{\\MetisGCN{}} batch sampling time on both directions; (4) \\emph{Local Similarity Normalization time} of the batches generated by each samplers, denoted as Norm(Sampler); (5) \\emph{Calculating Global Similarity} time in \\Merging{}; and (6) \\emph{Fusing Global and Local Similarity} time in \\Merging{}. \n% For the structure channel, we report the running time of the mini-batch generation strategy (i.e., METIS-CPS) and that of EA model training.\nThe experimental results are shown in Figure~\\ref{fig:scalability}, where G, R, and D denote \\ClusterEA{-G}, \\ClusterEA{-R}, and \\ClusterEA{-D}, respectively. As depicted in Figure~\\ref{fig:scalability}, we observe that the running time of each component except for Training time does not exceed $10^3$ seconds on the large-scale dataset.\nThis confirms the scalability of \\ClusterEA{}. Note that the training time of the Dual-AMN model is significantly less than that of other variants. This is contributed by the model design of Dual-AMN that could dramatically reduce the required training epochs.\n\\end{appendices}\n\n\\balance\n"
            }
        },
        "figures": {
            "fig:example": "\\begin{figure}[t]\n% \\vspace{-1mm\n\\centering \n\\hspace{-4.8mm}\\includegraphics[width=3.55in]{figs/example-eps-converted-to.pdf} \n% \\vspace{-7mm}\n\\caption{An example of normalizing mini-batch similarity matrix with \\Sampling{} strategy}\n\\vspace{-5mm}\n\\label{fig:example}\n\\vspace{-3mm}\n\\end{figure}",
            "fig:framewrok": "\\begin{figure*}[t]\n\\vspace*{-4mm}\n\\centering\n\\includegraphics[width=5.6in]{figs/framework-eps-converted-to.pdf}\n\\vspace*{-4mm}\n\\caption{The overall \\ClusterEAplain{} framework}\n\\label{fig:framewrok}\n\\vspace*{-4mm}\n\\end{figure*}",
            "fig:partition-exp": "\\begin{figure*}[t]\n\\centering\n\\includegraphics[width=.8\\textwidth]{figs/icon-1-eps-converted-to.pdf}\\\\\n\\vspace*{-4mm}\n\\subfigure[$\\rm IDS15K_{EN-FR}$]{\n \\includegraphics[width=1.7in]{figs/partition-k-small-fr-eps-converted-to.pdf}\n \\label{fig:partition-k-small-fr}\n}\\hspace{-3mm}\n\\subfigure[$\\rm IDS100K_{EN-FR}$]{\n \\includegraphics[width=1.7in]{figs/partition-k-medium-fr-eps-converted-to.pdf}\n \\label{fig:partition-k-medium-fr}\n}\\hspace{-3mm}\n\\subfigure[$\\rm DBP1M_{EN-FR}$]{\n \\includegraphics[width=1.7in]{figs/partition-k-large-fr-eps-converted-to.pdf}\n \\label{fig:partition-k-large-fr}\n}\\hspace{-3mm}\n\\subfigure[$\\rm DBP1M_{EN-FR}$]{\n \\includegraphics[width=1.67in]{figs/scalability-partition-en-fr-2_1-eps-converted-to.pdf}\n \\label{fig:scalability-p-fr}\n}\\\\\n\\vspace*{-6mm}\n\\subfigure[$\\rm IDS15K_{EN-DE}$]{\n \\includegraphics[width=1.7in]{figs/partition-k-small-de-eps-converted-to.pdf}\n \\label{fig:partition-k-small-de}\n}\\hspace{-3mm}\n\\subfigure[$\\rm IDS100K_{EN-DE}$]{\n \\includegraphics[width=1.7in]{figs/partition-k-medium-de-eps-converted-to.pdf}\n \\label{fig:partition-k-medium-de}\n}\\hspace{-3mm}\n\\subfigure[$\\rm DBP1M_{EN-DE}$]{\n \\includegraphics[width=1.7in]{figs/partition-k-large-de-eps-converted-to.pdf}\n \\label{fig:partition-k-large-de}\n}\\hspace{-3mm}\n\\subfigure[$\\rm DBP1M_{EN-DE}$]{\n \\includegraphics[width=1.67in]{figs/scalability-partition-en-de-2_1-eps-converted-to.pdf}\n \\label{fig:scalability-p-de}\n}\n\\vspace{-4mm}\n\\caption{Comparison results of different batch sampling strategies}\n\\vspace*{-4mm}\n\\label{fig:partition-exp}\n\\end{figure*}"
        },
        "equations": {
            "eq:1": "\\begin{equation}\n\\begin{array}{c}\na_{v}^{(k)}=\\operatorname{Aggregate}^{(k)}(\\left\\{h_{u}^{(k-1)} \\mid u \\in \\mathcal{N}(v)\\right\\}) \\\\\nh_{v}^{(k)}=\\operatorname{Update}^{(k)}(a_{v}^{(k)}, h_{v}^{(k-1)})\n\\end{array}\n\\label{eq:message_passing}\n\\vspace{-1mm}\n\\end{equation}",
            "eq:2": "\\begin{equation}\n   \\mathcal{M}^i_{e_s, e_t}  =\n    \\begin{cases}\n      \\operatorname{sim}(e_s, e_t) & \\text{if $e_s \\in \\mathcal{B}^i_s$ and $e_t \\in \\mathcal{B}^i_t$}\\\\\n      0 & \\text{otherwise}\n    \\end{cases}\n\\end{equation}"
        },
        "git_link": "https://github.com/joker-xii/ClusterEA"
    }
}