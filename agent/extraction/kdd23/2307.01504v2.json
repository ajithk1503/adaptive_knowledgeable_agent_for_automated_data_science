{
    "meta_info": {
        "title": "All in One: Multi-task Prompting for Graph Neural Networks",
        "abstract": "Recently, ''pre-training and fine-tuning'' has been adopted as a standard\nworkflow for many graph tasks since it can take general graph knowledge to\nrelieve the lack of graph annotations from each application. However, graph\ntasks with node level, edge level, and graph level are far diversified, making\nthe pre-training pretext often incompatible with these multiple tasks. This gap\nmay even cause a ''negative transfer'' to the specific application, leading to\npoor results. Inspired by the prompt learning in natural language processing\n(NLP), which has presented significant effectiveness in leveraging prior\nknowledge for various NLP tasks, we study the prompting topic for graphs with\nthe motivation of filling the gap between pre-trained models and various graph\ntasks. In this paper, we propose a novel multi-task prompting method for graph\nmodels. Specifically, we first unify the format of graph prompts and language\nprompts with the prompt token, token structure, and inserting pattern. In this\nway, the prompting idea from NLP can be seamlessly introduced to the graph\narea. Then, to further narrow the gap between various graph tasks and\nstate-of-the-art pre-training strategies, we further study the task space of\nvarious graph applications and reformulate downstream problems to the\ngraph-level task. Afterward, we introduce meta-learning to efficiently learn a\nbetter initialization for the multi-task prompt of graphs so that our prompting\nframework can be more reliable and general for different tasks. We conduct\nextensive experiments, results from which demonstrate the superiority of our\nmethod.",
        "author": "Xiangguo Sun, Hong Cheng, Jia Li, Bo Liu, Jihong Guan",
        "link": "http://arxiv.org/abs/2307.01504v2",
        "category": [
            "cs.SI",
            "cs.AI",
            "cs.LG"
        ],
        "additionl_info": "KDD 23 Best Research Paper Award, which is the first for Hong Kong  and Mainland China. A Python Library is released as ProG:  https://github.com/sheldonresearch/ProG Submitted to SIGKDD'23 in 03 Feb  2023; Receive Acceptance in 17 May 2023 (Rating 3 4 4 4); Submit to arXiv 1st  time in 4 Jul 2023"
    },
    "latex_extraction": {
        "content": {
            "section 1": {
                "name": "Introduction",
                "content": "\nGraph neural networks (GNNs) have been widely applied to various applications such as social computing \n% \\cite{sun2022self}\n\\cite{sun2022self, chen2022brainnet}\n,  anomaly detection \n% \\cite{sun2022structure}\n\\cite{BWGNN,sun2022structure}\n, and network analysis \\cite{chen2020multi}. Beyond exploring various exquisite GNN structures, recent years have witnessed a new research trend on how to train a graph model for dedicated problems.  \n\n \n\n\n\n\n% Beyond exploring exquisite graph neural network models, recent years have witnessed a new research trend that how to train a graph model for dedicated problems.  \nTraditional supervised learning methods on graphs heavily rely on graph labels, which are not always sufficient in the real world. Another shortcoming is the over-fitting problem when the testing data is out-of-distribution \\cite{shen2021towards}. To solve these challenges, many studies turn to ``pre-training and fine-tuning'' \\cite{jin2020self}, which means pre-training a graph model with easily accessible data, and then transferring the graph knowledge to a new domain or task via tuning the last layer of the pre-trained model. Although much progress has been achieved on pre-training strategies \\cite{hao2021multi}, there still exists a huge gap between these pretexts and multiple downstream tasks. For example, a typical pretext for the pre-training graph is binary edge prediction. Usually, this pre-training strategy makes connected nodes closer in a latent representation space. However, many downstream tasks are not limited to edge-level tasks but also include node-level tasks (e.g., node multi-class classification) or graph-level tasks (e.g., graph classification). If we transfer the above pre-trained model to multi-class node classification, it may require us to carefully search the results in higher dimensional parameter space for the additional classes of node labels. \n% Using the edge-level pre-training to conduct multi-class node classification for the single node requires us to carefully search parameters in a higher dimension space.\n% from multiple node classes instead of binary edge class. \nThis tuning may even break down (a.k.a negative transfer \\cite{wang2021afec}) when connected nodes have different labels. \nTuning this pre-trained model to graph-level tasks is neither efficient because we have to pay huge efforts to learn an appropriate function mapping node embedding to the whole graph representation.\n\n\nA promising solution to the above problems is to extend ``pre-training and fine-tuning'' to ``pre-training, prompting, and fine-tuning''. Prompt learning is a very attractive idea derived from natural language processing (NLP) and has shown notable effectiveness in generalizing pre-trained language models to a wide range of language applications \\cite{min2021recent}. Specifically, a language prompt refers to a piece of text appended to the rear of an input text. For example, a sentiment task like ``\\textit{KDD2023 will witness many high-quality papers.} \\underline{I feel so} [MASK]'' can be easily transferred to a word prediction task via a preset prompt (``\\underline{I feel so} [MASK]''). It is highly expected that the language model may predict ``[MASK]'' as ``excited'' rather than ``upset'' without further optimizing parameters for the new sentiment task because this model has already been pre-trained via the pretext of masked words prediction and contains some useful knowledge to answer this question. By this means, some downstream objectives can be naturally aligned with the pre-training target. Inspired by the success of the language prompt, we hope to introduce the same idea to graphs. As shown in Figure \\ref{fig:prompt_tuning}, prompt tuning in the graph domain is to seek some light-weighted prompt, keep the pre-training model frozen, and use the prompt to reformulate downstream tasks in line with the pre-training task. In this way, the pre-trained model can be easily applied to downstream applications with highly efficient fine-tuning or even without any fine-tuning. This is particularly useful when the downstream task is a few-shot setting. \n\n\nHowever, designing the graph prompt is more intractable than language prompts. First, classic language prompts are usually some preset phrases or learnable vectors attached at the end of input texts. As shown in Figure \\ref{fig:analogy}, we only need to consider the content for the language prompt, whereas the graph prompt not only requires the prompt ``content'' but also needs to know how to organize these prompt tokens and how to insert the prompt into the original graph, both of which are undefined problems.\n \n \n\nSecond, there is a huge difficulty in reconciling downstream problems to the pre-training task. In the NLP area, we usually pre-train a language model via masked prediction and then transfer it to various applications like question answering \\cite{rogers2020getting}, sentiment classification \\cite{ling2022vision}. The underlying support \\cite{qin2021exploring} is that these language tasks usually share a large overlapping task sub-space, making a masked language task easily transferred to other applications. However, how much does the same \nobservation exist (if truly exists) in graph learning? \n% After all, node-level, edge-level, and graph-level tasks seem to be far more dissimilar. \nIt is crucial but difficult to decide on an appropriate pre-training task and reformulate downstream tasks to improve the capability of model generalization. Currently, we only find very few works \\cite{sun2022gppt} studying the graph prompt issue. However, it can only deal with a single-type task (e.g., node classification) using a specific pretext (e.g., edge prediction), which is far from addressing the multi-task setting with different-level tasks.\n%node-level, edge-level, and graph-level tasks.\n\n\nLast but not least, learning a reliable prompt usually needs huge manpower and is more sensitive to prompt initialization in the multi-task setting \\cite{liu2021pre}. Although there are some works \\cite{lester2021power, zhong2021factual} in the NLP area trying to initialize the prompt via hand-crafted content or some discrete features, these methods are task-bounded, which is not sufficient when we confront a new task. This problem may be even worse in our multi-task graph area since graph features vary a lot in different domains and tasks. \n\n\\textit{\\textbf{Presented work.}}\nTo further fill the gap between graph pre-training and downstream tasks, we introduce the prompt method from NLP to graphs under the multi-task background. Specifically, to address the first challenge, we propose to unify the format of the language prompt and graph prompt in one way so that we can smoothly transfer the prompt idea from NLP to graphs, then we design the graph prompt from prompt tokens, token structures, and prompt inserting patterns. To address the second challenge, we first study the task subspace in graphs and then propose to reformulate node-level and edge-level tasks to graph-level tasks by induced graphs from original graphs. To address the third challenge, we introduce the meta-learning technique over multiple tasks to learn better prompts. We carefully evaluate our method with other approaches and the experimental results extensively demonstrate our advantages. \n\n\\textit{\\textbf{Contributions:}}\n%\\vspace{-0.05in}\n\\begin{itemize}\n    \\item We unify the prompt format in the language area and graph area, and further propose an effective graph prompt for multi-task settings (section \\ref{subsec:prompt_graph}).\n    \\item We propose an effective way to reformulate node-level and edge-level tasks to graph-level tasks, which can further match many pre-training pretexts (section \\ref{subsec:refor}). \n    \\item We introduce the meta-learning technique to our graph prompting study so that we can learn a reliable prompt for improving the multi-task performance (section \\ref{subsec:meta}).\n    \\item We carefully analyze why our method works (section \\ref{subsec:why}) and confirm the effectiveness of our method via extensive experiments (section \\ref{sec:eva}).\n\\end{itemize}\n%\\vspace{-0.15in}\n% \\section{Related Work}\n"
            },
            "section 2": {
                "name": "Background",
                "content": "\n\\noindent \\textbf{Graph Neural Networks.} Graph neural networks (GNNs) have presented powerful expressiveness in many graph-based applications \n% \\cite{sun2021multi, li2019predicting, sun2021heterogeneous, Cheng2023wiener}\n\\cite{sun2021multi, li2019predicting, hou2022graphmae, Cheng2023wiener}\n. The nature of most GNNs is to capture the underlying message-passing patterns for graph representation. To this end, there are many effective neural network structures proposed such as graph attention network (GAT) \\cite{velivckovic2018graph}, graph convolution network (GCN) \\cite{welling2016semi}, Graph Transformer \\cite{shi2020masked}. Recent works also consider how to make graph learning more adaptive when data annotation is insufficient or how to transfer the model to a new domain, which triggered many graph pre-training studies instead of traditional supervised learning.  \n\n\n\\noindent \\textbf{Graph Pre-training.} Graph pre-training \\cite{jin2020self} aims to learn some general knowledge for the graph model with easily accessible information to reduce the annotation costs of new tasks. Some effective pre-training strategies include node-level comparison like GCA \\cite{zhu2021graph}, edge-level pretext like edge prediction \\cite{jin2020self}, and graph-level contrastive learning such as GraphCL \\cite{you2020graph} and SimGRACE \\cite{xia2022simgrace}. In particular, GraphCL minimizes the distance between a pair of graph-level representations for the same graph with different augmentations whereas SimGRACE tries to perturb the graph model parameter spaces and narrow down the gap between different perturbations for the same graph. These graph-level strategies perform more effectively in graph knowledge learning \\cite{hu2020strategies} and are the default strategies of this paper.\n\n\\noindent \\textbf{Prompt Learning \\& Motivations.} \nIntuitively, the above graph-level pre-training strategies have some intrinsic similarities with the language-masked prediction task: aligning two graph views generated by node/edge/feature mask or other perturbations is very similar to predicting some vacant ``blanks'' on graphs. That inspires us to further consider: why can't we use a similar format prompt for graphs to improve the generalization of graph neural networks?\nInstead of fine-tuning a pre-trained model with an adaptive task head, prompt learning aims to reformulate input data to fit the pretext \\cite{gao2021making}. \n% The purpose of prompt-based methods is to relieve the difficulties of tuning the pre-trained model and the task head because traditional fine-tuning is not always suitable for knowledge transferring. \n% This problem may be more serious if the upstream and downstream tasks have a huge gap. \n%To this end, \nMany effective prompt methods are firstly proposed in the NLP area, including some hand-crafted prompts like GPT-3 \\cite{brown2020language}, discrete prompts like \\cite{autoprompt,gao2021making}, and trainable prompts in the continuous spaces like \\cite{li2021prefix, liu2022p}. Despite significant results achieved, prompt-based methods have been rarely introduced in graph domains yet. We only find very few works like GPPT \\cite{sun2022gppt}, trying to design prompts for graphs. Unfortunately, most of them are very limited and are far from sufficient to meet the multi-task demands.\n\n\n\n%%\\vspace{-0.1in}\n"
            },
            "section 3": {
                "name": "Multi-task Prompting on Graphs",
                "content": "\n",
                "subsection 3.1": {
                    "name": "Overview of Our Framework",
                    "content": "\\label{subsec:overview}\n\n\\textit{\\textbf{Objective: }} In this paper, we aim to learn a prompt graph that can be inserted into the original graph, through which we wish to further bridge the gap between a graph pre-training strategy and multiple downstream tasks, and further relieve the difficulties of transferring prior knowledge to different domains. \n\n\\noindent \\textit{\\textbf{Overview: }} To achieve our goal, we propose a novel multi-task prompting framework for graph models. First, we unify various graph tasks in the same format and reformulate these downstream tasks as graph-level tasks. Second, with the unified graph-level instances, we further narrow down the gap among multiple tasks by a novel prompt graph with learnable tokens, inner structures, and adaptive inserting patterns. Third, we build a meta-learning process to learn more adaptive graph prompts for multi-task settings. Next, we elaborate on the main components.\n\n%%\\vspace{-0.1in}\n"
                },
                "subsection 3.2": {
                    "name": "Reformulating Downstream Tasks",
                    "content": "\\label{subsec:refor}\n\n",
                    "subsubsection 3.2.1": {
                        "name": "Why Reformulate Downstream Tasks.",
                        "content": " The success of the traditional ``pre-training and fine-tuning'' framework in the NLP area largely lies in the fact that the pre-training task and downstream tasks share some common intrinsic task subspace, making the pre-training knowledge transferable to other downstream tasks (Figure \\ref{fig:hierarchy_2}). However, things are a little complicated in the graph domain since graph-related tasks are far from similar. As shown in Figure \\ref{fig:hierarchy_1}, it is far-fetched to treat the edge-level task and the node-level task as the same one because node-level operations and edge-level operations are far more different \\cite{sun2022gppt}. This gap limits the performance of pre-training models and might even cause negative transfer \\cite{jin2020self}. The same problem also happens in our ``pre-training, prompting, and fine-tuning'' framework since we aim to learn a graph prompt for multiple tasks, which means we need to further narrow down the gap between these tasks by reformulating different graph tasks in a more general form.\n\n\n\n"
                    },
                    "subsubsection 3.2.2": {
                        "name": "Why Reformulate to the Graph Level.",
                        "content": " With the above motivation, we revisit the potential task space on the graph and find their hierarchical relation as shown in Figure \\ref{fig:hierarchy_1}. Intuitively, many node-level operations such as ``changing node features'', ``delete/add a node'', or edge-level operations such as ``add/delete an edge'', can be treated as some basic operations at the graph level. For example, ``delete a subgraph'' can be treated as ``delete nodes and edges''. Compared with node-level and edge-level tasks, graph-level tasks are more general and contain the largest overlapping task sub-spaces for knowledge transfer, which has been adopted as the mainstream task in many graph pre-training models \\cite{you2020graph, hu2020strategies, xia2022simgrace}. This observation further inspires us to reformulate downstream tasks to look like the graph-level task and then leverage our prompting model to match graph-level pre-training strategies.\n\n\n\n"
                    },
                    "subsubsection 3.2.3": {
                        "name": "How to Reformulate Downstream Tasks.",
                        "content": "\\label{subsubsec:induced_graph}\nSpecifically, we reformulate node-level and edge-level tasks to graph-level tasks by building induced graphs for nodes and edges, respectively. As shown in Figure \\ref{fig:ign},\nan induced graph for a target node means its local area in the network within $\\tau$ distance, which is also known as its $\\tau$-ego network. This subgraph preserves the node's local structure by neighboring node connections and its semantic context by neighboring node features, which is the main scope of most graph neural encoders. When we treat the target node's label as this induced graph label, we can easily translate the node classification problem into graph classification; Similarly, we present an induced graph for a pair of nodes in Figure \\ref{fig:ige}. Here, the pair of nodes can be treated as a positive edge if there is an edge connecting them, or a negative edge if not. This subgraph can be easily built by extending this node pair to their $\\tau$ distance neighbors. We can reformulate the edge-level task by assigning the graph label with the edge label of the target node pair. Note that for unweighted graphs, the $\\tau$ distance is equal to $\\tau$-hop length; for weighted graphs, the $\\tau$ distance refers to the shortest path distance, where the induced graph can be easily found by many efficient algorithms \\cite{akiba2015efficient,zhu2013efficient}.\n\n\n%\\vspace{-0.2in}\n\n\n\n"
                    }
                },
                "subsection 3.3": {
                    "name": "Prompt Graph Design",
                    "content": "\\label{subsec:prompt_graph}\n",
                    "subsubsection 3.3.1": {
                        "name": "Prompting NLP and Graph in One Way",
                        "content": " To seamlessly transfer the prompting idea from NLP to the graph domain, we propose to unify NLP Prompt and Graph Prompt in one perspective. Having compared the demand of NLP and graph area as shown in Figure \\ref{fig:analogy}, we found that the prompt in NLP and graph areas should contain at least three components: \n\\textit{(1) prompt token}, which contains the vectorized prompting information with the same size as the input word/node vector; \\textit{(2) token structure}, which indicates the connection of different tokens. In the NLP area, prompt tokens (a.k.a prompt words) are preset as a linear relation like a sub-sentence or a phrase; whereas in the graph domain, the connections of different tokens are non-linear and far more complicated than NLP prompts; \\textit{(3) inserting pattern}, which presents how to add the prompt to the input data. In the NLP area, the prompt is usually added in the front or the back end of the input sentences by default. However, in the graph area, there are no explicit positions like a sentence to joint graph prompt, making the graph prompting more difficult. \n\n\n"
                    },
                    "subsubsection 3.3.2": {
                        "name": "Prompt Tokens",
                        "content": "\nLet a graph instance be $\\mathcal{G}=(\\mathcal{V},\\mathcal{E})$ where $\\mathcal{V}=\\{v_1,v_2,\\cdots,v_N\\}$ is the node set containing $N$ nodes; each node has a feature vector denoted by $\\mathbf{x}_i \\in \\mathbb{R}^{1\\times d}$ for node $v_i$; $\\mathcal{E}=\\{(v_i,v_j)|v_i,v_j \\in \\mathcal{V}\\}$ is the edge set where each edge connects a pair of nodes in $\\mathcal{V}$. With the previous discussion, we here present our prompt graph as $\\mathcal{G}_p=(\\mathcal{P},\\mathcal{S})$ where $\\mathcal{P}=\\{p_1,p_2,\\cdots,p_{|\\mathcal{P}|}\\}$ denotes the set of prompt tokens and $|\\mathcal{P}|$ is the number of tokens. Each token $p_i \\in \\mathcal{P}$ can be represented by a token vector $\\mathbf{p}_i\\in \\mathbb{R}^{1\\times d}$ with the same size of node features in the input graph; Note that in practice, we usually have $|\\mathcal{P}|\\ll N$ and $|\\mathcal{P}|\\ll d_h$ where $d_h$ is the size of the hidden layer in the pre-trained graph model. With these token vectors, the input graph can be reformulated by adding the $j$-th token to graph node $v_i$ (e.g., $\\mathbf{\\hat{x}}_i= \\mathbf{x}_i +\\mathbf{p}_j $). Then, we replace the input features with the prompted features and send them to the pre-trained model for further processing.\n\n\n\n"
                    },
                    "subsubsection 3.3.3": {
                        "name": "Token Structures",
                        "content": "\n$\\mathcal{S}=\\{(p_i,p_j)|p_i,p_j \\in \\mathcal{P}\\}$ is the token structure denoted by pair-wise relations among tokens. Unlike the NLP prompt, the token structure in the prompt graph is usually implicit. To solve this problem, we propose three methods to design the prompt token structures: (1) the first way is to learn tunable parameters:\n%\\vspace{-0.1in}\n$$\\mathcal{A}=\\overset{|\\mathcal{P}|-1}{\\underset{i=1 \\atop j=i+1}{\\cup}}\\{a_{ij}\\}$$\n%\\vspace{-0.1in}\n\n\\noindent where $a_{ij}$ is a tunable parameter indicating how possible the token $p_i$ and the token $p_j$ should be connected; (2) the second way is to use the dot product of each prompt token pair and prune them according to the dot value. In this case, $(p_i,p_j)\\in \\mathcal{S}$ iff $\\sigma(\\mathbf{p}_i\\cdot \\mathbf{p}_j)<\\delta$ where $\\sigma(\\cdot)$ is a sigmoid function and $\\delta$ is a pre-defined threshold; (3) the third way is to treat the tokens as independent and then we have $\\mathcal{S}=\\emptyset$. \n \n\n\n\n"
                    },
                    "subsubsection 3.3.4": {
                        "name": "Inserting Patterns",
                        "content": "\nLet $\\psi$\n% $\\mathcal{I}=\\{(p_i,v_j)|p_i \\in \\mathcal{P}, v_j \\in \\mathcal{V}\\}$ \nbe the inserting function that indicates how to add the prompt graph $\\mathcal{G}_p$ to the input graph $\\mathcal{G}$, then the manipulated graph can be denoted as $\\mathcal{G}_m=\\psi(\\mathcal{G}, \\mathcal{G}_p)$. We can define the inserting pattern as the dot product between prompt tokens and input graph nodes, and then use a tailored connection like\n$\\mathbf{\\hat{x}}_i=\\mathbf{x}_i+\\sum_{k=1}^{|\\mathcal{P}|} w_{ik}\\mathbf{p}_k$ where $w_{ik}$ is a weighted value to prune unnecessary connections:\n\\begin{equation}\nw_{ik}=\\left\\{\n            \\begin{array}{cl}\n                 \\sigma(\\mathbf{p}_k\\cdot \\mathbf{x}_i^T), & \\text{if } \\sigma(\\mathbf{p}_k\\cdot \\mathbf{x}_i^T)>\\delta \\\\\n                 0, & \\text{otherwise}\n            \\end{array}\n        \\right.\n\\end{equation}\nAs an alternative and special case, we can also use a more simplified way to get $\\mathbf{\\hat{x}}_i=\\mathbf{x}_i+\\sum_{k=1}^{|\\mathcal{P}|} \\mathbf{p}_k$.\n \n\n\n"
                    }
                },
                "subsection 3.4": {
                    "name": "Multi-task Prompting via Meta Learning",
                    "content": "\\label{subsec:meta}\n",
                    "subsubsection 3.4.1": {
                        "name": "Constructing Meta Prompting Tasks",
                        "content": "\nLet $\\tau_i$ be the $i$-th task with supporting data $\\mathcal{D}^{s}_{\\tau_i}$ and query data  $\\mathcal{D}^{q}_{\\tau_i}$; Specifically, for the graph classification task, $\\mathcal{D}^{s}_{\\tau_i}$ and $\\mathcal{D}^{q}_{\\tau_i}$ contain labeled graphs; for the node classification task, we generate an induced graph for each node as mentioned in section \\ref{subsubsec:induced_graph}, align the graph label with the target node label, and treat this graph as a member in $\\mathcal{D}^{s}_{\\tau_i}$ or $\\mathcal{D}^{q}_{\\tau_i}$; for the edge classification task, we first generate edge induced graphs for training and testing and the edge label is up to its two endpoints. \n\n\n\n\n\n\n"
                    },
                    "subsubsection 3.4.2": {
                        "name": "Applying Meta-learning to Graph Prompting",
                        "content": "\nLet $\\theta$ be prompt parameters, $\\pi^{*}$ be the fixed parameters of the pre-trained graph backbone, and $\\phi$ be the tasker's parameters. We use $f_{\\theta, \\phi|\\pi^{*}}$ to denote the pipeline with prompt graph ($\\theta$), pre-trained model ($\\pi^{*}$, fixed), and downstream tasker ($\\phi$). Let $\\mathcal{L}_{\\mathcal{D}}(f)$ be the task loss with pipline $f$ on data $\\mathcal{D}$. Then for each task $\\tau_i$, the corresponding parameters can be updated as follows:\n%\\vspace{-0.1in}\n\\begin{equation}\n\\begin{aligned}\n\\theta_i^k &=\\theta_i^{k-1}-\\alpha \\nabla_{\\theta_i^{k-1}} \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{s}}\\left(f_{\\theta_i^{k-1}, \\phi_i^{k-1}|\\pi^{*}}\\right) \\\\\n\\phi_i^k &=\\phi_i^{k-1}-\\alpha \\nabla_{\\phi_i^{k-1}}\\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{s}}\\left(f_{\\theta_i^{k-1}, \\phi_i^{k-1}|\\pi^{*}}\\right) \n\\end{aligned}\n\\end{equation}\n%\\vspace{-0.1in}\n\n\\noindent where the initialization is set as: $\\theta_i^0=\\theta$, and $\\phi_i^0=\\phi$. The goal of this section is to learn effective initialization settings ($\\theta, \\phi$) for meta prompting tasks, which can be achieved by minimizing the meta loss on various tasks:\n\\begin{equation}\n\\theta^{*}, \\phi^{*}=\\underset{\\theta, \\phi}{\\arg \\min }\\sum_{\\tau_i \\in \\mathcal{T}} \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{q}}\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\right) \n\\end{equation}\nwhere $\\mathcal{T}$ is the task set. According to the chain rule, we use the second-order gradient to update $\\theta$ (or $\\phi$) based on query data:\n\\begin{equation}\\label{equ:meta_update}\n\\begin{aligned}\n\\theta \\!\\leftarrow & \\theta-\\beta \\cdot g_\\theta^{second} \\\\\n=& \\theta-\\beta \\cdot \\sum_{\\tau_i \\in \\mathcal{T}} \\nabla_\\theta \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{q}}\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\right) \\\\\n=&\\theta-\\beta \\cdot \\sum_{\\tau_i \\in \\mathcal{T}} \\nabla_{\\theta_i} \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{q}}\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\right) \\cdot \\nabla_\\theta\\left(\\theta_i\\right) \\\\\n=&\\theta\\!-\\beta\\! \\cdot \\!\\!\\!\\!\\sum_{\\tau_i \\in \\mathcal{T}} \\!\\!\\! \\nabla_{\\theta_i} \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{q}}\\!\\!\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\right)\\!\\cdot \\!\\left(\\mathbf{I}\\!-\\!\\alpha \\mathbf{H}_\\theta\\!\\left(\\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{s}}\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\!\\right)\\!\\right)\\!\\right)\n\\end{aligned}\n\\end{equation}\n%\\vspace{-0.1in}\n\n\\noindent where $\\mathbf{H}_\\theta(\\mathcal{L})$ is the Hessian matrix with $(\\mathbf{H}_\\theta(\\mathcal{L}))_{ij}=\\partial^2\\mathcal{L}/\\partial\\theta_i\\theta_j$; and $\\phi$ can be updated in the same way. \n\nKindly note that in the prompt learning area, the task head is also known as the answering function, which connects the prompt to the answers for downstream tasks to be reformulated. The answering function can be both tunable or hand-craft templates. In section \\ref{subsec:why}, we also propose a very simple but effective hand-crafted prompt answering template without any tunable task head.\n\n\n\n\n"
                    },
                    "subsubsection 3.4.3": {
                        "name": "Overall Learning Process",
                        "content": "\nTo improve the learning stability, we organize these tasks as multi-task episodes where each episode contains batch tasks including node classification (``$n$'' for short), edge classification (``$\\ell$'' for short), and graph classification (``$g$'' for short). Let $\\mathcal{E}_i=(\\mathcal{T}_{\\mathcal{E}_i}, \\mathcal{L}_{\\mathcal{E}_i}, \\mathcal{S}_{\\mathcal{E}_i},\\mathcal{Q}_{\\mathcal{E}_i})$ be a multi-task episode. We define task batch  $\\mathcal{T}_{\\mathcal{E}_i}=\\{\\mathcal{T}^{(g)}_{\\mathcal{E}_i},\\mathcal{T}^{(n)}_{\\mathcal{E}_i},\\mathcal{T}^{(\\ell)}_{\\mathcal{E}_i}\\}$ where each subset $\\mathcal{T}^{(\\triangleleft)}_{\\mathcal{E}_i}=\\{\\tau_{\\triangleleft1},\\cdots,\\tau_{\\triangleleft t_{\\triangleleft}}\\}$; loss function sets $\\mathcal{L}_{\\mathcal{E}_i}=\\{\\mathcal{L}^{(g)},\\mathcal{L}^{(n)},\\mathcal{L}^{(\\ell)}\\}$, supporting data $\\mathcal{S}_{\\mathcal{E}_i}=\\{\\mathcal{S}_{\\mathcal{E}_i}^{(g)},\\mathcal{S}_{\\mathcal{E}_i}^{(n)},\\mathcal{S}_{\\mathcal{E}_i}^{(\\ell)}\\}$ where each subset $\\mathcal{S}_{\\mathcal{E}_i}^{(\\triangleleft)}=\\{\\mathcal{D}^s_{\\tau_{\\triangleleft1}},\\cdots,\\mathcal{D}^s_{\\tau_{\\triangleleft t_{\\triangleleft}}}\\}$, and query data $\\mathcal{Q}_{\\mathcal{E}_i}=\\{\\mathcal{Q}_{\\mathcal{E}_i}^{(g)},\\mathcal{Q}_{\\mathcal{E}_i}^{(n)},\\mathcal{Q}_{\\mathcal{E}_i}^{(\\ell)}\\}$  where $\\mathcal{S}_{\\mathcal{E}_i}^{(\\triangleleft)}=\\{\\mathcal{D}^q_{\\tau_{\\triangleleft1}},\\cdots,\\mathcal{D}^q_{\\tau_{\\triangleleft t_{\\triangleleft}}}\\}$. Then the multi-task prompting is presented in Algorithm \\ref{alg:prompting}.  We treat each node/edge/graph class as a binary classification task so that they can share the same task head. \nNote that our method can also deal with other tasks beyond classification with only a few adaptations (see Appendix \\ref{sec:app}). \n\n\n\n% \\setlength{\\textfloatsep}{0.1in}\n% \\vspace{-0.15in}\n\\begin{algorithm}[t]\n%\\SetAlgoNoLine %用于去掉算法中的竖线\n\\KwIn{Overall pipeline $f_{\\theta, \\phi|\\pi^{*}}$ with prompt parameter $\\theta$, pre-trained model with frozen parameter $\\pi^{*}$, and task head parameterized by $\\phi$; Multi-task episodes $\\mathcal{E}=\\{\\mathcal{E}_1,\\cdots,\\mathcal{E}_n\\}$;\n}\n\\KwOut{\nOptimal pipeline $f_{\\theta^{*}, \\phi^{*}|\\pi^{*}}$\n}\nInitialize $\\theta$ and $\\phi $\\\\\n% \\For{$\\mathcal{E}_i \\in \\mathcal{E}$}\n\\While{not done}\n{\n\\tcp{inner adaptation}\nSample $\\mathcal{E}_i \\in \\mathcal{E}$ where $\\mathcal{E}_i=(\\mathcal{T}_{\\mathcal{E}_i}, \\mathcal{L}_{\\mathcal{E}_i}, \\mathcal{S}_{\\mathcal{E}_i},\\mathcal{Q}_{\\mathcal{E}_i})$ \\\\\n\\For{$\\tau_{\\triangleleft t} \\in \\mathcal{T}_{\\mathcal{E}_i},\\triangleleft=g,n,\\ell$}\n{\n$\\theta_{\\tau_{\\triangleleft t}}, \\phi_{\\tau_{\\triangleleft t}} \\leftarrow \\theta, \\phi $\\\\\n\n$\\theta_{\\tau_{\\triangleleft t}} \\leftarrow \\theta_{\\tau_{\\triangleleft t}}-\\alpha \\nabla_{\\theta_{\\tau_{\\triangleleft t}}} \\mathcal{L}^{(\\triangleleft)}_{\\mathcal{D}_{\\tau_{\\triangleleft t}}^{s}}\\left(f_{\\theta_{\\tau_{\\triangleleft t}}, \\phi_{\\tau_{\\triangleleft t}}|\\pi^{*}}\\right)$\\\\\n\n$\\phi_{\\tau_{\\triangleleft t}} \\leftarrow \\phi_{\\tau_{\\triangleleft t}}-\\alpha \\nabla_{\\phi_{\\tau_{\\triangleleft t}}}\\mathcal{L}^{(\\triangleleft)}_{\\mathcal{D}_{\\tau_{\\triangleleft t}}^{s}}\\left(f_{\\theta_{\\tau_{\\triangleleft t}}, \\phi_{\\tau_{\\triangleleft t}}|\\pi^{*}}\\right) $\\\\\n\n}\n\\tcp{outer meta update}\n% $meta\\_loss \\leftarrow \\underset{{\\tau_{\\triangleleft t} \\in \\mathcal{T}_{\\mathcal{E}_i}}}{\\sum} \\mathcal{L}^{(\\triangleleft)}_{\\mathcal{D}_{\\tau_{\\triangleleft t}}^{q}}\\left(f_{\\theta_{\\tau_{\\triangleleft t}}, \\phi_{\\tau_{\\triangleleft t}}|\\pi^{*}}\\right)$\\\\\n\nUpdate $\\theta,\\phi$ by \\eqcite{equ:meta_update} on $\\mathcal{Q}_{\\mathcal{E}_i}=\\{\\mathcal{D}_{\\tau_{\\triangleleft t}}^{q}|\\tau_{\\triangleleft t} \\in \\mathcal{T}_{\\mathcal{E}_i},\\triangleleft=g,n,\\ell\\}$\n\n} % end. for\n\\Return{\n$f_{\\theta^{*}, \\phi^{*}|\\pi^{*}}$\n}\n\\caption{Overall Learning Process}\n\\label{alg:prompting}\n\\end{algorithm}\n% \\setlength{\\floatsep}{0.1in}\n\n\n\n\n"
                    }
                },
                "subsection 3.5": {
                    "name": "Why It Works?",
                    "content": "\\label{subsec:why}\n\n",
                    "subsubsection 3.5.1": {
                        "name": "Connection to Existing Work",
                        "content": "\\label{subsubsec:con}\nA prior study on graph prompt is proposed by \\cite{sun2022gppt}, namely GPPT. They use edge prediction as a pre-training pretext and reformulate node classification to the pretext by designing labeled tokens added to the original graph. The compound graph will be sent to the pre-trained model again to predict the link connecting each node to the label tokens. Their work somehow is a special case of our method when our prompt graph only contains isolated tokens, each of which corresponds to a node category. However, there are at least three notable differences: (1) GPPT is not flexible to manipulate original graphs; (2) GPPT is only applicable for node classification; and (3) GPPT only supports edge prediction task as the pretext but is not compatible with more advanced graph-level pre-training strategies such as GraphCL \\cite{you2020graph}, UGRAPHEMB \\cite{bai2019unsupervised}, SimGRACE \\cite{xia2022simgrace} etc. We further discuss these issues w.r.t.\\ flexibility, efficiency, and compatibility as below.\n\n"
                    },
                    "subsubsection 3.5.2": {
                        "name": "Flexibility",
                        "content": "\\label{subsec:flex}\nThe nature of prompting is to manipulate the input data to match the pretext. Therefore, the flexibility of data operations is the bottleneck of prompting performance. Let $g$ be any graph-level transformation such as ``changing node features'', ``adding or removing edges/subgraphs'' etc., and $\\varphi^{*}$ be the frozen pre-trained graph model. For any graph $\\mathcal{G}$ with adjacency matrix $\\mathbf{A}$ and node feature matrix $\\mathbf{X}$, Fang et al. \\cite{fang2022prompt} have proved that we can always learn an appropriate prompt token $p^*$ making the following equation stand:\n%\\vspace{-0.05in}\n\\begin{equation}\\label{equ:error_bound_naive}%\\vspace{-0.05in}\n    \\varphi^*\\left(\\mathbf{A}, \\mathbf{X}+p^*\\right)=\\varphi^*({g}(\\mathbf{A}, \\mathbf{X}))+O_{p\\varphi}\n\\end{equation}\nThis means we can learn an appropriate token applied to the original graph to imitate any graph manipulation. Here {\\small $O_{p\\varphi}$} denotes the error bound between the manipulated graph and the prompting graph w.r.t. their representations from the pre-trained graph model. This error bound is related to some non-linear layers of the model (\\textit{unchangeable}) and the quality of the learned prompt (\\textit{changeable}), which is promising to be further narrowed down by a more advanced prompt scheme. In this paper, we extend the standalone token to a prompt graph that has multiple prompt tokens with learnable inner structures. Unlike the indiscriminate inserting in \\eqcite{equ:error_bound_naive} (``{\\footnotesize $\\mathbf{X}+p^*$}'' means the prompt token should be added to every node of the original graph), the inserting pattern of our proposed prompt graph is highly customized. Let $\\psi(\\mathcal{G}, \\mathcal{G}_p)$ denote the inserting pattern defined in section \\ref{subsec:prompt_graph}; $\\mathcal{G}$ is the original graph, and $\\mathcal{G}_p$ is the prompt graph, then we can learn an optimal prompt graph $\\mathcal{G}_p^*$ to extend \\eqcite{equ:error_bound_naive} as follows:\n%\\vspace{-0.05in}\n\\begin{equation}\\label{equ:error_bound_new}%\\vspace{-0.05in}\n    \\varphi^*\\left(\\psi(\\mathcal{G}, \\mathcal{G}_p^*)\\right)=\\varphi^*(\\mathbf{g}(\\mathbf{A}, \\mathbf{X}))+O^{*}_{p\\varphi}\n\\end{equation}\nBy efficient tuning, the new error bound {\\small $O^{*}_{p\\varphi}$} can be further reduced. In section \\ref{subsec:further}, we empirically demonstrate that {\\small $O^{*}_{p\\varphi}$} can be significantly smaller than {\\small $O_{p\\varphi}$} via efficient training. That means our method supports more flexible transformations on graphs to match various pre-training strategies. \n\n\n% time complexity\n% $O(LNd^2+LMd+Nd+Lnd^2+Lmd+nNd+nd)$\n% $O(LNd^2+LMd+Nd)$\n"
                    },
                    "subsubsection 3.5.3": {
                        "name": "Efficiency",
                        "content": " \nAssume an input graph has $N$ nodes and $M$ edges and the prompt graph has $n$ tokens with $m$ edges. Let the graph model contain $L$ layers and the maximum dimension of one layer be $d$. The parameter complexity of the prompt graph is only $O(nd)$. In contrast, some typical graph models (e.g., GAT \\cite{velivckovic2018graph}) usually contain $O(LKd^2+LKd)$ parameters to generate node embedding and additional $O(Kd)$ parameters to obtain the whole graph representation ($K$ is the multi-head number). The parameters may be even larger in other graph neural networks (e.g., graph transformer \\cite{yun2019graph}). In our prompt learning framework, we only need to tune the prompt with the pre-trained graph model frozen, making the training process converge faster than traditional transfer tuning. \n\n\nFor the time complexity, a typical graph model (e.g., GCN \\cite{welling2016semi}) usually needs $O(LNd^2\\!+\\!LMd\\!+\\!Nd)$ time to generate node embedding via message passing and then obtain the whole graph representation (e.g., $O(Nd)$ for summation pooling). By inserting the prompt into the original graph, the total time is \n% $O(nNd\\!+\\!L(n\\!+\\!N)d^2\\!+\\!L(m\\!+\\!M)d\\!+\\! (n\\!+\\!N)d)$. \n$O(L(n\\!+\\!N)d^2\\!+\\!L(m\\!+\\!M)d\\!+\\! (n\\!+\\!N)d)$. \nCompared with the original time, the additional time cost is only $O(Lnd^2\\!+\\!Lmd\\!+\\!nd)$ where $n\\ll d, n\\ll N, m\\ll M$.\n\nBesides the efficient parameter and time cost, our work is also memory friendly. Taking node classification as an example, the memory cost of a graph model largely includes parameters, graph features, and graph structure information. As previously discussed, our method only needs to cache the prompt parameters, which are far smaller than the original graph model. For the graph features and structures, traditional methods usually need to feed the whole graph into a graph model, which needs huge memory to cache these contents. However, we only need to feed an induced graph to the model for each node, the size of which is usually far smaller than the original graph. Notice that in many real-world applications, we are often interested in only a few parts of the total nodes, which means our method can stop timely if there is no more node to be predicted and we do not need to propagate messages on the whole graph either. This is particularly helpful for large-scale data.\n\n\n\n\n"
                    },
                    "subsubsection 3.5.4": {
                        "name": "Compatibility",
                        "content": "\\label{subsub:com}\nUnlike GPPT, which can only use binary edge prediction as a pretext, and is only applicable for node classification as downstream tasks, our framework can support node-level, edge-level, and graph-level downstream tasks, and adopt various graph-level pretexts with only a few steps of tuning. Besides, when transferring the model to different tasks, traditional approaches usually need to additionally tune a task head. In contrast, our method focuses on the input data manipulation and it relies less on the downstream tasks. This means we have a larger tolerance for the task head. For example, in section \\ref{subsec:trans}, we study the transferability from other domains or tasks but we only adapt our prompt, leaving the source task head unchanged. We can even select some specific pretext and customize the details of our prompt without any tuned task head. Here we present a case that does not need to tune a task head and we evaluate its feasibility in section \\ref{subsec:abla}.\n\n\\begin{center}\n\\fcolorbox{black!0}{gray!10}{\\parbox{.42\\textwidth}{\n% \\centerline{\\textit{Prompt without Any Fine-tuning:}}\n\\textit{Prompt without Task Head Tuning:}\n\n\\textbf{Pretext:} GraphCL \\cite{you2020graph}, a graph contrastive learning task that tries to maximize the agreement between a pair of views from the same graph.\n\n\\textbf{Downstream Tasks:} node/edge/graph classification.\n\n\\textbf{Prompt Answer:} \\textit{node classification.} Assume there are $k$ categories for the nodes. We design the prompt graph with $k$ sub-graphs (a.k.a sub-prompts) where each sub-graph has $n$ tokens. Each sub-graph corresponds to one node category. Then we can generate $k$ graph views for all input graphs. We classify the target node with label $\\ell$ ($\\ell=1,2,\\cdots, k$) if the $\\ell$-th graph view is closest to the induced graph. It is similar to edge/graph classification.\n}}\n\\end{center}\n\nInterestingly, by shrinking the prompt graph as isolate tokens aligned with node classes and replacing the induced graphs with the whole graph, our prompt format can degenerate to GPPT, which means we can also leverage edge-level pretext for node classification. Since this format is exactly the same as GPPT, we will not discuss it anymore. Instead, we directly compare GPPT on node classification with our method.\n%more advanced version: using the induced graph to reformulate downstream tasks, preserving inner links of the graph prompt, and still treating a node classification as a graph-level pretext. \n\n\n\n\n\n"
                    }
                }
            },
            "section 4": {
                "name": "Evaluation",
                "content": "\\label{sec:eva}\nIn this section, we extensively evaluate our method with other approaches on node-level, edge-level, and graph-level tasks of graphs. In particular, we wish to answer the following research questions: \\textbf{Q1}: How effective is our method under the few-shot learning background for multiple graph tasks? \\textbf{Q2}: How adaptable is our method when transferred to other domains or tasks? \\textbf{Q3}: How do the main components of our method impact the performance? \\textbf{Q4}: How efficient is our model compared with traditional approaches? \\textbf{Q5}: How powerful is our method when we manipulate graphs?\n\n%\\vspace{-0.1in}\n",
                "subsection 4.1": {
                    "name": "Experimental Settings",
                    "content": "\n\n",
                    "subsubsection 4.1.1": {
                        "name": "Datasets",
                        "content": ": We compare our methods with other approaches on five public datasets including Cora \\cite{welling2016semi}, CiteSeer \\cite{welling2016semi}, Reddit \\cite{hamilton2017inductive}, Amazon \\cite{shchur2018pitfalls}, and Pubmed \\cite{welling2016semi}. Detailed statistics are presented in Table \\ref{tab:data} where the last column refers to the number of node classes. To conduct edge-level and graph-level tasks, we sample edges and subgraphs from the original data where the label of an edge is decided by its two endpoints and the subgraph label follows the majority of the subgraph nodes. For example, if nodes have 3 different classes, say $c_1, c_2, c_3$, then edge-level tasks contain at least 6 categories ($c_1,c_2,c_3, c_1c_2,c_1c_3,c_2c_3$). We also evaluate additional graph classification and link prediction on more specialized datasets where the graph label and the link label are inborn and not related to any node (see Appendix \\ref{sec:app}).\n\n\n"
                    },
                    "subsubsection 4.1.2": {
                        "name": "Approaches",
                        "content": "\nCompared approaches are from three categories: \\textbf{(1) Supervised methods}: these methods directly train a GNN model on a specific task and then directly infer the result. We here take three famous GNN models including GAT \\cite{velivckovic2018graph}, GCN \\cite{welling2016semi}, and Graph Transformer \\cite{shi2020masked} (short as GT). These GNN models are also included as the backbones of our prompt methods. \\textbf{(2) Pre-training with fine-tuning}: These methods first pre-train a GNN model in a self-supervised way such as GraphCL \\cite{you2020graph} and SimGRACE \\cite{xia2022simgrace}, then the pre-trained model will be fine-tuned for a new downstream task. \\textbf{(3) Prompt methods}: With a pre-trained model frozen and a learnable prompt graph, our prompt method aims to change the input graph and reformulate the downstream task to fit the pre-training strategies. \n\n\n"
                    },
                    "subsubsection 4.1.3": {
                        "name": "Implementations",
                        "content": "\nWe set the number of graph neural layers as 2 with a hidden dimension of 100. To study the transferability across different graph data, we use SVD (Singular Value\n    Decomposition) to reduce the initial features to 100 dimensions. The token number of our prompt graph is set as 10. We also discuss the impact of token numbers in section \\ref{subsec:abla} where we change the token number from 1 to 20. We use the Adam optimizer for all approaches. The learning rate is set as 0.001 for most datasets. In the meta-learning stage, we split all the node-level, edge-level, and graph-level tasks randomly in 1:1 for meta-training and meta-testing. Reported results are averaged on all tested tasks. More implementation details are shown in Appendix \\ref{sec:app}, in which we also analyze the performance on more datasets and more kinds of tasks such as regression, link prediction, and so on. \n\n\n% Please add the following required packages to your document preamble:\n% \\usepackage{booktabs}\n% \\usepackage{multirow}\n% \\usepackage{graphicx}\n\n\n"
                    }
                },
                "subsection 4.2": {
                    "name": "Multi-Task Performance with Few-shot Learning Settings (RQ1)",
                    "content": "\nWe compared our prompt-based methods with other mainstream training schemes on node-level, edge-level, and graph-level tasks under the few-shot setting. We repeat the evaluation 5 times and report the average results in Table \\ref{tab:node_level}, Table \\ref{tab:edge_level} (Appendix \\ref{sec:app}), and Table \\ref{tab:graph_level} (Appendix \\ref{sec:app}). From the results, we can observe that most supervised methods are very hard to achieve better performance compared with pre-train methods and prompt methods. This is because the empirical annotations required by supervised frameworks in the few-shot setting are very limited, leading to poor performance. In contrast, pre-training approaches contain more prior knowledge, making the graph model rely less on data labels. However, to achieve better results on a specific task, we usually need to carefully select an appropriate pre-training approach and carefully tune the model to match the target task, but this huge effort is not ensured to be applicable to other tasks. The gap between pre-training strategies and downstream tasks is still very large, making the graph model very hard to transfer knowledge on multi-task settings (we further discuss the transferability in section \\ref{subsec:trans}.) Compared with pre-training approaches, our solutions further improve the compatibility of graph models. The reported improvements range from 1.10\\% to 8.81\\% on node-level tasks, 1.28\\% to 12.26\\% on edge-level tasks, and 0.14\\% to 10.77\\% on graph-level tasks. In particular, we also compared our node-level performance with the previously mentioned node-level prompt model GPPT in Table \\ref{tab:node_level}. Kindly note that our experiment settings are totally different from GPPT. In GPPT, they study the few-shot problem by masking 30\\% or 50\\% data labels. However, in our paper, we propose a more challenging problem: how does the model perform if we further reduce the label data? So in our experiment, each class only has 100 labeled samples. This different setting makes our labeled ratio approximately only 25\\% on Cora, 18\\% on CiteSeer, 1.7\\% on Reddit, 7.3\\% on Amazon, and 1.5\\% on Pubmed, which are far less than the reported GPPT (50\\% labeled). \n\n% %\\vspace{-0.15in}\n"
                },
                "subsection 4.3": {
                    "name": "Transferability Analysis (RQ2)",
                    "content": "\\label{subsec:trans}\nTo evaluate the transferability, we compared our method with the hard transfer method and the fine-tuning method. Here the hard transfer method means we seek the source task model which has the same task head as the target task and then we directly conduct the model inference on the new task. The fine-tune method means we load the source task model and then tune the task head for the new task. We evaluate the transferability from two perspectives: (1) how effectively is the model transferred to different tasks within the same domain? and (2) how effectively is the model transferred to different domains? \n\n\n% Please add the following required packages to your document preamble:\n% \\usepackage{booktabs}\n% \\usepackage{multirow}\n% \\usepackage{graphicx}\n\n% Please add the following required packages to your document preamble:\n% \\usepackage{booktabs}\n% \\usepackage{multirow}\n% \\usepackage{graphicx}\n\n\n%\\vspace{-0.1in}\n",
                    "subsubsection 4.3.1": {
                        "name": "Transferability to Different Level Tasks",
                        "content": "\nHere we pre-train the graph neural network on Amazon, then conduct the model on two source tasks (graph level and node level), and further evaluate the performance on the target task (edge level). For simplicity, both source tasks and the target task are built as binary classifications with $1:1$ positive and negative samples (we randomly select a class as the positive label and sample negatives from the rest). We report the results in Table \\ref{tab:trans_amazon}, from which we have two observations: First, our prompt method significantly outperforms the other approaches and the prediction results make sense. In contrast, the problem of the hard transfer method is that the source model sometimes can not well decide on the target tasks because the target classes may be far away from the source classes. This may even cause negative transfer results (results that are lower than random guess). In most cases, the fine-tuning method can output meaningful results with a few steps of tuning but it can still encounter a negative transfer problem. Second, the graph-level task has better adaptability than the node-level task for the edge-level target, which is in line with our previous intuition presented in Figure \\ref{fig:hierarchy} (section \\ref{subsec:refor}). \n%Similar observations are also reflected in more datasets (Appendix \\ref{app:transfer})\n\n"
                    },
                    "subsubsection 4.3.2": {
                        "name": "Transferability to Different Domains",
                        "content": " We also conduct the model on Amazon and PubMed as source domains, then load the model states from these source domains and report the performance on the target domain (Cora). Since different datasets have various input feature dimensions, we here use SVD to unify input features from all domains as 100 dimensions. Results are shown in Table \\ref{tab:trans_domains}, from which we can find that the good transferability of our prompt also exists when we deal with different domains.\n\n\n%\\vspace{-0.1in}\n \n\n"
                    }
                },
                "subsection 4.4": {
                    "name": "Ablation Study (RQ3)",
                    "content": "\\label{subsec:abla}\nIn this section, we compare our complete framework with four variants: ``w/o meta'' is the prompt method without meta-learning step; ``w/o h'' is our method without task head tuning, which is previously introduced in section \\ref{subsub:com}; ``w/o token structure'' is the prompt where all the tokens are treated as isolated without any inner connection; and ``w/o inserting'' is the prompt without any across links between prompt tokens and the input graphs. We report the performance in Figure \\ref{fig:abl}, from which we can find the meta-learning and token structure all contribute significantly to the final results. In particular, the inserting pattern between a prompt graph and the input graph plays a very crucial role in the final performance. As previously discussed, the purpose of the prompt-based method is to relieve the difficulty of traditional ``pre-train, fine-tuning'' by filling the gap between the pre-training model and the task head. This means the prompt graph is proposed to further improve the fine-tuning performance. This is particularly important when we transfer the model across different tasks/domains, which proposes harder demand for the task head. As suggested in Figure \\ref{fig:abl}, even when we totally remove the tunable task head, the ``w/o h'' variant can still perform very competitively, which suggests the powerful capability of bridging upstream and downstream tasks. \n\n\n\n"
                },
                "subsection 4.5": {
                    "name": "Efficiency Analysis (RQ4)",
                    "content": "\nFigure \\ref{fig:token_num} presents the impact of increasing token number on the model performance, from which we can find that most tasks can reach satisfactory performance with very limited tokens, making the complexity of the prompt graph very small. The limited token numbers make our tunable parameter space far smaller than traditional methods, which can be seen in Table \\ref{tab:num_par}. This means our method can be efficiently trained with a few steps of tuning. As shown in Figure \\ref{fig:loss}, the prompt-based method converges faster than traditional pre-train and supervised methods, which further suggests the efficiency advantages of our method.\n\n\n%%\\vspace{-0.1in}\n \n\n\n\n\n"
                },
                "subsection 4.6": {
                    "name": "Flexibility on Graph Transformation (RQ5)",
                    "content": "\\label{subsec:further}\n\nAs discussed in section \\ref{subsec:flex}, the flexibility of data transformation is the bottleneck of prompt-based methods. Here we manipulate several graphs by dropping nodes, dropping edges, and masking features, then we calculate the error bound mentioned in Equation \\ref{equ:error_bound_naive} and \\ref{equ:error_bound_new}. We compare the original error with the naive prompt mentioned in Equation \\ref{equ:error_bound_naive}, and our prompt graph with 3, 5, and 10 tokens. As shown in Table \\ref{tab:error}, our designed prompt graph significantly reduces the error between the original graph and the manipulated graph. This means our method is more powerful to stimulate various graph transformations and can further support significant improvement for downstream tasks. This capability can also be observed in the  graph visualization from two approaches. As shown in Figure \\ref{fig:vis}, the graph representations from a pre-trained model present lower resolution to node classes compared with our prompted graph.\n\n%\\vspace{-0.1in}\n \n\n"
                }
            },
            "section 5": {
                "name": "Conclusion",
                "content": "\nIn this paper, we study the multi-task problem of graph prompts with few-shot settings. We propose a novel method to reformulate different-level tasks to unified ones and further design an effective prompt graph with a meta-learning technique. We extensively evaluate the performance of our method. Experiments demonstrate the effectiveness of our framework.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n% \\sun{check this url to see whether you made the similar shortcomings in your paper:\n% \\url{https://openreview.net/forum?id=SZojABvWnkx}}\n\n\\begin{acks}\n% This research is supported in part by project \\#MMT-p2-23 of the Shun Hing Institute of Advanced Engineering, The Chinese University of Hong Kong, by grants from the Research Grant Council of the Hong Kong Special Administrative Region, China (Project No.: CUHK 14217622).\n% % Jia Li\n% by NSFC Grant No. 62206067, by Guangzhou-HKUST(GZ) Joint Funding Scheme 2023A03J0673.\n% % jihong guan\n% This work was supported in part by NSFC (No. U1936205, No. 62172300, No. 62202336),  National Key R\\&D Program of China (No. 2021YFC3300300),  the Fundamental Research Funds for the Central Universities (No. ZD-21-202101), and Open Research Projects of Zhejiang Lab (No. 2021KH0AB04).\n% % Bo Liu\n% This work is supported by National Key R&D Program of China under Grants No. 2022YFB3104300. National Natural Science Foundation of China under Grants No. 61972087.\n% % me\n% The first author, Dr. Xiangguo Sun, in particular, wants to thank his parents for their kind support during his tough period. \n\nThis research is supported in part by project \\#MMT-p2-23 of the Shun Hing Institute of Advanced Engineering, The Chinese University of Hong Kong, by grants from the Research Grant Council of the Hong Kong Special Administrative Region, China (No. CUHK 14217622), NSFC (No. 61972087, No. 62206067, No. U1936205, No. 62172300, No. 62202336), Guangzhou-HKUST(GZ) Joint Funding Scheme (No. 2023A03J0673), National Key R\\&D Program of China (No. 2022YFB3104300, No. 2021YFC3300300), the Fundamental Research Funds for the Central Universities (No. ZD-21-202101), and Open Research Projects of Zhejiang Lab (No. 2021KH0AB04). \\textbf{The first author, Dr. Xiangguo Sun, in particular, wants to thank his parents for their kind support during his tough period.} \n\n\n\\end{acks}\n\\clearpage\n\\bibliographystyle{ACM-Reference-Format} % 0.5 pages\n\\balance\n\\bibliography{ref.bib}\n\n\n\\clearpage\n\n\n\n\\appendix\n\n"
            },
            "section 6": {
                "name": "Appendix",
                "content": "\\label{sec:app}\nIn this section, we supplement more experiments to evaluate the effectiveness of our framework further. \n% Here we first introduce additional datasets in section \\ref{app:add_data}, then we evaluate the transferability on more datasets in section \\ref{app:transfer}. We conduct multi-class classification tasks in section \\ref{app:multi_class}, additional graph-level classification tasks in section \\ref{app:gc}, regression tasks in section \\ref{app:reg}, and link prediction tasks in section \\ref{app:link}. \n% Section \\ref{app:setting} introduces more detailed settings of our implementation\nThe source code is publicly available at \\textcolor{cyan}{\\url{https://anonymous.4open.science/r/mpg}}\n%We open the source code at https://anonymous.4open.science/r/mpg.\n\n\n\n\n\n\n\n\n\n% \\subsection{Additional Datasets}\\label{app:add_data}\n\\textbf{Additional Datasets} Besides the datasets mentioned in the main experiments of our paper, we here supplement more datasets in Table \\ref{tab:data_graph_more} to further evaluate the effectiveness of our framework.\n%As shown in Table \\ref{tab:data_graph_more} can be accessed from PyG Datasets.\n% \\footnote{\\url{https://pytorch-geometric.readthedocs.io/en/latest/modules/datasets.html}}.\nSpecifically, ENZYMES and ProteinsFull are two molecule/protein datasets that are used in our additional graph-level classification tasks. \n% % In our main experiments of the paper, the graph-level labels are constructed by the node labels. Here the labels of these two datasets are their inborn graph classes which are not related to nodes. We do this because we wish to further confirm the effectiveness of our framework on graph-level tasks.\nMovielens and QM9 are used to evaluate the performance of our method on edge-level and graph-level regression, respectively. In particular, Movielens contains user's rating scores to the movies, each edge in which has a score value ranging from $0$ to $5$. \n% We first use metapath2vec to get node initial features by meta path ``User-Movie-User'' and obtain 100 dimension features for all nodes. We scale the scoring values within $[0,1]$, and leverage our method to predict the edge value. \nQM9 is a molecule graph dataset where each graph has 19 regression targets, which are treated as graph-level multi-output regression. PersonalityCafe and Facebook datasets are used to test the performance of link prediction, both of which are social networks where edges denote the following/quoting relations. \n\n\\textbf{Multi-label v.s. Multi-class Classification} In the main experiments, we treat the classification task as a multi-label problem. \n% treat each class as a binary classification problem to construct meta-learning tasks. Then we calculate the averaged performance on multiple tasks so that all tasks can share the same project head. This setting is a widely adopted solution to multi-label classification, which means one sample may belong to multiple labels. In other situations, however, we might be interested in the multi-class classification where each sample only belongs to one of the classes. \nHere we present the experimental results under a multi-class setting. \n%In this case, the output dimension of each model is exactly the same as the number of classes. \n% To save space, we only present the results on Cora and CiteSeer, but the similar observations are also reflected on other datasets. \nAs reported in Table \\ref{tab:app_multiclass}, our prompt-based method still outperforms the rest methods. \n%In particular, prompt w/o h, as mentioned in section \\ref{subsub:com}, also suppresses the rest baselines, which further confirms the superiority of our method.\n\n\n\n\n\n\n\n\n\n\\textbf{Additional Graph-level Classification} Here, we evaluate the graph-level classification performance where the graph label is not impacted by nodes' attributes. As shown in Table \\ref{tab:app_graph_multiclass}, \n% we only feed 100 labeled graphs for each graph class on the ProtensFull dataset and ENZYMES is tested with 50-shot setting, from which we can find that \nour method is more effective in the multi-class graph classification, especially in the few-shot setting.\n\n\n\\textbf{Edge/Graph-level Regression} Beyond classification tasks, our method can also support to improve graph models on regression tasks. Here, we evaluate the regression performance of both graph-level (QM9) and edge-level (MovieLens) datasets by MAE (mean absolute error) and MSE (mean squared error). We only feed 100-shot edge induced graphs for the model and the results are shown in Table \\ref{tab:app_reg}, from which we can observe that our prompt-based methods outperform traditional approaches.\n\n\n\n\n\n\n\n\n% \\begin{table}[h]\n% \\centering\n% \\caption{Transferability (\\%) on more data sets from different level tasks spaces. Source tasks: graph-level tasks and node-level tasks. Target task: edge-level tasks}\n% \\label{tab:trans_rest1}\n% \\resizebox{0.48\\textwidth}{!}{%\n% \\begin{tabular}{@{}p{0.07\\textwidth}<{\\centering}c|p{0.05\\textwidth}<{\\centering}p{0.04\\textwidth}<{\\centering}p{0.04\\textwidth}<{\\centering}|p{0.05\\textwidth}<{\\centering}p{0.04\\textwidth}<{\\centering}p{0.04\\textwidth}<{\\centering}@{}}\n% \\toprule\n% \\multirow{2}{*}{\\makecell[c]{Source tasks}}     & \\multirow{2}{*}{Methods} & \\multicolumn{3}{c|}{Cora}       & \\multicolumn{3}{c}{CiteSeer}     \\\\\n%                                       &                          & Accuracy & F1 & AUC & Accuracy & F1 & AUC  \\\\ \\midrule\n% \\multirow{3}{*}{graph level} & hard transfer & 55.00    & 51.04    & 52.00     & 50.00    & 66.67    & 94.02       \\\\\n%                              & fine-tune     & 95.00    & 94.79    & 98.04     & 89.00    & 90.39    & 97.94     \\\\\n%                              & prompt        & 95.50    & 95.34    & 98.39     & 91.50    & 91.70    & 98.59       \\\\\\midrule\n% \\multirow{3}{*}{node level}  & hard transfer & 56.50    & 24.34    & 69.89     & 50.00    & 50.33    & 90.38    \\\\\n%                              & fine-tune     & 89.00    & 91.73    & 82.08     & 50.50    & 66.89    & 97.35    \\\\\n%                              & prompt        & 93.00    & 93.14    & 95.80     & 53.95    & 66.67    & 98.31     \\\\\n% \\bottomrule\n% \\end{tabular}%\n% }\n% \\end{table}\n\n% \\begin{table}[h]\n% \\centering\n% \\caption{Transferability (\\%) on more data sets from different level tasks spaces. Source tasks: graph-level tasks and node-level tasks. Target task: edge-level tasks}\n% \\label{tab:trans_rest2}\n% \\resizebox{0.48\\textwidth}{!}{%\n% \\begin{tabular}{@{}p{0.07\\textwidth}<{\\centering}c|p{0.05\\textwidth}<{\\centering}p{0.04\\textwidth}<{\\centering}p{0.04\\textwidth}<{\\centering}|p{0.05\\textwidth}<{\\centering}p{0.04\\textwidth}<{\\centering}p{0.04\\textwidth}<{\\centering}@{}}\n% \\toprule\n% \\multirow{2}{*}{\\makecell[c]{Source tasks}}     & \\multirow{2}{*}{Methods} & \\multicolumn{3}{c|}{Reddit}     & \\multicolumn{3}{c}{Pubmed}  \\\\\n%                                       &                          &  Accuracy & F1 & AUC  & Accuracy & F1 & AUC   \\\\ \\midrule\n% \\multirow{3}{*}{graph level} & hard transfer     & 55.33    & 57.61    & 65.35     & 60.50    & 34.64    & 75.71     \\\\\n%                              & fine-tune    & 63.44    & 67.38    & 70.40     & 80.00    & 80.95    & 84.34     \\\\\n%                              & prompt  & 65.56    & 67.33    & 71.26     & 80.00    & 82.14    & 85.13     \\\\\\midrule\n% \\multirow{3}{*}{node level}  & hard transfer  & 52.36    & 54.62    & 55.37     & 59.00    & 36.92    & 72.71     \\\\\n%                              & fine-tune   & 61.64    & 65.47    & 69.40     & 58.50    & 45.03    & 74.13     \\\\\n%                              & prompt  & 63.62    & 66.31    & 70.56     & 58.50    & 60.23    & 74.10    \\\\\n% \\bottomrule\n% \\end{tabular}%\n% }\n% \\end{table}\n\n\n\n\n\n% \\subsection{Transferability on More Datasets}\\label{app:transfer}\n\n% As mentioned in section \\ref{subsec:trans}, we can also observe similar advantages of our method on more datasets as shown in Table \\ref{tab:trans_rest1} and Table \\ref{tab:trans_rest2}. Detailed analysis and settings are in line with the main body of section  \\ref{subsec:trans}.\n\n\n\n\n\n\n\n\n\n\n\n\\textbf{Link Prediction} Beyond edge classification, link prediction is also a widely studied problem in the graph learning area. Here, the edges are split into three parts: (1) 80\\% of the edges are for message passing only. (2) 10\\% of the rest edges as the supervision training set. and (3) the rest edges as the testing set. For each edge in the training set and the testing set, we treat these edges as positive samples and sample non-adjacent nodes as negative samples. We generate the edge-induced graph for these node pairs according to the first part edges. The graph label is assigned as positive if the node pairs have a positive edge and vice versa. To further evaluate our method's potential in the extremely limited setting, we only sample 100 positive edges from the training set to train our model. In the testing stage, each positive edge has 100 negative edges. We evaluate the performance by MRR (mean reciprocal rank), and Hit Ratio@ 1, 5, 10. Results from Table \\ref{tab:link} demonstrate that the performance of our prompt-based method still keeps the best in most cases.\n\n\n\n\n\n\n\n\n\n\n% \\subsection{Algorithms of Induced Graph Generation for Nodes and Edges}\n% Here we present three auxiliary algorithm: \n% Algorithms of Induced Graph Generation for Nodes and Edges, and episodes construction.\n\n% \\subsection{Visulization of Prompt Graph}\n% \\sun{try as much as you can if you still have some time.}\n% \\sun{To Be finished before 30 Jan}\n\n% \\subsection{Implementation Details}\\label{app:setting}\n% We implement our method by PyTorch\\footnote{\\url{https://pytorch.org}} and PyG\\footnote{\\url{https://www.pyg.org}} with Python 3.10. Most of the experiments are conducted on Mac Mini 2020 with Apple M1 chip, 16 GM memory and MacOS Ventura 13.1. A demo project is open available at https://anonymous.4open.science/r/mpg. We also developed a more advanced python package based on the paper source code. Following the anonymity policy, this package will also be released after the acceptance.\n\n\n% Please add the following required packages to your document preamble:\n% \\usepackage{booktabs}\n% \\usepackage{multirow}\n% \\usepackage{graphicx}\n\n% Please add the following required packages to your document preamble:\n% \\usepackage{booktabs}\n% \\usepackage{multirow}\n% \\usepackage{graphicx}\n\n\n\n\n\n"
            }
        },
        "tables": {
            "tab:data": "\\begin{table}[t]\n\\centering%\\vspace{-0.1in}\n\\caption{Statistics of datasets.}%\\vspace{-0.15in}\n\\label{tab:data}\n\\resizebox{0.35\\textwidth}{!}{%\n\\begin{tabular}{@{}c|c|c|c|c@{}}\n\\toprule\nDataset & \\#Nodes & \\#Edges  & \\#Features & \\#Labels           \\\\ \\midrule\nCora    & 2,708    & 5,429     & 1,433       & 7            \\\\\nCiteSeer & 3,327   & 9,104    & 3,703        & 6  \\\\\nReddit  & 232,965  & 23,213,838 & 602        & 41           \\\\\nAmazon  & 13,752   & 491,722   & 767        & 10            \\\\ \nPubmed  & 19,717   & 88,648    & 500        & 3            \\\\ \n\\bottomrule\n\\end{tabular}%\n}%\\vspace{-0.1in}\n\\end{table}",
            "tab:node_level": "\\begin{table*}[]\n\\centering\n\\caption{Node-level performance (\\%) with 100-shot setting. IMP (\\%): the average improvement of prompt over the rest.}%\\vspace{-0.15in}\n\\label{tab:node_level}\n\\resizebox{0.9\\textwidth}{!}{%\n\\begin{tabular}{@{}p{0.07\\textwidth}<{\\centering}c|p{0.02\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}@{}}\n\\toprule\n\\multirow{2}{*}{\\makecell[c]{Training\\\\ schemes}}     & \\multirow{2}{*}{Methods} & \\multicolumn{3}{c|}{Cora}       & \\multicolumn{3}{c|}{CiteSeer}    & \\multicolumn{3}{c|}{Reddit}     & \\multicolumn{3}{c|}{Amazon} & \\multicolumn{3}{c}{Pubmed}  \\\\\n                                      &                          & Acc & F1 & AUC & Acc & F1 & AUC & Acc & F1 & AUC & Acc & F1 & AUC & Acc & F1 & AUC \\\\ \\midrule\n\\multirow{3}{*}{supervised}           \n& GAT                        & 74.45    & 73.21    & 82.97     & 83.00    & 83.20    & 89.33     & 55.64    & 62.03    & 65.38     & 79.00    & 73.42    & 97.81     & 75.00    & 77.56    & 79.72     \\\\\n                                      & GCN                        & 77.55    & 77.45    & 83.71     & 88.00    & 81.79    & 94.79     & 54.38    & 52.47    & 56.82     & 95.36    & 93.99    & 96.23     & 53.64    & 66.67    & 69.89     \\\\\n                                      & GT          & 74.25    & 75.21    & 82.04     & 86.33    & 85.62    & 90.13     & 61.50    & 61.38    & 65.56     & 85.50    & 86.01    & 93.01     & 51.50    & 67.34    & 71.91     \n\\\\\\midrule\n\\multirow{6}{*}{\\makecell[c]{pre-train \\\\+\\\\  fine-tune}} \n& GraphCL+GAT                & 76.05    & 76.78    & 81.96     & 87.64    & 88.40    & 89.93     & 57.37    & 66.42    & 67.43     & 78.67    & 72.26    & 95.65     & 76.03    & 77.05    & 80.02     \\\\\n                                      & GraphCL+GCN                & 78.75    & 79.13    & 84.90     & 87.49    & 89.36    & 90.25     & 55.00    & 65.52    & 74.65     & 96.00    & 95.92    & 98.33     & 69.37    & 70.00    & 74.74     \\\\\n                                      & GraphCL+GT  & 73.80    & 74.12    & 82.77     & 88.50    & 88.92    & 91.25     & 63.50    & 66.06    & 68.04     & 94.39    & 93.62    & 96.97     & 75.00    & 78.45    & 75.05     \\\\\n                                      & SimGRACE+GAT               & 76.85    & 77.48    & 83.37     & 90.50    & 91.00    & 91.56     & 56.59    & 65.47    & 67.77     & 84.50    & 84.73    & 89.69     & 72.50    & 68.21    & 81.97     \\\\\n                                      & SimGRACE+GCN               & 77.20    & 76.39    & 83.13     & 83.50    & 84.21    & 93.22     & 58.00    & 55.81    & 56.93     & 95.00    & 94.50    & 98.03     & 77.50    & 75.71    & 87.53     \\\\\n                                      & SimGRACE+GT & 77.40    & 78.11    & 82.95     & 87.50    & 87.05    & 91.85     & 66.00    & 69.95    & 70.03     & 79.00    & 73.42    & 97.58     & 70.50    & 73.30    & 74.22     \n\\\\\\midrule\n\\multirow{6}{*}{prompt}               \n& GraphCL+GAT                & 76.50    & 77.26    & 82.99     & 88.00    & 90.52    & 91.82     & 57.84    & 67.02    & 75.33     & 80.01    & 75.62    & 97.96     & 77.50    & 78.26    & 83.02     \\\\\n                                      & GraphCL+GCN                & 79.20    & 79.62    & 85.29     & 88.50    & 91.59    & 91.43     & 56.00    & 68.57    & 78.82     & 96.50    & 96.37    & 98.70     & 72.50    & 72.64    & 79.57     \\\\\n                                      & GraphCL+GT  & 75.00    & 76.00    & 83.36     & 91.00    & 91.00    & 93.29     & 65.50    & 66.08    & 68.86     & 95.50    & 95.43    & 97.56     & 76.50    & 79.11    & 76.00     \\\\\n                                      & SimGRACE+GAT               & 76.95    & 78.51    & 83.55     & 93.00    & 93.14    & 92.44     & 57.63    & 66.64    & 69.43     & 95.50    & 95.43    & 97.56     & 73.00    & 74.04    & 81.89     \\\\\n                                      & SimGRACE+GCN               & 77.85    & 76.57    & 83.79     & 90.00    & 89.47    & 94.87     & 59.50    & 55.97    & 59.46     & 95.00    & 95.24    & 98.42     & 78.00    & 78.22    & 87.66     \\\\\n                                      & SimGRACE+GT & 78.75    & 79.53    & 85.03     & 91.00    & 91.26    & 95.62     & 69.50    & 71.43    & 70.75     & 86.00    & 83.72    & 98.24     & 73.00    & 73.79    & 76.64  \n\\\\ \\midrule\n\\multicolumn{2}{c|}{IMP (\\%)}                                        & 1.47     & 1.94     & 1.10      & 3.81     & 5.25     & 2.05      & 3.97     & 5.04     & 6.98      & 4.49&\t5.84&\t2.24  & 8.81     & 4.55     & 4.62      \\\\     \n\\midrule  \n\\multicolumn{2}{c|}{\\makecell[c]{Reported Acc of GPPT (Label Ratio 50\\%)}}        & 77.16    & --     & --      & 65.81     & --    & --     & 92.13     & --     & --      & 86.80  & -- & --  & 72.23    & --    & --      \\\\ \\cline{1-2}\n\\multicolumn{2}{c|}{\\makecell[c]{appr. Label Ratio of our 100-shot setting}}  & \\multicolumn{3}{c|}{$\\sim 25\\% $}       & \\multicolumn{3}{c|}{$\\sim 18\\% $}    & \\multicolumn{3}{c|}{$\\sim 1.7\\% $}     & \\multicolumn{3}{c|}{$\\sim 7.3\\% $} & \\multicolumn{3}{c}{$\\sim 1.5\\% $}  \\\\\n\\bottomrule\n\\end{tabular}%\n}%\\vspace{-0.1in}\n\\end{table*}",
            "tab:trans_amazon": "\\begin{table}[h]\n\\centering%\\vspace{-0.1in}\n\\caption{Transferability (\\%) on Amazon from different level tasks spaces. Source tasks: graph-level tasks and node-level tasks. Target task: edge-level tasks.}%\\vspace{-0.15in}\n\\label{tab:trans_amazon}\n\\resizebox{0.4\\textwidth}{!}{%\n\\begin{tabular}{@{}ll|lll@{}}\n\\toprule\nSource task                  & Methods       & Accuracy & F1-score & AUC score \\\\ \\midrule\n\\multirow{3}{*}{graph level} & hard & 51.50    & 65.96    & 40.34     \\\\\n                             & fine-tune     & 62.50    & 70.59    & 53.91     \\\\\n                             & prompt        & 70.50    & 71.22    & 74.02     \\\\ \\midrule\n\\multirow{3}{*}{node level}  & hard & 40.50    & 11.85    & 29.48     \\\\\n                             & fine-tune     & 46.00    & 54.24    & 37.26     \\\\\n                             & prompt        & 59.50    & 68.73    & 55.90     \\\\ \\bottomrule\n\\end{tabular}%\n}\n\\end{table}",
            "tab:trans_domains": "\\begin{table}[h]\n\\centering\n\\caption{Transferability (\\%) from different domains. Source domains: Amazon and PubMed. Target domain: Cora}%\\vspace{-0.1in}\n\\label{tab:trans_domains}\n% %\\vspace{-0.2in}\n\\resizebox{0.45\\textwidth}{!}{%\n% \\begin{tabular}{@{}p{0.03\\textwidth}<{\\centering}p{0.03\\textwidth}<{\\centering}|p{0.057\\textwidth}<{\\centering}p{0.057\\textwidth}<{\\centering}p{0.05\\textwidth}<{\\centering}|p{0.057\\textwidth}<{\\centering}p{0.068\\textwidth}<{\\centering}p{0.05\\textwidth}<{\\centering}@{}}\n\\begin{tabular}{@{}cc|ccc|ccc@{}}\n\\toprule\n\\multicolumn{2}{c|}{\\makecell[c]{Source\\\\Domains}}    & \\multicolumn{3}{c|}{Amazon}        & \\multicolumn{3}{c}{PubMed}         \\\\ \\midrule\nTasks                        &  & \\makecell[c]{hard} & \\makecell[c]{fine-tune} & prompt &\\makecell[c]{hard} & \\makecell[c]{fine-tune} & prompt  \\\\ \\midrule\n\\multirow{3}{*}{\\makecell[c]{node\\\\level}}  & Acc     & 26.9          & 64.14     & 65.07  & 55.62         & 57.93     & 62.07  \\\\\n                             & F1      & 13.11         & 77.59     & 80.23  & 66.33         & 70.00     & 76.60  \\\\\n                             & AUC     & 17.56         & 88.79     & 92.59  & 82.34         & 83.34     & 88.46  \\\\ \\midrule\n\\multirow{3}{*}{\\makecell[c]{edge\\\\level}}  & Acc     & 17.00         & 77.00     & 82.00  & 10.00         & 90.50     & 96.50  \\\\\n                             & F1      & 10.51         & 81.58     & 84.62  & 2.17          & 89.73     & 91.80  \\\\\n                             & AUC     & 4.26          & 94.27     & 96.19  & 6.15          & 93.89     & 94.70  \\\\ \\midrule\n\\multirow{3}{*}{\\makecell[c]{graph\\\\level}} & Acc     & 46.00         & 87.50     & 88.00  & 50.00         & 91.00     & 95.50  \\\\\n                             & F1      & 62.76         & 89.11     & 88.12  & 10.00          & 93.90     & 95.60  \\\\\n                             & AUC     & 54.23         & 86.33     & 94.99  & 90.85         & 91.47     & 98.47  \\\\ \\bottomrule\n\\end{tabular}%\n}\n% %\\vspace{-0.1in}\n\\end{table}",
            "tab:num_par": "\\begin{table}[h]\n\\centering %%\\vspace{-0.05in}\n% \\caption{The number of tunable parameters of supervised methods and the prompt method. RED (\\%): average reduction of the prompt method to baselines.}%\\vspace{-0.15in}\n\\caption{Tunable parameters comparison. RED (\\%): average reduction of the prompt method to others.}%\\vspace{-0.15in}\n\\label{tab:num_par}\n\\resizebox{0.45\\textwidth}{!}{%\n\\begin{tabular}{@{}c|ccccc|c@{}}\n\\toprule\nMethods           & Cora & CiteSeer & Reddit & Amazon & Pubmed & RED (\\%)\\\\ \\midrule\nGAT               & $\\sim$ 155K  &  $\\sim$ 382K      &  $\\sim$ 75K     &  $\\sim$ 88K     &  $\\sim$ 61K & 95.4$\\downarrow$  \\\\\nGCN               &  $\\sim$ 154K  &  $\\sim$ 381K      &  $\\sim$ 75K     &  $\\sim$ 88K     &  $\\sim$ 61K  & 95.4$\\downarrow$ \\\\\nGT &  $\\sim$ 615K  &  $\\sim$ 1.52M     &  $\\sim$ 286K    &  $\\sim$ 349K    &  $\\sim$ 241K & 98.8$\\downarrow$ \\\\\nprompt            &  $\\sim$ 7K    &  $\\sim$ 19K       &  $\\sim$ 3K      &  $\\sim$ 4K      &  $\\sim$ 3K &  --   \\\\ \\bottomrule\n\\end{tabular}%\n}%\\vspace{-0.15in}\n\\end{table}",
            "tab:error": "\\begin{table}[h]\n\\centering %\\vspace{-0.1in}\n\\caption{Error bound discussed by section \\ref{subsec:flex}\n% between the original graph and the manipulated graph from the pre-trained graph model. \nRED (\\%): average reduction of each method to the original error.}%\\vspace{-0.15in}\n\\label{tab:error}\n\\resizebox{0.45\\textwidth}{!}{%\n\\begin{tabular}{@{}p{0.14\\textwidth}<{\\centering}c|ccc|c@{}}\n\\toprule\n\\makecell[c]{Prompt Solutions} & \\makecell[c]{Token\\\\ Number} & \\makecell[c]{Drop \\\\Nodes} & \\makecell[c]{Drop \\\\Edges} & \\makecell[c]{Mask \\\\Features} & RED (\\%) \\\\ \\midrule\n\\makecell[c]{Original Error \\\\(without prompt)} & 0        & 0.9917    & 2.6330    & 6.8209  &  -   \\\\\\midrule\n\\makecell[c]{Naive Prompt \\\\(Equation \\ref{equ:error_bound_naive})} & 1       & 0.8710    & 0.5241    & 2.0835  &  66.70$\\downarrow$   \\\\\\midrule\n\\multirow{3}{*}{\\makecell[c]{Our Prompt Graph\\\\ (with token, structure,\\\\ and inserting patterns)}} & 3         & 0.0875    & 0.2337    & 0.6542  & 90.66$\\downarrow$    \\\\\n& 5         & 0.0685    & 0.1513    & 0.4372  & 93.71$\\downarrow$    \\\\\n& 10        & 0.0859    & 0.1144    & 0.2600  & 95.59$\\downarrow$    \\\\ \\bottomrule\n\\end{tabular}%\n}%\\vspace{-0.15in}\n\\end{table}",
            "tab:data_graph_more": "\\begin{table}[t]\n\\centering\n\\caption{Statistics of Additional Datasets}\n\\label{tab:data_graph_more}\n\\resizebox{0.48\\textwidth}{!}{%\n\\begin{tabular}{@{}p{0.11\\textwidth}<{\\centering}|p{0.057\\textwidth}<{\\centering}|p{0.057\\textwidth}<{\\centering}|p{0.061\\textwidth}<{\\centering}|p{0.047\\textwidth}<{\\centering}|c@{}}\n\\toprule\nDataset        & \\#Nodes & \\#Edges & \\#Features & \\#Labels & \\#Graphs \\\\ \\midrule\nENZYMES        & 19,580   & 74,564   & 21         & 6      & 600       \\\\\nProteinsFull & 43,471   & 162,088  & 32         & 2        & 1,113      \\\\\\midrule\nMovielens   &10,352 & 100,836  & 100         & -       & 1       \\\\\nQM9            & 2,333,625 & 4,823,498 & 16         & -     & 129,433    \\\\\\midrule %19\n% Synthie        & 38,000   & 138,342  & 15         & 4       & 400       \\\\\nPersonalityCafe   &  100,340   & 3,788,032 &   100      &   0  &  1     \\\\\nFacebook  & 4,039 &  88,234    &  1,283  &    0  &    1  \\\\\n\\bottomrule\n\\end{tabular}%\n}\n\\end{table}",
            "tab:app_multiclass": "\\begin{table}[t]\n\\centering\n\\caption{Multi-class node classification (100-shots)}\n\\label{tab:app_multiclass}\n\\resizebox{0.48\\textwidth}{!}{%\n\\begin{tabular}{@{}c|cc|cc@{}}\n\\toprule\n\\multirow{2}{*}{Methods} & \\multicolumn{2}{c|}{Cora} & \\multicolumn{2}{c}{CiteSeer} \\\\\n     & Acc (\\%) & Macro F1 (\\%) & Acc (\\%)& Macro F1  (\\%)     \\\\ \\midrule\nSupervised    & 74.11  & 73.26        & 77.33          & 77.64 \\\\\\midrule\nPre-train and Fine-tune & 77.97      & 77.63        & 79.67     & 79.83 \\\\ \\midrule\nPrompt     & 80.12      & 79.75        &  80.50   & 80.65    \\\\\nPrompt w/o h    & 78.55          & 78.18            & 80.00     & 80.05  \\\\ \\midrule\n\\makecell[c]{Reported Acc of GPPT\\\\ (Label Ratio 50\\%)}  & 77.16      & -            & 65.81       & -   \\\\ \n% \\midrule\n% \\makecell[c]{appr. Label Ratio of our 100 shots}  & \\multicolumn{2}{c|}{$\\sim 25\\% $}   & \\multicolumn{2}{c}{$\\sim 18\\% $}  \\\\ \n\\bottomrule\n\\end{tabular}%\n}\n\\end{table}",
            "tab:app_graph_multiclass": "\\begin{table}[t]\n\\centering\n\\caption{Additional graph-level classification.}%\\vspace{-0.15in}\n\\label{tab:app_graph_multiclass}\n\\resizebox{0.48\\textwidth}{!}{%\n\\begin{tabular}{@{}c|cc|cc@{}}\n\\toprule\n\\multirow{2}{*}{Methods}  & \\multicolumn{2}{c|}{ProteinsFull (100 shots)} & \\multicolumn{2}{c}{ENZYMES (50 shots)} \\\\\n     & Acc (\\%)  & Macro F1 (\\%)   & Acc (\\%)& Macro F1 (\\%)      \\\\ \\midrule\nSupervised    &  66.64 &  65.03   &  31.33  & 30.25 \\\\%\\midrule\nPre-train + Fine-tune & 66.50  &66.43    & 34.67   & 33.94  \\\\ %\\midrule\nPrompt     &70.50  & 70.17    & 35.00  & 34.92 \\\\\nPrompt w/o h   & 68.50  & 68.50 &  36.67  &  34.05\n\\\\ \\bottomrule\n\\end{tabular}%\n}\n\\end{table}",
            "tab:app_reg": "\\begin{table}[t]\n\\centering\n\\caption{Graph/edge-level regression with few-shot settings.}%\\vspace{-0.15in}\n\\label{tab:app_reg}\n\\resizebox{0.48\\textwidth}{!}{%\n\\begin{tabular}{@{}c|cc|cc@{}}\n\\toprule\nTasks    & \\multicolumn{2}{c|}{Graph Regression} & \\multicolumn{2}{c}{Edge Regression} \\\\\nDatasets & \\multicolumn{2}{c|}{QM9 (100 shots)} & \\multicolumn{2}{c}{MovieLens (100 shots)} \\\\\nMethods     & MAE  & MSE  & MAE  & MSE     \\\\ \\midrule\nSupervised    & 0.3006  & 0.1327   &0.2285 & 0.0895   \\\\%\\midrule\nPre-train + Fine-tune & 0.1539  & 0.0351  &0.2171  &0.0774  \\\\ %\\midrule\nPrompt     &0.1384  & 0.0295   & 0.1949 &  0.0620   \\\\\nPrompt w/o h   & 0.1424  &0.0341   & 0.2120    & 0.0744      \n\\\\ \\bottomrule\n\\end{tabular}%\n}\n\\end{table}",
            "tab:link": "\\begin{table}[h]\n\\centering\n\\caption{Evaluation on link prediction (100-shot settings)}%\\vspace{-0.15in}\n\\label{tab:link}\n\\resizebox{0.48\\textwidth}{!}{%\n\\begin{tabular}{@{}c|cccc|cccc@{}}\n\\toprule\nDatasets & \\multicolumn{4}{c|}{PersonalityCafe} & \\multicolumn{4}{c}{Facebook} \\\\\nMethods     & MRR  & Hit@1 & Hit@5 & Hit@10& MRR  & Hit@1 & Hit@5 & Hit@10     \\\\ \\midrule\nSupervised  &0.18 & 0.04&0.24 &0.56  & 0.13&0.06 &0.17 &0.35 \\\\\\midrule\n\\makecell[c]{Pre-train \\\\+ Fine-tune}  & 0.13&0.05 &0.12 &0.34  &0.10 &0.02 & 0.16& 0.33\\\\ \\midrule\nPrompt   &0.20 &0.07 &0.32 & 0.60 &0.19 &0.10 &0.23 &0.39  \\\\\nPrompt w/o h   & 0.20&0.06 &0.30 & 0.50 &0.15 &0.09 &0.15 &0.33\\\\\\midrule\n\\makecell[c]{Label Ratio}  & \\multicolumn{4}{c|}{\\makecell[c]{$\\sim 0.003\\%$ (training) \\\\ $\\sim 80\\%$(message passing)}}   & \\multicolumn{4}{c}{\\makecell[c]{$\\sim 0.1\\%$ (training) \\\\ $\\sim 80\\%$(message passing)}}  \n\\\\ \\bottomrule\n\\end{tabular}%\n}\n\\end{table}",
            "tab:edge_level": "\\begin{table*}[h]\n\\centering\n\\caption{Edge-level performance (\\%) with 100-shot setting. IMP (\\%): the average improvement of prompt over the rest.}%\\vspace{-0.15in}\n\\label{tab:edge_level}\n\\resizebox{0.99\\textwidth}{!}{%\n\\begin{tabular}{@{}p{0.07\\textwidth}<{\\centering}c|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}@{}}\n\\toprule\n\\multirow{2}{*}{\\makecell[c]{Training\\\\ schemes}}     & \\multirow{2}{*}{Methods} & \\multicolumn{3}{c|}{Cora}       & \\multicolumn{3}{c|}{CiteSeer}    & \\multicolumn{3}{c|}{Reddit}     & \\multicolumn{3}{c|}{Amazon} & \\multicolumn{3}{c}{Pubmed}  \\\\\n                                      &                          & Acc & F1 & AUC & Acc & F1 & AUC & Acc & F1 & AUC & Acc & F1 & AUC & Acc & F1 & AUC \\\\ \\midrule\n\\multirow{3}{*}{supervised}           \n & GAT                        & 84.30    & 83.35    & 85.43     & 68.63    & 82.79    & 89.98     & 93.50    & 93.03    & 94.48     & 85.00    & 82.67    & 88.78     & 80.05    & 77.07    & 79.26     \\\\\n                                      & GCN                        & 83.85    & 84.90    & 85.90     & 66.67    & 81.01    & 89.62     & 83.50    & 84.51    & 91.43     & 89.00    & 89.81    & 98.85     & 79.00    & 77.73    & 80.19     \\\\\n                                      & GT          & 85.95    & 86.01    & 87.25     & 69.70    & 83.03    & 82.46     & 95.50    & 94.52    & 96.89     & 94.00    & 93.62    & 99.34     & 74.50    & 65.77    & 85.19      \n\\\\\\midrule\n\\multirow{6}{*}{\\makecell[c]{pre-train \\\\+\\\\  fine-tune}}  \n& GraphCL+GAT                & 85.64    & 85.97    & 87.22     & 72.67    & 82.85    & 92.98     & 94.00    & 93.75    & 98.43     & 86.50    & 86.96    & 84.47     & 85.54    & 83.92    & 91.78     \\\\\n                                      & GraphCL+GCN                & 86.36    & 85.82    & 86.39     & 70.67    & 81.82    & 90.00     & 94.00    & 93.94    & 97.04     & 86.50    & 84.92    & 98.41     & 80.00    & 78.05    & 85.21     \\\\\n                                      & GraphCL+GT  & 85.79    & 86.27    & 87.51     & 86.01    & 85.38    & 88.58     & 96.67    & 95.38    & 97.65     & 96.50    & 97.42    & 98.12     & 85.50    & 87.11    & 81.68     \\\\\n                                      & SimGRACE+GAT               & 86.85    & 86.80    & 88.12     & 85.33    & 85.26    & 90.04     & 95.50    & 95.54    & 97.11     & 87.50    & 86.34    & 88.65     & 80.01    & 81.03    & 86.89     \\\\\n                                      & SimGRACE+GCN               & 85.62    & 85.38    & 87.83     & 89.33    & 86.34    & 95.10     & 88.00    & 87.88    & 94.49     & 98.45    & 97.57    & 98.29     & 80.50    & 82.58    & 91.22     \\\\\n                                      & SimGRACE+GT & 86.35    & 87.03    & 88.47     & 86.00    & 89.52    & 90.42     & 97.50    & 95.54    & 96.92     & 96.50    & 96.45    & 99.09     & 81.00    & 79.57    & 85.69      \n\\\\\\midrule\n\\multirow{6}{*}{prompt}               \n  & GraphCL+GAT                & 86.85    & 86.88    & 87.92     & 76.67    & 83.00    & 96.22     & 95.36    & 94.50    & 98.65     & 88.50    & 86.00    & 87.15     & 86.50    & 84.75    & 92.61     \\\\\n                                      & GraphCL+GCN                & 86.87    & 86.80    & 87.79     & 76.67    & 82.37    & 93.54     & 95.50    & 95.52    & 97.75     & 86.96    & 85.63    & 98.66     & 81.50    & 78.61    & 86.11     \\\\\n                                      & GraphCL+GT  & 87.02    & 86.90    & 87.97     & 86.67    & 88.00    & 91.10     & 97.03    & 95.94    & 98.62     & 98.50    & 98.48    & 98.53     & 86.50    & 87.78    & 82.21     \\\\\n                                      & SimGRACE+GAT               & 87.37    & 87.33    & 88.37     & 91.33    & 92.30    & 95.18     & 95.72    & 96.69    & 97.64     & 95.50    & 95.38    & 98.89     & 80.50    & 82.03    & 87.86     \\\\\n                                      & SimGRACE+GCN               & 86.85    & 86.80    & 88.67     & 93.47    & 97.69    & 97.08     & 88.00    & 88.12    & 95.10     & 98.50    & 98.52    & 98.55     & 81.00    & 83.76    & 91.41     \\\\\n                                      & SimGRACE+GT & 87.30    & 87.24    & 88.74     & 95.33    & 96.52    & 94.46     & 98.00    & 98.02    & 99.38     & 98.50    & 98.52    & 99.10     & 82.50    & 80.45    & 87.61       \n\\\\\\midrule\n\\multicolumn{2}{c|}{IMP(\\%)}                                        & 1.65     & 1.48     & 1.28      & 12.26    & 6.84     & 5.21      & 1.94     & 2.29     & 1.88      & 3.63\t&3.44&\t2.03  & 2.98     & 4.66     & 3.21   \\\\\\bottomrule\n\\end{tabular}%\n}%\\vspace{-0.1in}\n\\end{table*}",
            "tab:graph_level": "\\begin{table*}[h]\n\\centering\n\\caption{Graph-level performance (\\%) with 100-shot setting. IMP (\\%): the average improvement of prompt over the rest.}%\\vspace{-0.15in}\n\\label{tab:graph_level}\n\\resizebox{0.99\\textwidth}{!}{%\n\\begin{tabular}{@{}p{0.07\\textwidth}<{\\centering}c|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}|p{0.025\\textwidth}<{\\centering}p{0.025\\textwidth}<{\\centering}p{0.035\\textwidth}<{\\centering}@{}}\n\\toprule\n\\multirow{2}{*}{\\makecell[c]{Training\\\\ schemes}}     & \\multirow{2}{*}{Methods} & \\multicolumn{3}{c|}{Cora}       & \\multicolumn{3}{c|}{CiteSeer}    & \\multicolumn{3}{c|}{Reddit}     & \\multicolumn{3}{c|}{Amazon} & \\multicolumn{3}{c}{Pubmed}  \\\\\n                                      &                          & Acc & F1 & AUC & Acc & F1 & AUC & Acc & F1 & AUC & Acc & F1 & AUC & Acc & F1 & AUC \\\\ \\midrule\n\\multirow{3}{*}{supervised}      \n& GAT                        & 84.40    & 86.44    & 87.60     & 86.50    & 84.75    & 91.75     & 79.50    & 79.76    & 82.11     & 93.05    & 94.04    & 93.95     & 69.86    & 72.30    & 66.92     \\\\\n                                                                             & GCN                        & 83.95    & 86.01    & 88.64     & 85.00    & 82.56    & 93.33     & 64.00    & 70.00    & 78.60     & 91.20    & 91.27    & 94.33     & 61.30    & 59.97    & 66.29     \\\\\n                                                                             & GT          & 85.85    & 85.90    & 89.59     & 77.50    & 75.85    & 89.72     & 69.62    & 68.01    & 66.32     & 90.33    & 91.39    & 94.39     & 60.30    & 60.88    & 67.62 \n\\\\\\midrule\n\\multirow{6}{*}{\\makecell[c]{pre-train  \\\\ + \\\\fine-tune}}     \n & GraphCL+GAT                & 85.50    & 85.54    & 89.31     & 83.00    & 85.47    & 92.13     & 72.03    & 72.82    & 83.23     & 92.15    & 92.18    & 94.78     & 85.50    & 85.50    & 86.33     \\\\\n                                                                             & GraphCL+GCN                & 85.50    & 85.59    & 87.94     & 86.50    & 84.57    & 94.56     & 71.00    & 71.90    & 80.33     & 93.58    & 93.55    & 94.93     & 78.75    & 77.29    & 89.40     \\\\\n                                                                             & GraphCL+GT  & 85.95    & 85.05    & 87.92     & 84.50    & 81.87    & 88.36     & 69.63    & 70.06    & 81.35     & 91.68    & 91.55    & 94.78     & 86.85    & 86.93    & 88.91     \\\\\n                                                                             & SimGRACE+GAT               & 86.04    & 86.33    & 88.55     & 83.50    & 85.84    & 90.09     & 81.32    & 81.64    & 88.61     & 93.58    & 93.57    & 93.91     & 87.33    & 86.70    & 88.02     \\\\\n                                                                             & SimGRACE+GCN               & 85.95    & 86.05    & 89.33     & 84.50    & 86.46    & 91.60     & 80.50    & 81.52    & 89.11     & 90.73    & 90.52    & 94.85     & 85.26    & 84.64    & 86.99     \\\\\n                                                                             & SimGRACE+GT & 86.40    & 86.47    & 89.64     & 81.00    & 81.54    & 89.81     & 69.50    & 70.97    & 77.11     & 92.63    & 92.56    & 94.04     & 85.95    & 86.05    & 89.37     \n \\\\\\midrule\n\\multirow{6}{*}{prompt}\n& GraphCL+GAT                & 86.40    & 86.47    & 89.46     & 86.50    & 89.93    & 92.24     & 73.36    & 73.32    & 84.77     & 94.08    & 94.02    & 94.20     & 85.95    & 85.97    & 87.17     \\\\\n                                                                             & GraphCL+GCN                & 85.95    & 86.01    & 88.95     & 87.00    & 85.87    & 95.35     & 72.50    & 72.91    & 81.37     & 94.05    & 94.05    & 94.98     & 84.60    & 84.43    & 88.96     \\\\\n                                                                             & GraphCL+GT  & 86.05    & 85.17    & 88.93     & 85.50    & 85.28    & 88.60     & 72.63    & 70.97    & 82.39     & 92.63    & 92.64    & 94.82     & 87.03    & 86.96    & 89.10     \\\\\n                                                                             & SimGRACE+GAT               & 86.67    & 86.36    & 89.51     & 87.50    & 88.37    & 91.47     & 82.62    & 83.33    & 89.41     & 93.35    & 94.66    & 94.61     & 87.75    & 87.69    & 88.88     \\\\\n                                                                             & SimGRACE+GCN               & 86.85    & 86.90    & 89.95     & 85.00    & 85.85    & 91.95     & 81.00    & 82.24    & 89.43     & 93.95    & 92.06    & 93.89     & 85.50    & 85.54    & 87.30     \\\\\n                                                                             & SimGRACE+GT & 86.85    & 86.87    & 89.75     & 87.50    & 86.63    & 90.85     & 76.50    & 80.82    & 86.84     & 94.05    & 94.06    & 94.96     & 86.40    & 86.50    & 89.74      \n\\\\\\midrule\n\\multicolumn{2}{c|}{IMP(\\%)}                                                                               & 1.12     & 0.43     & 0.79      & 3.52     & 4.54     & 0.53      & 4.69     & 4.31     & 6.13      &1.72&\t1.39&\t0.14 & 10.66    & 10.77    & 9.16     \\\\\n\\bottomrule\n\\end{tabular}%\n}\n\\end{table*}"
        },
        "figures": {
            "fig:prompt_tuning": "\\begin{figure}[t]\n    \\centering\n    \\includegraphics[width =0.35\\textwidth]{pic/finetune_prompt.pdf}%\\vspace{-0.1in}\n    \\caption{Fine-tuning, Pre-training, and Prompting.\n    % Prompt turning only adjusts a light-weighted prompt in the input space while keeps the pre-trained model frozen.\n    }%\\vspace{-0.35in}\n    \\label{fig:prompt_tuning}\n\\end{figure}",
            "fig:analogy": "\\begin{figure}[t]\n    \\centering\n    \\includegraphics[width =0.49\\textwidth]{pic/nlp2graph3.pdf}\n    %\\vspace{-0.2in}\n    \\caption{Our graph prompt inspired by the language prompt.}%\\vspace{-0.2in}\n    \\label{fig:analogy}\n\\end{figure}",
            "fig:hierarchy": "\\begin{figure}[t]\n\\centering\n\\subfloat[NLP tasks]{\n\\label{fig:hierarchy_2}\n\\includegraphics[width=0.16\\textwidth]{pic/nlp_subspace.pdf}%\n}\n\\subfloat[graph tasks]{\n\\label{fig:hierarchy_1}\n\\includegraphics[width=0.16\\textwidth]{pic/operation_space.pdf}%\n}%\\vspace{-0.1in}\n\\caption{Task space in NLP and graph}%\\vspace{-0.2in}\n\\label{fig:hierarchy}\n\\end{figure}",
            "fig:ig": "\\begin{figure}[h]\n\\centering\n\\subfloat[Induced graphs for nodes]{\n\\label{fig:ign}\n\\includegraphics[width=0.3\\textwidth]{pic/node_graph.pdf}\n}%\\vspace{-0.1in}\n\\\\\n\\subfloat[Induced graphs for edges]{\n\\label{fig:ige}\n\\includegraphics[width=0.3\\textwidth]{pic/edge_graph.pdf}%\n}%\\vspace{-0.1in}\n\\caption{Induced graphs for nodes and edges}%\\vspace{-0.2in}\n\\label{fig:ig}\n\\end{figure}",
            "fig:abl": "\\begin{figure}[h]\n    \\centering\n    \\includegraphics[width =0.45\\textwidth]{pic/ablation.pdf}%\\vspace{-0.1in}\n    \\caption{Effectiveness of main components}%\\vspace{-0.2in}\n    \\label{fig:abl}\n\\end{figure}",
            "fig:token_num": "\\begin{figure}[h]\n    \\centering\n    \\includegraphics[width =0.35\\textwidth]{pic/token_num.pdf}%\\vspace{-0.15in}\n    \\caption{Impact of token numbers}\n    \\label{fig:token_num}%\\vspace{-0.15in}\n\\end{figure}",
            "fig:loss": "\\begin{figure}[h]\n    \\centering\n    \\includegraphics[width =0.33\\textwidth]{pic/loss.pdf}%\\vspace{-0.2in}\n    \\caption{Training losses with epochs. Mean values and 65\\% confidence intervals by 5 repeats with different seeds.}%\\vspace{-0.15in}\n    \\label{fig:loss}\n\\end{figure}",
            "fig:vis": "\\begin{figure}[h]\n\\centering %\\vspace{-0.1in}\n\\subfloat[pre-trained]{\n\\label{fig:init}\n\\includegraphics[width=0.24\\textwidth]{pic/gcn.pdf}\n}\n\\subfloat[prompt]{\n\\label{fig:prompt}\n\\includegraphics[width=0.24\\textwidth]{pic/prompt.pdf}\n}%\\vspace{-0.15in}\n\\caption{Visualization of graph representations.}%\\vspace{-0.15in}\n\\label{fig:vis}\n\\end{figure}"
        },
        "equations": {
            "eq:1": "\\begin{equation}\nw_{ik}=\\left\\{\n            \\begin{array}{cl}\n                 \\sigma(\\mathbf{p}_k\\cdot \\mathbf{x}_i^T), & \\text{if } \\sigma(\\mathbf{p}_k\\cdot \\mathbf{x}_i^T)>\\delta \\\\\n                 0, & \\text{otherwise}\n            \\end{array}\n        \\right.\n\\end{equation}",
            "eq:2": "\\begin{equation}\n\\begin{aligned}\n\\theta_i^k &=\\theta_i^{k-1}-\\alpha \\nabla_{\\theta_i^{k-1}} \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{s}}\\left(f_{\\theta_i^{k-1}, \\phi_i^{k-1}|\\pi^{*}}\\right) \\\\\n\\phi_i^k &=\\phi_i^{k-1}-\\alpha \\nabla_{\\phi_i^{k-1}}\\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{s}}\\left(f_{\\theta_i^{k-1}, \\phi_i^{k-1}|\\pi^{*}}\\right) \n\\end{aligned}\n\\end{equation}",
            "eq:3": "\\begin{equation}\n\\theta^{*}, \\phi^{*}=\\underset{\\theta, \\phi}{\\arg \\min }\\sum_{\\tau_i \\in \\mathcal{T}} \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{q}}\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\right) \n\\end{equation}",
            "eq:equ:meta_update": "\\begin{equation}\\label{equ:meta_update}\n\\begin{aligned}\n\\theta \\!\\leftarrow & \\theta-\\beta \\cdot g_\\theta^{second} \\\\\n=& \\theta-\\beta \\cdot \\sum_{\\tau_i \\in \\mathcal{T}} \\nabla_\\theta \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{q}}\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\right) \\\\\n=&\\theta-\\beta \\cdot \\sum_{\\tau_i \\in \\mathcal{T}} \\nabla_{\\theta_i} \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{q}}\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\right) \\cdot \\nabla_\\theta\\left(\\theta_i\\right) \\\\\n=&\\theta\\!-\\beta\\! \\cdot \\!\\!\\!\\!\\sum_{\\tau_i \\in \\mathcal{T}} \\!\\!\\! \\nabla_{\\theta_i} \\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{q}}\\!\\!\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\right)\\!\\cdot \\!\\left(\\mathbf{I}\\!-\\!\\alpha \\mathbf{H}_\\theta\\!\\left(\\mathcal{L}_{\\mathcal{D}_{\\tau_i}^{s}}\\left(f_{\\theta_i, \\phi_i|\\pi^{*}}\\!\\right)\\!\\right)\\!\\right)\n\\end{aligned}\n\\end{equation}",
            "eq:equ:error_bound_naive": "\\begin{equation}\\label{equ:error_bound_naive}%\\vspace{-0.05in}\n    \\varphi^*\\left(\\mathbf{A}, \\mathbf{X}+p^*\\right)=\\varphi^*({g}(\\mathbf{A}, \\mathbf{X}))+O_{p\\varphi}\n\\end{equation}",
            "eq:equ:error_bound_new": "\\begin{equation}\\label{equ:error_bound_new}%\\vspace{-0.05in}\n    \\varphi^*\\left(\\psi(\\mathcal{G}, \\mathcal{G}_p^*)\\right)=\\varphi^*(\\mathbf{g}(\\mathbf{A}, \\mathbf{X}))+O^{*}_{p\\varphi}\n\\end{equation}"
        }
    }
}