{
    "meta_info": {
        "title": "PointPillars: Fast Encoders for Object Detection from Point Clouds",
        "abstract": "Object detection in point clouds is an important aspect of many robotics\napplications such as autonomous driving. In this paper we consider the problem\nof encoding a point cloud into a format appropriate for a downstream detection\npipeline. Recent literature suggests two types of encoders; fixed encoders tend\nto be fast but sacrifice accuracy, while encoders that are learned from data\nare more accurate, but slower. In this work we propose PointPillars, a novel\nencoder which utilizes PointNets to learn a representation of point clouds\norganized in vertical columns (pillars). While the encoded features can be used\nwith any standard 2D convolutional detection architecture, we further propose a\nlean downstream network. Extensive experimentation shows that PointPillars\noutperforms previous encoders with respect to both speed and accuracy by a\nlarge margin. Despite only using lidar, our full detection pipeline\nsignificantly outperforms the state of the art, even among fusion methods, with\nrespect to both the 3D and bird's eye view KITTI benchmarks. This detection\nperformance is achieved while running at 62 Hz: a 2 - 4 fold runtime\nimprovement. A faster version of our method matches the state of the art at 105\nHz. These benchmarks suggest that PointPillars is an appropriate encoding for\nobject detection in point clouds.",
        "author": "Alex H. Lang, Sourabh Vora, Holger Caesar, Lubing Zhou, Jiong Yang, Oscar Beijbom",
        "link": "http://arxiv.org/abs/1812.05784v2",
        "category": [
            "cs.LG",
            "cs.CV",
            "stat.ML"
        ],
        "additionl_info": "9 pages. v1 is initial submission to CVPR 2019. v2 is final version  accepted for publication at CVPR 2019"
    },
    "latex_extraction": {
        "content": {
            "section 1": {
                "name": "Introduction",
                "content": " \\label{sec:intro}\n\\squeeze\n\nDeploying autonomous vehicles (AVs) in urban environments poses a difficult technological challenge.\nAmong other tasks, AVs need to detect and track moving objects such as vehicles, pedestrians, and cyclists in realtime.\nTo achieve this, autonomous vehicles rely on several sensors out of which the \\lidar is arguably the most important.\nA \\lidar uses a laser scanner to measure the distance to the environment, thus generating a sparse point cloud representation.\nTraditionally, a \\lidar robotics pipeline interprets such point clouds as object detections through a bottom-up pipeline involving background subtraction, followed by spatiotemporal clustering and classification~\\cite{classic_lidar,himmelsbach2008lidar}.\n\nFollowing the tremendous advances in deep learning methods for computer vision,\na large body of literature has investigated to what extent this technology could be applied towards object detection from \\lidar point clouds~\\cite{voxelnet,hdnet,pixor,avod,mv3d,frustum,contfuse,second,complexyolo,roarnet}.\nWhile there are many similarities between the modalities, there are two key differences:\n1) the point cloud is a sparse representation, while an image is dense and\n2) the point cloud is 3D, while the image is 2D.\nAs a result object detection from point clouds does not trivially lend itself to standard image convolutional pipelines.\n\nSome early works focus on either using 3D convolutions~\\cite{engelcke2017vote3deep} or a projection of the point cloud into the image \\cite{fcl}.\nRecent methods tend to view the \\lidar point cloud from a bird's eye view~\\cite{mv3d, avod, voxelnet, pixor}.\nThis overhead perspective offers several advantages such as lack of scale ambiguity and the near lack of occlusion.\n\nHowever, the bird's eye view tends to be extremely sparse which makes direct application of convolutional neural networks impractical and inefficient.\nA common workaround to this problem is to partition the ground plane into a regular grid,\nfor example 10 x 10 cm, and then perform a hand crafted feature encoding method on the points in each grid cell~\\cite{mv3d, avod, complexyolo, pixor}.\nHowever, such methods may be sub-optimal since the hard-coded feature extraction method may not generalize to new configurations without significant engineering efforts.\nTo address these issues, and building on the PointNet design developed by Qi et al.~\\cite{pointnet}, VoxelNet~\\cite{voxelnet} was one of the first methods to truly do end-to-end learning in this domain.\nVoxelNet divides the space into voxels, applies a PointNet to each voxel, followed by a 3D convolutional middle layer to consolidate the vertical axis, after which a 2D convolutional detection architecture is applied.\nWhile the VoxelNet performance is strong, the inference time, at $4.4~H\\hspace{-.5mm}z$, is too slow to deploy in real time. Recently SECOND~\\cite{second} improved the inference speed of VoxelNet but the 3D convolutions remain a bottleneck.\n\nIn this work we propose PointPillars: a method for object detection in 3D that enables end-to-end learning with only 2D convolutional layers.\nPointPillars uses a novel encoder that learn features on pillars (vertical columns) of the point cloud to predict 3D oriented boxes for objects.\nThere are several advantages of this approach.\nFirst, by learning features instead of relying on fixed encoders, PointPillars can leverage the full information represented by the point cloud.\nFurther, by operating on pillars instead of voxels there is no need to tune the binning of the vertical direction by hand.\nFinally, pillars are highly efficient because all key operations can be formulated as 2D convolutions which are extremely  efficient to compute on a GPU.\nAn additional benefit of learning features is that PointPillars requires no hand-tuning to use different point cloud configurations.\nFor example, it can easily incorporate multiple lidar scans, or even radar point clouds.\n\nWe evaluated our PointPillars network on the public KITTI detection challenges which require detection of cars, pedestrians, and cyclists in either the bird's eye view (BEV) or 3D~\\cite{kitti}.\nWhile our PointPillars network is trained using only \\lidar point clouds, it dominates the current state of the art including methods that use lidar \\emph{and} images, thus establishing new standards for performance on both BEV and 3D detection (\\tableref{table:res_bev} and \\tableref{table:res_3d}). At the same time PointPillars runs at \\hertz, which is orders of magnitude faster than previous art. PointPillars further enables a trade off between speed and accuracy; in one setting we match state of the art performance at over $100~H\\hspace{-.5mm}z$ (\\figref{fig:speed_accuracy_val}). We have also released code (\\href{https://github.com/nutonomy/second.pytorch}{https://github.com/nutonomy/second.pytorch}) that can reproduce our results.\n\n\n\n",
                "subsection 1.1": {
                    "name": "Related Work",
                    "content": "\n\\squeeze\nWe start by reviewing recent work in applying convolutional neural networks toward object detection in general, and then focus on methods specific to object detection from \\lidar point clouds.\n\n\\squeeze\n",
                    "subsubsection 1.1.1": {
                        "name": "Object detection using CNNs",
                        "content": "\n\\squeeze\nStarting with the seminal work of Girshick et al.~\\cite{girshick2014rich} it was established that convolutional neural network~(CNN) architectures are state of the art for detection in images.\nThe series of papers that followed~\\cite{ren2015faster, he2017mask} advocate a two-stage approach to this problem, where in the first stage a region proposal network (RPN) suggests candidate proposals.\nCropped and resized versions of these proposals are then classified by a second stage network.\nTwo-stage methods dominated the important vision benchmark datasets such as COCO~\\cite{coco} over single-stage architectures originally proposed by Liu et al.~\\cite{ssd}.\nIn a single-stage architecture a dense set of anchor boxes is regressed and classified in a single stage into a set of predictions providing a fast and simple architecture.\nRecently Lin et al.~\\cite{retinanet} convincingly argued that with their proposed focal loss function a single stage method is superior to two-stage methods, both in terms of accuracy \\emph{and} runtime. \nIn this work, we use a single stage method.\n\n\\squeeze\n"
                    },
                    "subsubsection 1.1.2": {
                        "name": "Object detection in \\lidar point clouds",
                        "content": "\n\\squeeze\nObject detection in point clouds is an intrinsically three dimensional problem.\nAs such, it is natural to deploy a 3D convolutional network for detection, which is the paradigm of several early works~\\cite{engelcke2017vote3deep,li20173d}.\nWhile providing a straight-forward architecture, these methods are slow; e.g. Engelcke et al.~\\cite{engelcke2017vote3deep} require $0.5s$ for inference on a single point cloud.\nMost recent methods improve the runtime by projecting the 3D point cloud either onto the ground plane~\\cite{avod, mv3d} or the image plane~\\cite{fcl}.\nIn the most common paradigm the point cloud is organized in voxels and the set of voxels in each vertical column is encoded into a fixed-length, hand-crafted, feature encoding to form a pseudo-image which can be processed by a standard image detection architecture.\nSome notable works here include MV3D~\\cite{mv3d}, AVOD~\\cite{avod}, PIXOR~\\cite{pixor} and Complex YOLO~\\cite{complexyolo} which all use variations on the same fixed encoding paradigm as the first step of their architectures.\nThe first two methods additionally fuse the \\lidar features with image features to create a multi-modal detector.\nThe fusion step used in MV3D and AVOD forces them to use two-stage detection pipelines, while PIXOR and Complex YOLO use single stage pipelines.\n\nIn their seminal work Qi et al.~\\cite{pointnet, pointnetplusplus} proposed a simple architecture, PointNet, for learning from unordered point sets, which offered a path to full end-to-end learning.\nVoxelNet~\\cite{voxelnet} is one of the first methods to deploy PointNets for object detection in \\lidar point clouds.\nIn their method, PointNets are applied to voxels which are then processed by a set of 3D convolutional layers followed by a 2D backbone and a detection head.\nThis enables end-to-end learning, but like the earlier work that relied on 3D convolutions, VoxelNet is slow, requiring 225ms inference time ($4.4~H\\hspace{-.5mm}z$) for a single point cloud.\nAnother recent method, Frustum PointNet~\\cite{frustum}, uses PointNets to segment and classify the point cloud in a frustum generated from projecting a detection on an image into 3D.\nFrustum PointNet's achieved high benchmark performance compared to other fusion methods, but its multi-stage design makes end-to-end learning impractical.\nVery recently SECOND~\\cite{second} offered a series of improvements to VoxelNet resulting in stronger performance and a much improved speed of $20~H\\hspace{-.5mm}z$.\nHowever, they were unable to remove the expensive 3D convolutional layers.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
                    }
                },
                "subsection 1.2": {
                    "name": "Contributions",
                    "content": "\n\\squeeze\n\\begin{itemize}\n\\setlength\\itemsep{1mm}\n\\item We propose a novel point cloud encoder and network, PointPillars, that operates on the point cloud to enable end-to-end training of a 3D object detection network.\n\\item We show how all computations on pillars can be posed as dense 2D convolutions which enables inference at \\hertz; a factor of 2-4 times faster than other methods.\n\\item We conduct experiments on the KITTI dataset and demonstrate state of the art results on cars, pedestrians, and cyclists on both BEV and 3D benchmarks.\n\\item We conduct several ablation studies to examine the key factors that enable a strong detection performance.\n\\end{itemize}\n\n% !TEX root = ../pointpillar.tex\n\n\n\n\n\n"
                }
            },
            "section 2": {
                "name": "PointPillars Network",
                "content": " \\label{sec:network}\n\\squeeze\n\nPointPillars accepts point clouds as input and estimates oriented 3D boxes for cars, pedestrians and cyclists.\nIt consists of three main stages (\\figref{fig:pointpillar}):\n(1) A feature encoder network that converts a point cloud to a sparse pseudo-image;\n(2) a 2D convolutional backbone to process the pseudo-image into high-level representation; and\n(3) a detection head that detects and regresses 3D boxes.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n",
                "subsection 2.1": {
                    "name": "Pointcloud to Pseudo-Image",
                    "content": "\n\\label{sec:pointpillars}\n\\label{sec:create-stacked-pillars}\nTo apply a 2D convolutional architecture, we first convert the point cloud to a pseudo-image.\n\nWe denote by $l$ a point in a point cloud with coordinates $x$, $y$, $z$ and reflectance $r$.\nAs a first step the point cloud is discretized into an evenly spaced grid in the x-y plane, creating a set of pillars $\\mathcal{P}$ with $|\\mathcal{P}| = B$.\nNote that there is no need for a hyper parameter to control the binning in the z dimension.\nThe points in each pillar are then augmented with $x_{c}$, $y_{c}$, $z_{c}$, $x_{p}$ and $y_{p}$ where the $c$ subscript denotes distance to the arithmetic mean of all points in the pillar and the $p$ subscript denotes the offset from the pillar $x, y$ center. The augmented lidar point $l$ is now $D=9$ dimensional.\n\nThe set of pillars will be mostly empty due to sparsity of the point cloud, and the non-empty pillars will in general have few points in them.\nFor example, at $0.16^2~m^2$ bins the point cloud from an HDL-64E Velodyne lidar has 6k-9k non-empty pillars in the range typically used in KITTI for $\\sim 97\\%$ sparsity.\nThis sparsity is exploited by imposing a limit both on the number of non-empty pillars per sample ($P$) and on the number of points per pillar ($N$) to create a dense tensor of size $(D, P, N)$. \nIf a sample or pillar holds too much data to fit in this tensor the data is randomly sampled. \nConversely, if a sample or pillar has too little data to populate the tensor, zero padding is applied.\n\nNext, we use a simplified version of PointNet where, for each point, a linear layer is applied followed by BatchNorm~\\cite{batchnorm} and ReLU~\\cite{relu} to generate a $(C, P, N)$ sized tensor. \nThis is followed by a max operation over the channels to create an output tensor of size $(C, P)$. \nNote that the linear layer can be formulated as a 1x1 convolution across the tensor resulting in very efficient computation.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\label{sec:stacked-to-pseudo}\nOnce encoded, the features are scattered back to the original pillar locations to create a pseudo-image of size $(C, H, W)$ where $H$ and $W$ indicate the height and width of the canvas.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\squeeze\n"
                },
                "subsection 2.2": {
                    "name": "Backbone",
                    "content": "\n\\squeeze\nWe use a similar backbone as~\\cite{voxelnet} and the structure is shown in Figure \\ref{fig:pointpillar}.\nThe backbone has two sub-networks:\none top-down network that produces features at increasingly small spatial resolution and a second network that performs upsampling and concatenation of the top-down features.\nThe top-down backbone can be characterized by a series of blocks Block($S$, $L$, $F$).\nEach block operates at stride $S$ (measured relative to the original input pseudo-image).\nA block has $L$ 3x3 2D conv-layers with $F$ output channels, each followed by BatchNorm and a ReLU.\nThe first convolution inside the layer has stride $\\frac{S}{S_{in}}$ to ensure the block operates on stride $S$ after receiving an input blob of stride $S_{in}$.\nAll subsequent convolutions in a block have stride 1.\n\nThe final features from each top-down block are combined through upsampling and concatenation as follows.\nFirst, the features are upsampled, Up($S_{in}$, $S_{out}$, $F$) from an initial stride $S_{in}$ to a final stride $S_{out}$ (both again measured wrt. original pseudo-image) using a transposed 2D convolution with $F$ final features.\nNext, BatchNorm and ReLU is applied to the upsampled features.\nThe final output features are a concatenation of all features that originated from different strides.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\squeeze\n"
                },
                "subsection 2.3": {
                    "name": "Detection Head",
                    "content": "\n\\squeeze\nIn this paper, we use the Single Shot Detector (SSD)~\\cite{ssd} setup to perform 3D object detection.\nSimilar to SSD, we match the priorboxes to the ground truth using 2D Intersection over Union~(IoU) ~\\cite{pascal}.\nBounding box height and elevation were not used for matching; instead given a 2D match, the height and elevation become additional regression targets.\n\n\n% !TEX root = ../pointpillar.tex\n\n"
                }
            },
            "section 3": {
                "name": "Implementation Details",
                "content": " \\label{sec:training}\n\\squeeze\nIn this section we describe our network parameters and the loss function that we optimize for.\n\n",
                "subsection 3.1": {
                    "name": "Network",
                    "content": "\n\\squeeze\nInstead of pre-training our networks, all weights were initialized randomly using a uniform distribution as in~\\cite{heInit}. \n\nThe encoder network has $C=64$ output features.\nThe car and pedestrian/cyclist backbones are the same except for the stride of the first block ($S=2$ for car, $S=1$ for pedestrian/cyclist).\nBoth network consists of three blocks, Block1($S$, 4, C), Block2($2S$, 6, 2C), and Block3($4S$, 6, 4C).\nEach block is upsampled by the following upsampling steps: Up1($S$, $S$, 2C), Up2($2S$, $S$, 2C) and Up3($4S$, $S$, 2C).\nThen the features of Up1, Up2 and Up3 are concatenated together to create 6C features for the detection head.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n"
                },
                "subsection 3.2": {
                    "name": "Loss",
                    "content": "\n\\squeeze\nWe use the same loss functions introduced in SECOND~\\cite{second}.\nGround truth boxes and anchors are defined by $(x, y, z, w, l, h, \\theta)$.\nThe localization regression residuals between ground truth and anchors are defined by:\n\\begin{eqnarray*}\n\\left.\\begin{aligned}\n\\Delta x &= \\frac{x^{gt} - x^a}{d^a}, \\Delta y = \\frac{y^{gt} - y^a}{d^a}, \\Delta z = \\frac{z^{gt} - z^a}{h^a} \\\\\n\\Delta w &= \\log{\\frac{w^{gt}}{w^a}}, \\Delta l = \\log{\\frac{l^{gt}}{l^a}}, \\Delta h = \\log{\\frac{h^{gt}}{h^a}} \\\\\n\\Delta \\theta &= \\sin{\\left(\\theta^{gt} - \\theta^a\\right)},\n\\end{aligned}\\right.\n\\end{eqnarray*}\nwhere $x^{gt}$ and $x^a$ are respectively the ground truth and anchor boxes and $d^a = \\sqrt{(w^{a})^2+(l^{a})^2}$.\nThe total localization loss is:\n\\begin{eqnarray*}\n\\mathcal{L}_{loc} = \\sum_{b \\in (x, y, z, w, l, h, \\theta)} \\text{SmoothL1}\\left(\\Delta b\\right)\n\\end{eqnarray*}\n\nSince the angle localization loss cannot distinguish flipped boxes, we use a softmax classification loss on the discretized directions~\\cite{second}, $\\mathcal{L}_{dir}$, which enables the network to learn the heading.\n\nFor the object classification loss, we use the focal loss~\\cite{retinanet}:\n\n\\begin{eqnarray*}\n\\mathcal{L}_{cls}= -\\alpha_a \\left(1 - p^a\\right) ^ \\gamma \\log p^a,\n\\end{eqnarray*}\n\\squeeze\nwhere $p^a$ is the class probability of an anchor.\nWe use the original paper settings of $\\alpha=0.25$ and $\\gamma=2$.\nThe total loss is therefore: \n\\squeeze\n\\begin{eqnarray*}\n\\mathcal{L} &= \\frac{1}{N_{pos}}\\left(\\beta_{loc} \\mathcal{L}_{loc} + \\beta_{cls} \\mathcal{L}_{cls}  + \\beta_{dir} \\mathcal{L}_{dir}\\right),\n\\end{eqnarray*}\n\\squeeze\nwhere $N_{pos}$ is the number of positive anchors and $\\beta_{loc}=2$, $\\beta_{cls}=1$, and $\\beta_{dir}=0.2$.\n\nTo optimize the loss function we use the Adam optimizer with an initial learning rate of $2*10^{-4}$ and decay the learning rate by a factor of $0.8$ every $15$ epochs and train for $160$ epochs.\nWe use a batch size of 2 for validation set and 4 for our test submission.\n% !TEX root = ../pointpillar.tex\n\n\n\n\n\n\n\n"
                }
            },
            "section 4": {
                "name": "Experimental setup",
                "content": "\n\\squeeze\nIn this section we present our experimental setup, including dataset, experimental settings and data augmentation.\n\n",
                "subsection 4.1": {
                    "name": "Dataset",
                    "content": "\n\\squeeze\nAll experiments use the KITTI object detection benchmark dataset~\\cite{kitti}, which consists of samples that have both lidar point clouds and images.\nWe only train on lidar point clouds, but compare with fusion methods that use both lidar and images.\nThe samples are originally divided into 7481 training and 7518 testing samples.\nFor experimental studies we split the official training into 3712 training samples and 3769 validation samples~\\cite{chen20153d}, while for our test submission we created a minival set of 784 samples from the validation set and trained on the remaining 6733 samples.\nThe KITTI benchmark requires detections of cars, pedestrians, and cyclists.\nSince the ground truth objects were only annotated if they are visible in the image, we follow the standard convention~\\cite{mv3d, voxelnet} of only using \\lidar points that project into the image.\nFollowing the standard literature practice on KITTI~\\cite{avod,voxelnet,second}, we train one network for cars and one network for both pedestrians and cyclists.\n\n\\squeeze\n"
                },
                "subsection 4.2": {
                    "name": "Settings",
                    "content": "\n\\squeeze\n\nUnless explicitly varied in an experimental study, we use an xy resolution: \\xyres m,  max number of pillars ($P$): \\maxpillars, and  max number of points per pillar ($N$): \\maxpts.\n\nWe use the same anchors and matching strategy as~\\cite{voxelnet}.\nEach class anchor is described by a width, length, height, and z center, and is applied at two orientations: 0 and 90 degrees.\nAnchors are matched to ground truth using the 2D IoU with the following rules.\nA positive match is either the highest with a ground truth box, or above the positive match threshold, while a negative match is below the negative threshold.\nAll other anchors are ignored in the loss.\n\nAt inference time we apply axis aligned non maximum suppression (NMS) with an overlap threshold of $0.5$ IoU.\nThis provides similar performance compared to rotational NMS, but is much faster.\n\n\\mypar{Car.}\nThe x, y, z range is [(0, 70.4), (-40, 40), (-3, 1)] meters respectively.\nThe car anchor has width, length, and height of (1.6, 3.9, 1.5) m with a z center of -1 m.\nMatching uses positive and negative thresholds of 0.6 and 0.45.\n\n\\mypar{Pedestrian \\& Cyclist.}\nThe x, y, z range of [(0, 48), (-20, 20), (-2.5, 0.5)] meters respectively.\nThe pedestrian anchor has width, length, and height of (0.6, 0.8, 1.73) meters with a z center of -0.6 meters, while the cyclist anchor has width, length, and height of (0.6, 1.76, 1.73) meters with a z center of -0.6 meters.\nMatching uses positive and negative thresholds of 0.5 and 0.35.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\squeeze\n"
                },
                "subsection 4.3": {
                    "name": "Data Augmentation",
                    "content": "\n\\squeeze\nData augmentation is critical for good performance on the KITTI benchmark~\\cite{second, pixor, mv3d}.\n\nFirst, following SECOND~\\cite{second}, we create a lookup table of the ground truth 3D boxes for all classes and the associated point clouds that falls inside these 3D boxes.\nThen for each sample, we randomly select $15, 0, 8$ ground truth samples for cars, pedestrians, and cyclists respectively and place them into the current point cloud.\nWe found these settings to perform better than the proposed settings~\\cite{second}.\n\nNext, all ground truth boxes are individually augmented.\nEach box is rotated (uniformly drawn from $[-\\pi/20, \\pi/20]$) and translated (x, y, and z independently drawn from $\\mathcal{N}(0, 0.25)$) to further enrich the training set.\n\nFinally, we perform two sets of global augmentations that are jointly applied to the point cloud and all boxes.\nFirst, we apply random mirroring flip along the x axis~\\cite{pixor}, then a global rotation and scaling~\\cite{voxelnet, second}.\nFinally, we apply a global translation with x, y, z drawn from $\\mathcal{N}(0, 0.2)$ to simulate localization noise.\n\n"
                }
            },
            "section 5": {
                "name": "Results",
                "content": " \\label{sec:results}\n\\squeeze\n\nIn this section we present results of our PointPillars method and compare to the literature.\n\n\\squeeze\n\\mypar{Quantitative Analysis.}\nAll detection results are measured using the official KITTI evaluation detection metrics which are: bird's eye view (BEV), 3D, 2D, and average orientation similarity (AOS).\nThe 2D detection is done in the image plane and average orientation similarity assesses the average orientation (measured in BEV) similarity for 2D detections.\nThe KITTI dataset is stratified into easy, moderate, and hard difficulties, and the official KITTI leaderboard is ranked by performance on moderate.\n\nAs shown in \\tableref{table:res_bev} and \\tableref{table:res_3d}, PointPillars outperforms all published methods with respect to mean average precision (mAP).\nCompared to lidar-only methods, PointPillars achieves better results across all classes and difficulty strata except for the easy car stratum.\nIt also outperforms fusion based methods on cars and cyclists.\n\nWhile PointPillars predicts 3D oriented boxes, the BEV and 3D metrics do not take orientation into account.\nOrientation is evaluated using AOS~\\cite{kitti}, which requires projecting the 3D box into the image, performing 2D detection matching, and then assessing the orientation of these matches.\nThe performance of PointPillars on AOS significantly exceeds in all strata as compared to the only two 3D detection methods~\\cite{avod,second} that predict oriented boxes (\\tableref{table:res_aos}).\nIn general, image only methods perform best on 2D detection since the 3D projection of boxes into the image can result in loose boxes depending on the 3D pose.\nDespite this, PointPillars moderate cyclist AOS of 68.16 outperforms the best image based method~\\cite{xiang2017subcategory}.\n\nFor comparison to other methods on val, we note that our network achieved BEV AP of ($87.98$, $63.55$, $69.71$) and 3D AP of ($77.98$, $57.86$, $66.02$) for the moderate strata of cars, pedestrians, and cyclists respectively.\n\n\\squeeze\n\\mypar{Qualitative Analysis.}\nWe provide qualitative results in \\figref{fig:kitti_visualize} and \\ref{fig:kitti_failure}.\nWhile we only train on lidar point clouds, for ease of interpretation we visualize the 3D bounding box predictions from the BEV and image perspective.\n\\figref{fig:kitti_visualize} shows our detection results, with tight oriented 3D bounding boxes.\nThe predictions for cars are particularly accurate and common failure modes include false negatives on difficult samples (partially occluded or faraway objects) or false positives on similar classes (vans or trams).\nDetecting pedestrians and cyclists is more challenging and leads to some interesting failure modes.\nPedestrians and cyclists are commonly misclassified as each other (see \\figref{fig:kitti_failure}a for a standard example and \\figref{fig:kitti_failure}d for the combination of pedestrian and table classified as a cyclist).\nAdditionally, pedestrians are easily confused with narrow vertical features of the environment such as poles or tree trunks (see \\figref{fig:kitti_failure}b).\nIn some cases we correctly detect objects that are missing in the ground truth annotations (see \\figref{fig:kitti_failure}c).\n\n\n% !TEX root = ../pointpillar.tex\n\n"
            },
            "section 6": {
                "name": "Realtime Inference",
                "content": " \\label{sec:runtime}\n\\squeeze\nAs indicated by our results (\\tableref{table:res_bev} and \\figref{fig:speed_accuracy_val}), PointPillars represent a significant improvement in terms of inference runtime.\nIn this section we break down our runtime and consider the different design choices that enabled this speedup.\nWe focus on the car network, but the pedestrian and bicycle network runs at a similar speed since the smaller range cancels the effect of the backbone operating at lower strides.\nAll runtimes are measured on a desktop with an Intel i7 CPU and a 1080ti GPU.\n\nThe main inference steps are as follows.\nFirst, the point cloud is loaded and filtered based on range and visibility in the images ($1.4~ms$).\nThen, the points are organized in pillars and decorated ($2.7~ms$).\nNext, the PointPillar tensor is uploaded to the GPU ($2.9~ms$), encoded ($1.3~ms$), scattered to the pseudo-image ($0.1~ms$), and processed by the backbone and detection heads ($7.7~ms$).\nFinally NMS is applied on the CPU ($0.1~ms$) for a total runtime of $16.2~ms$.\n\n\\mypar{Encoding.}\nThe key design to enable this runtime is the PointPilar encoding.\nFor example, at $1.3~ms$ it is 2 orders of magnitude faster than the VoxelNet encoder ($190~ms$)~\\cite{voxelnet}.\nRecently, SECOND proposed a faster sparse version of the VoxelNet encoder for a total network runtime of $50~ms$.\nThey did not provide a runtime analysis, but since the rest of their architecture is similar to ours, it suggests that the encoder is still significantly slower; in their open source implementation\\footnote{https://github.com/traveller59/second.pytorch/} the encoder requires $48~ms$.\n\n\\mypar{Slimmer Design.}\nWe opt for a single PointNet in our encoder, compared to 2 sequential PointNets suggested by~\\cite{voxelnet}.\nThis reduced our runtime by $2.5~ms$ in our PyTorch runtime.\nThe number of dimensions of the first block were also lowered $64$ to match the encoder output size, which reduced the runtime by $4.5~ms$.\nFinally, we saved another $3.9~ms$ by cutting the output dimensions of the upsampled feature layers by half to $128$.\nNeither of these changes affected detection performance.\n\n\\mypar{TensorRT.}\nWhile all our experiments were performed in PyTorch~\\cite{pytorch}, the final GPU kernels for encoding, backbone and detection head were built using NVIDIA TensorRT, which is a library for optimized GPU inference. \nSwitching to TensorRT gave a $45.5\\%$ speedup from the PyTorch pipeline which runs at $42.4~H\\hspace{-.5mm}z$.\n\n\\mypar{The Need for Speed.}\nAs seen in \\figref{fig:speed_accuracy_val}, PointPillars can achieve \\maxhertz with limited loss of accuracy.\nWhile it could be argued that such runtime is excessive since a \\lidar typically operates at $20~H\\hspace{-.5mm}z$, there are two key things to keep in mind.\nFirst, due to an artifact of the KITTI ground truth annotations, only \\lidar points which projected into the front image are utilized, which is only $\\sim 10\\%$ of the entire point cloud. However, an operational AV needs to view the full environment and process the complete point cloud, significantly increasing all aspects of the runtime.\nSecond, timing measurements in the literature are typically done on a high-power desktop GPU. However, an operational AV may instead use embedded GPUs or embedded compute which may not have the same throughput.\n\n% !TEX root = ../pointpillar.tex\n\n"
            },
            "section 7": {
                "name": "Ablation Studies",
                "content": " \\label{sec:exp}\n\\squeeze\nIn this section we provide ablation studies and discuss our design choices compared to the recent literature.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\squeeze\n",
                "subsection 7.1": {
                    "name": "Spatial Resolution",
                    "content": "\n\\squeeze\nA trade-off between speed and accuracy can be achieved by varying the size of the spatial binning.\nSmaller pillars allow finer localization and lead to more features, while larger pillars are faster due to fewer non-empty pillars (speeding up the encoder) and a smaller pseudo-image (speeding up the CNN backbone).\nTo quantify this effect we performed a sweep across grid sizes.\nFrom \\figref{fig:speed_accuracy_val} it is clear that the larger bin sizes lead to faster networks; at $0.28^2$ we achieve \\maxhertz at similar performance to previous methods.\nThe decrease in performance was mainly due to the pedestrian and cyclist classes, while car performance was stable across the bin sizes.\n\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\squeeze\n"
                },
                "subsection 7.2": {
                    "name": "Per Box Data Augmentation",
                    "content": "\n\\squeeze\n\\label{sec:box_aug}\nBoth VoxelNet~\\cite{voxelnet} and SECOND~\\cite{second} recommend extensive per box augmentation.\nHowever, in our experiments, minimal box augmentation worked better.\nIn particular, the detection performance for pedestrians degraded significantly with more box augmentation.\nOur hypothesis is that the introduction of ground truth sampling mitigates the need for extensive per box augmentation.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\squeeze\n"
                },
                "subsection 7.3": {
                    "name": "Point Decorations",
                    "content": "\n\\squeeze\n\\label{sec:decoration}\nDuring the lidar point decoration step, we perform the VoxelNet~\\cite{voxelnet} decorations plus two additional decorations:\n$x_{p}$ and $y_{p}$ which are the $x$ and $y$ offset from the pillar $x, y$ center.\nThese extra decorations added 0.5 mAP to final detection performance and provided more reproducible experiments.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\squeeze\n"
                },
                "subsection 7.4": {
                    "name": "Encoding",
                    "content": "\n\\squeeze\n\\label{sec:encoding}\nTo assess the impact of the proposed PointPillar encoding in isolation, we implemented several encoders in the official codebase of SECOND~\\cite{second}.\nFor details on each encoding, we refer to the original papers.\n\n\nAs shown in \\tableref{table:encode}, learning the feature encoding is strictly superior to fixed encoders across all resolution.\nThis is expected as most successful deep learning architectures are trained end-to-end.\nFurther, the differences increase with larger bin sizes where the lack of expressive power of the fixed encoders are accentuated due to a larger point cloud in each pillar.\nAmong the learned encoders VoxelNet is marginally stronger than PointPillars.\nHowever, this is not a fair comparison, since the VoxelNet encoder is orders of magnitude slower and has orders of magnitude more parameters.\nWhen the comparison is made for a similar \\emph{inference time}, it is clear that PointPillars offers a better operating point (\\figref{fig:speed_accuracy_val}).\n\nThere are a few curious aspects of \\tableref{table:encode}.\nFirst, despite notes in the original papers that their encoder only works on cars, we found that the MV3D~\\cite{mv3d} and PIXOR~\\cite{pixor} encoders can learn pedestrians and cyclists quite well.\nSecond, our implementations beat the respective published results by a large margin ($1-10$ mAP).\nWhile this is not an apples to apples comparison since we only used the respective \\emph{encoders} and not the full network architectures, the performance difference is noteworthy.\nWe see several potential reasons.\nFor VoxelNet and SECOND we suspect the boost in performance comes from improved data augmentation hyperparameters as discussed in \\secref{sec:box_aug}.\nAmong the fixed encoders, roughly half the performance increase can be explained by the introduction of ground truth database sampling~\\cite{second}, which we found to boost the mAP by around $3\\%$ mAP.\nThe remaining differences are likely due to a combination of multiple hyperparameters including network design (number of layers, type of layers, whether to use a feature pyramid); anchor box design (or lack thereof~\\cite{pixor}); localization loss with respect to 3D and angle; classification loss; optimizer choices (SGD vs Adam, batch size); and more.\nHowever, a more careful study is needed to isolate each cause and effect.\n\n\n% !TEX root = ../pointpillar.tex\n\\squeeze\n"
                }
            },
            "section 8": {
                "name": "Conclusion",
                "content": " \\label{sec:conclusion}\n\\squeeze\n\nIn this paper, we introduce PointPillars, a novel deep network and encoder that can be trained end-to-end on lidar point clouds.\nWe demonstrate that on the KITTI challenge, PointPillars dominates all existing methods by offering higher detection performance (mAP on both BEV and 3D) at a faster speed.\nOur results suggests that PointPillars offers the best architecture so far for 3D object detection from lidar.\n\n{\\small\n\\bibliographystyle{ieee}\n\\bibliography{references}\n}\n\n"
            }
        },
        "tables": {
            "table:res_bev": "\\begin{table*}[]\n\\small\n\\begin{tabular}{| c | c | c | c || c | c | c || c | c | c || c | c | c |}\n\\hline\n\\multirow{2}{*}{Method}\t\t\t\t& \\multirow{2}{*}{Modality}\t\t\t& \\multirow{2}{10mm}{Speed (Hz)}\t& mAP\t\t& \\multicolumn{3}{|c||}{Car}\t\t& \\multicolumn{3}{|c||}{Pedestrian}\t\t& \\multicolumn{3}{|c|}{Cyclist}\t\\\\ \\cline{4-13}\n\t\t\t\t\t&\t\t\t\t& \t\t& Mod.\t\t& Easy\t\t& Mod.\t\t& Hard\t\t& Easy\t\t& Mod.\t\t& Hard\t\t& Easy\t\t& Mod.\t\t& Hard\t\\\\ \\hline \nMV3D~\\cite{mv3d}\t\t& Lidar \\& Img.\t& 2.8\t\t& N/A\t\t& 86.02 \t\t& 76.90 \t\t& 68.49\t\t&  N/A\t\t&  N/A \t\t&  N/A\t\t&  N/A \t\t&  N/A \t\t&  N/A\t\\\\ \nCont-Fuse~\\cite{contfuse}\t\t& Lidar \\& Img.\t& 16.7\t\t\t& N/A\t\t& 88.81 \t\t& 85.83 \t\t& 77.33\t\t&  N/A\t\t&  N/A \t\t&  N/A\t\t&  N/A \t\t&  N/A \t\t&  N/A\t\\\\ \nRoarnet~\\cite{roarnet}\t\t& Lidar \\& Img.\t& 10\t\t& N/A\t\t& 88.20 \t\t& 79.41 \t\t& 70.02\t\t&  N/A\t\t&  N/A \t\t&  N/A\t\t&  N/A \t\t&  N/A \t\t&  N/A\t\\\\ \nAVOD-FPN~\\cite{avod}\t& Lidar \\& Img.\t& 10\t\t& 64.11\t\t& 88.53\t\t& 83.79 \t\t& 77.90\t\t& \\textbf{58.75}\t& \\textbf{51.05}\t& \\textbf{47.54}\t& 68.09 \t\t& 57.48\t\t& 50.77\t\\\\ \nF-PointNet~\\cite{frustum}\t&  Lidar \\& Img.\t& 5.9\t\t& 65.39\t\t& 88.70\t\t& 84.00 \t\t& 75.33\t\t& 58.09\t\t& 50.22\t\t& 47.20\t\t& 75.38\t\t& 61.96\t\t& 54.68\t\\\\ \\hline\nHDNET~\\cite{hdnet}\t&  Lidar \\& Map\t& 20\t\t& N/A\t\t& 89.14\t\t& \\textbf{86.57}\t\t& 78.32\t\t& N/A\t\t& N/A\t\t& N/A\t\t& N/A\t\t& N/A\t\t& N/A\t\\\\ \\hline\nPIXOR++~\\cite{hdnet}\t& Lidar\t\t\t& 35\t\t\t& N/A\t\t& \\textbf{89.38} & 83.70 \t\t& 77.97\t\t&  N/A\t\t&  N/A \t\t&  N/A\t\t&  N/A \t\t&  N/A \t\t&  N/A\t\\\\ \nVoxelNet~\\cite{voxelnet}\t& Lidar\t\t\t& 4.4\t\t& 58.25\t\t& 89.35\t& 79.26 \t\t& 77.39\t\t& 46.13\t\t& 40.74\t\t& 38.11\t\t& 66.70\t\t& 54.76\t\t& 50.55\t\\\\\nSECOND~\\cite{second}\t& Lidar\t\t\t& 20\t\t\t& 60.56\t\t& 88.07 \t\t& 79.37 \t\t& 77.95\t\t& 55.10 \t\t& 46.27\t\t& 44.76\t\t& 73.67\t\t& 56.04\t\t& 48.78\t\\\\ \\hline\nPointPillars\t\t\t& Lidar\t\t\t& \\textbf{62}\t& \\textbf{66.19}\t& 88.35\t\t& 86.10\t& \\textbf{79.83}\t& 58.66\t\t& 50.23\t\t& 47.19\t\t& \\textbf{79.14} & \\textbf{62.25} & \\textbf{56.00} \\\\ \\hline\n\\end{tabular}\n\\caption{Results on the KITTI test BEV detection benchmark.}\n\\label{table:res_bev}\n\\end{table*}",
            "table:res_3d": "\\begin{table*}[]\n\\small\n\\begin{tabular}{| c | c | c || c || c | c | c || c | c | c || c | c | c |}\n\\hline\n\\multirow{2}{*}{Method}\t\t\t\t& \\multirow{2}{*}{Modality}\t\t\t& \\multirow{2}{10mm}{Speed (Hz)}\t& mAP\t\t& \\multicolumn{3}{|c||}{Car}\t\t& \\multicolumn{3}{|c||}{Pedestrian}\t\t& \\multicolumn{3}{|c|}{Cyclist}\t\\\\ \\cline{4-13}\n\t\t\t\t\t&\t\t\t\t& \t\t& Mod.\t\t& Easy\t\t& Mod.\t\t& Hard\t\t& Easy\t\t& Mod.\t\t& Hard\t\t& Easy\t\t& Mod.\t\t& Hard\t\\\\ \\hline \nMV3D~\\cite{mv3d}\t\t& Lidar \\& Img.\t& 2.8\t\t& N/A\t\t& 71.09\t\t& 62.35 \t\t& 55.12\t\t&  N/A\t\t&  N/A \t\t\t&  N/A\t\t&  N/A \t\t&  N/A \t\t&  N/A\t\\\\ \nCont-Fuse~\\cite{contfuse}\t\t& Lidar \\& Img.\t& 16.7\t\t\t& N/A\t\t& 82.54\t\t&  66.22\t\t& 64.04\t\t&  N/A\t\t&  N/A \t\t\t&  N/A\t\t&  N/A \t\t&  N/A \t\t&  N/A\t\\\\ \nRoarnet~\\cite{roarnet}\t& Lidar \\& Img.\t& 10\t\t\t& N/A\t\t& \\textbf{83.71}\t\t&  73.04\t\t& 59.16\t\t&  N/A\t\t&  N/A \t\t\t&  N/A\t\t&  N/A \t\t&  N/A \t\t&  N/A\t\\\\ \nAVOD-FPN~\\cite{avod}\t& Lidar \\& Img.\t& 10\t\t& 55.62\t\t& 81.94 \t \t& 71.88\t \t& 66.38\t\t& 50.80\t\t& 42.81\t\t\t& 40.88\t& 64.00\t \t& 52.18\t\t& 46.61\t\\\\ \nF-PointNet~\\cite{frustum}\t&  Lidar \\& Img.\t& 5.9\t\t& 57.35\t\t& 81.20\t\t& 70.39 \t \t& 62.19\t\t& 51.21\t\t& \\textbf{44.89}\t\t& 40.23\t\t& 71.96\t& 56.77 & 50.39\t\\\\ \\hline\nVoxelNet~\\cite{voxelnet}\t& Lidar\t\t\t& 4.4\t\t& 49.05\t\t& 77.47\t\t& 65.11  \t\t& 57.73\t\t& 39.48\t\t& 33.69\t\t\t& 31.5\t\t& 61.22\t\t& 48.36\t\t& 44.37\t\\\\\nSECOND~\\cite{second}\t& Lidar\t\t\t& 20\t\t\t& 56.69\t\t& 83.13 \t& 73.66\t \t& 66.20\t\t& 51.07\t\t& 42.56\t\t\t& 37.29\t\t& 70.51\t\t& 53.85 \t\t& 46.90 \t\\\\ \\hline\nPointPillars\t\t\t& Lidar\t\t\t& \\textbf{62} \t& \\textbf{59.20}\t& 79.05\t\t& \\textbf{74.99}\t& \\textbf{68.30}\t& \\textbf{52.08}\t& 43.53\t\t\t& \\textbf{41.49}\t\t& \\textbf{75.78} \t\t& \\textbf{59.07}\t\t& \\textbf{52.92}\t\\\\ \\hline\n\\end{tabular}\n\\caption{Results on the KITTI test 3D detection benchmark.}\n\\label{table:res_3d}\n\\end{table*}",
            "table:res_aos": "\\begin{table*}[]\n\\small\n\\begin{tabular}{| c | c | c || c || c | c | c || c | c | c || c | c | c |}\n\\hline\n\\multirow{2}{*}{Method}\t\t\t\t& \\multirow{2}{*}{Modality}\t\t\t& \\multirow{2}{10mm}{Speed (Hz)}\t& mAOS\t\t& \\multicolumn{3}{|c||}{Car}\t\t& \\multicolumn{3}{|c||}{Pedestrian}\t\t& \\multicolumn{3}{|c|}{Cyclist}\t\\\\ \\cline{4-13}\n\t\t\t\t\t&\t\t\t\t& \t\t& Mod.\t\t& Easy\t\t& Mod.\t\t& Hard\t\t& Easy\t\t& Mod.\t\t& Hard\t\t& Easy\t\t& Mod.\t\t& Hard\t\\\\ \\hline \nSubCNN~\\cite{xiang2017subcategory}\t& Img.\t& 0.5\t\t& \\textbf{72.71}\t\t&  \\textbf{90.61} \t \t& 88.43 \t \t& 78.63\t\t&  \\textbf{78.33}\t\t& \\textbf{66.28}\t& \\textbf{61.37} \t& 71.39\t & 63.41\t& 56.34 \t\\\\ \\hline\n\nAVOD-FPN~\\cite{avod}\t& Lidar \\& Img.\t& 10\t\t& 63.19\t\t& 89.95  \t \t&  87.13\t \t& 79.74\t\t& 53.36 \t\t& 44.92\t\t\t& 43.77 \t& 67.61\t \t& 57.53 \t\t& 54.16\t\\\\ \\hline\nSECOND~\\cite{second}\t& Lidar\t\t\t& 20\t\t\t& 54.53\t\t& 87.84  & 81.31\t \t& 71.95\t\t& 51.56\t\t& 43.51\t\t\t& 38.78\t\t& 80.97 \t\t& 57.20 \t\t& 55.14 \t\\\\ \\hline\nPointPillars\t\t\t& Lidar\t\t\t& \\textbf{62} \t& 68.86\t& 90.19\t\t& \\textbf{88.76}\t& \\textbf{86.38}\t& 58.05\t& 49.66\t\t& 47.88\t\t& \\textbf{82.43} \t\t& \\textbf{68.16}\t\t& \\textbf{61.96 }\t\\\\ \\hline\n\\end{tabular}\n\\caption{Results on the KITTI test average orientation similarity (AOS) detection benchmark. SubCNN is the best performing image only method, while AVOD-FPN, SECOND, and PointPillars are the only 3D object detectors that predict orientation.}\\label{table:res_aos}\n\n\\end{table*}",
            "table:encode": "\\begin{table}[]\n\\small\n\\begin{tabular}{*{6}{| c} |}\n\\hline\n\\textbf{Encoder} \t\t\t\t& \\textbf{Type}\t\t& $\\mathbf{0.16^2}$ \t\t&$\\mathbf{0.20^2}$  \t\t& $\\mathbf{0.24^2}$\t\t& $\\mathbf{0.28^2}$\t\t\\\\ \\hline \\hline \nMV3D~\\cite{mv3d}\t\t\t\t& Fixed\t\t\t& 72.8\t\t\t\t& 71.0\t\t\t\t& 70.8\t\t\t& 67.6\t\t\t\\\\ \\hline\nC. Yolo~\\cite{complexyolo}\t\t& Fixed\t\t\t& 72.0\t\t    \t\t& 72.0\t\t\t\t& 70.6\t\t\t& 66.9\t\t\t\\\\ \\hline\nPIXOR~\\cite{pixor} \t\t\t\t& Fixed\t\t\t& 72.9\t\t    \t\t& 71.3\t\t\t\t& 69.9\t\t\t& 65.6\t\t\t\\\\ \\hline \\hline\nVoxelNet~\\cite{voxelnet}\t\t\t& Learned\t\t\t& \\textbf{74.4}\t\t\t\t& \\textbf{74.0}\t\t\t\t& \\textbf{72.9}\t\t\t& 71.9 \t\\\\ \\hline\nPointPillars\t\t\t\t\t& Learned\t\t\t& 73.7\t\t\t\t& 72.6\t\t\t\t& \\textbf{72.9}\t\t\t& \\textbf{72.0}\t\t\t\\\\ \\hline\n\\end{tabular}\n\\caption{Encoder performance evaluation.\nTo fairly compare encoders, the same network architecture and training procedure was used and only the encoder and xy resolution were changed between experiments.\nPerformance is measured as BEV mAP on KITTI val.\nLearned encoders clearly beat fixed encoders, especially at larger resolutions.\n}\n\\label{table:encode}\n\\end{table}"
        },
        "figures": {
            "fig:speed_accuracy": "\\begin{figure}\n\\begin{center}\n\\includegraphics[width = 8.3cm]{./figures/acc_speed_testset.pdf}\n\\end{center}\n\\squeeze\n\\caption{Bird's eye view performance vs speed for our proposed PointPillars, \\framebox{PP} method on the KITTI~\\cite{kitti} test set.\nLidar-only methods drawn as blue circles; \\lidar \\& vision methods drawn as red squares.\nAlso drawn are top methods from the KITTI leaderboard: \\framebox{M}: MV3D~\\cite{mv3d}, \\framebox{A} AVOD~\\cite{avod}, \\framebox{C}: ContFuse~\\cite{contfuse}, \\framebox{V}: VoxelNet~\\cite{voxelnet}, \\framebox{F}: Frustum PointNet~\\cite{frustum}, \\framebox{S}: SECOND~\\cite{second}, \\framebox{P+} PIXOR++~\\cite{hdnet}.\nPointPillars outperforms all other \\lidar-only methods in terms of both speed and accuracy by a large margin.\nIt also outperforms all fusion based method except on pedestrians. \nSimilar performance is achieved on the 3D metric (\\tableref{table:res_3d}). \n }\n\\label{fig:speed_accuracy}\n\\end{figure}",
            "fig:network": "\\begin{figure*}\n\\begin{center}\n\\includegraphics[width = 1.0\\textwidth]{./figures/method.pdf}\n\\end{center}\n\\squeeze\n\\caption{Network overview.\nThe main components of the network are a Pillar Feature Network, Backbone, and SSD Detection Head.\nSee Section \\ref{sec:network} for more details.\nThe raw point cloud is converted to a stacked pillar tensor and pillar index tensor.\nThe encoder uses the stacked pillars to learn a set of features that can be scattered back to a 2D pseudo-image for a convolutional neural network.\nThe features from the backbone are used by the detection head to predict 3D bounding boxes for objects.\nNote: here we show the backbone dimensions for the car network.}\n\\label{fig:network}\n\\label{fig:pointpillar}\n\\end{figure*}",
            "fig:pointpillar": "\\begin{figure*}\n\\begin{center}\n\\includegraphics[width = 1.0\\textwidth]{./figures/method.pdf}\n\\end{center}\n\\squeeze\n\\caption{Network overview.\nThe main components of the network are a Pillar Feature Network, Backbone, and SSD Detection Head.\nSee Section \\ref{sec:network} for more details.\nThe raw point cloud is converted to a stacked pillar tensor and pillar index tensor.\nThe encoder uses the stacked pillars to learn a set of features that can be scattered back to a 2D pseudo-image for a convolutional neural network.\nThe features from the backbone are used by the detection head to predict 3D bounding boxes for objects.\nNote: here we show the backbone dimensions for the car network.}\n\\label{fig:network}\n\\label{fig:pointpillar}\n\\end{figure*}",
            "fig:kitti_visualize": "\\begin{figure*}\n\\begin{center}\n\\includegraphics[width = 1.0\\textwidth]{./figures/kitti-results-narrow-good.pdf}\n\\end{center}\n\\caption{Qualitative analysis of KITTI results.\nWe show a bird's-eye view of the lidar point cloud (top), as well as the 3D bounding boxes projected into the image for clearer visualization.\nNote that our method \\textit{only} uses lidar.\nWe show predicted boxes for car (orange), cyclist (red) and pedestrian (blue).\nGround truth boxes are shown in gray.\nThe orientation of boxes is shown by a line connected the bottom center to the front of the box.\n}\n\\label{fig:kitti_visualize}\n\\end{figure*}",
            "fig:kitti_failure": "\\begin{figure*}\n\\begin{center}\n\\includegraphics[width = 1.0\\textwidth]{./figures/kitti-results-narrow-bad.pdf}\n\\end{center}\n\\caption{Failure cases on KITTI.\nSame visualize setup from \\figref{fig:kitti_visualize} but focusing on several common failure modes.\n}\n\\label{fig:kitti_failure}\n\\end{figure*}",
            "fig:speed_accuracy_val": "\\begin{figure}\n\\begin{center}\n\\includegraphics[width = 6cm]{./figures/speed_vs_accuracy_joint.pdf}\n\\end{center}\n\\vspace{-3mm}\n\\caption{BEV detection performance (mAP) vs speed (Hz) on the KITTI~\\cite{kitti} val set across pedestrians, bicycles and cars.\nBlue circles indicate \\lidar only methods, red squares indicate methods that use \\lidar \\& vision.\nDifferent operating points were achieved by using pillar grid sizes in $\\{0.12^2, 0.16^2, 0.2^2, 0.24^2, 0.28^2\\}$ $m^2$. The number of max-pillars was varied along with the resolution and set to $16000, 12000, 12000, 8000, 8000$ respectively.\n}\n\\label{fig:speed_accuracy_val}\n\\end{figure}"
        },
        "git_link": "https://github.com/nutonomy/second.pytorch"
    }
}